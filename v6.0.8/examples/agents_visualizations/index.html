<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plotting and Interactivity · Agents.jl</title><meta name="title" content="Plotting and Interactivity · Agents.jl"/><meta property="og:title" content="Plotting and Interactivity · Agents.jl"/><meta property="twitter:title" content="Plotting and Interactivity · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../flock/">Flocking model</a></li><li><a class="tocitem" href="../zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../event_rock_paper_scissors/">Spatial rock-paper-scissors (event based)</a></li><li><a class="tocitem" href="../">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li class="is-active"><a class="tocitem" href>Plotting and Interactivity</a><ul class="internal"><li><a class="tocitem" href="#Static-plotting-of-ABMs"><span>Static plotting of ABMs</span></a></li><li><a class="tocitem" href="#Interactive-ABM-Applications"><span>Interactive ABM Applications</span></a></li><li><a class="tocitem" href="#ABM-Videos"><span>ABM Videos</span></a></li><li><a class="tocitem" href="#Agent-inspection"><span>Agent inspection</span></a></li><li><a class="tocitem" href="#Creating-custom-ABM-plots"><span>Creating custom ABM plots</span></a></li><li><a class="tocitem" href="#GraphSpace-models"><span>GraphSpace models</span></a></li></ul></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Plotting and Interactivity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plotting and Interactivity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/agents_visualizations.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="vis_tutorial"><a class="docs-heading-anchor" href="#vis_tutorial">Visualizations and Animations for Agent Based Models</a><a id="vis_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#vis_tutorial" title="Permalink"></a></h1><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><p>This page describes functions that can be used with the <a href="https://docs.makie.org/stable/">Makie</a> plotting ecosystem to animate and interact with agent based models. ALl the functionality described here uses Julia&#39;s package extensions and therefore comes into scope once <code>Makie</code> (or any of its backends such as <code>CairoMakie</code>) gets loaded.</p><p>The animation at the start of the page is created using the code of this page, see below.</p><p>The docs are built using versions:</p><pre><code class="language- hljs">import Pkg
Pkg.status([&quot;Agents&quot;, &quot;CairoMakie&quot;];
    mode = PKGMODE_MANIFEST, io=stdout
)</code></pre><h2 id="Static-plotting-of-ABMs"><a class="docs-heading-anchor" href="#Static-plotting-of-ABMs">Static plotting of ABMs</a><a id="Static-plotting-of-ABMs-1"></a><a class="docs-heading-anchor-permalink" href="#Static-plotting-of-ABMs" title="Permalink"></a></h2><p>Static plotting, which is also the basis for creating custom plots that include an ABM plot, is done using the <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> function. Its usage is exceptionally straight-forward, and in principle one simply defines functions for how the agents should be plotted. Here we will use a pre-defined model, the Daisyworld as an example throughout this docpage. To learn about this model you can visit the <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/daisyworld/">example hosted at AgentsExampleZoo </a>,</p><pre><code class="language-julia hljs">using Agents, CairoMakie
using AgentsExampleZoo

model = AgentsExampleZoo.daisyworld(;
    solar_luminosity = 1.0, solar_change = 0.0, scenario = :change
)
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 360 agents of type Daisy
 agents container: Dict
 space: GridSpaceSingle with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, ratio, solar_change, tick, scenario</code></pre><p>Now, to plot daisyworld we provide a function for the color for the agents that depend on the agent properties, and a size and marker style that are constants,</p><pre><code class="language-julia hljs">daisycolor(a) = a.breed
agent_size = 20
agent_marker = &#39;✿&#39;
agentsplotkwargs = (strokewidth = 1.0,) # add stroke around each agent
fig, ax, abmobs = abmplot(model;
    agent_color = daisycolor, agent_size, agent_marker, agentsplotkwargs
)
fig # returning the figure displays it</code></pre><img src="11b28b3a.png" alt="Example block output"/><div class="admonition is-info"><header class="admonition-header">Supported keyword arguments</header><div class="admonition-body"><p>We do not check internally, if the keyword arguments passed to <code>abmplot</code> are supported. Please make sure that there are no typos and that the used kwargs are supported by the <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> function. Otherwise they will be ignored. This is an unfortunate consequence of how Makie.jl recipes work, and we believe that in the future this problem will be addressed in Makie.jl.</p></div></div><p>Besides agents, we can also plot spatial properties as a heatmap. Here we plot the temperature of the planet by providing the name of the property as the &quot;heat array&quot;:</p><pre><code class="language-julia hljs">heatarray = :temperature
heatkwargs = (colorrange = (-20, 60), colormap = :thermal)
plotkwargs = (;
    agent_color = daisycolor, agent_size, agent_marker,
    agentsplotkwargs = (strokewidth = 1.0,),
    heatarray, heatkwargs
)

fig, ax, abmobs = abmplot(model; plotkwargs...)
fig</code></pre><img src="0f421252.png" alt="Example block output"/><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmplot-examples-agents_visualizations" href="#Agents.abmplot-examples-agents_visualizations"><code>Agents.abmplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmplot(model::ABM; kwargs...) → fig, ax, abmobs
abmplot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmobs</code></pre><p>Plot an agent based model by plotting each individual agent as a marker and using the agent&#39;s position field as its location on the plot. The same function is used to make custom composite plots and animations for the model evolution using the returned <code>abmobs</code>. <code>abmplot</code> is also used to launch interactive GUIs for evolving agent based models, see &quot;Interactivity&quot; below.</p><p>See also <a href="../../api/#Agents.abmvideo"><code>abmvideo</code></a> and <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a>.</p><p><strong>Keyword arguments</strong></p><p><strong>Agent related</strong></p><ul><li><p><code>agent_color, agent_size, agent_marker</code> : These three keywords decide the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a <em>function</em>, which takes as an input a single agent and outputs the corresponding value. If the model uses a <code>GraphSpace</code>, <code>agent_color, agent_size, agent_marker</code> functions instead take an <em>iterable of agents</em> in each position (i.e. node of the graph).</p><p>Using constants: <code>agent_color = &quot;#338c54&quot;, agent_size = 15, agent_marker = :diamond</code></p><p>Using functions:</p><pre><code class="language-julia hljs">agent_color(a) = a.status == :S ? &quot;#2b2b33&quot; : a.status == :I ? &quot;#bf2642&quot; : &quot;#338c54&quot;
agent_size(a) = 10rand()
agent_marker(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect</code></pre><p>Notice that for 2D models, <code>agent_marker</code> can be/return a <code>Makie.Polygon</code> instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent&#39;s position when creating the polygon. In this case, the keyword <code>as</code> is meaningless, as each polygon has its own size. Use the functions <code>scale, rotate_polygon</code> to transform this polygon.</p><p>3D models currently do not support having different markers. As a result, <code>agent_marker</code> cannot be a function. It should be a <code>Mesh</code> or 3D primitive (such as <code>Sphere</code> or <code>Rect3D</code>).</p></li><li><p><code>offset = nothing</code> : If not <code>nothing</code>, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent&#39;s position (which matters only if there is overlap).</p></li><li><p><code>agentsplotkwargs = ()</code> : Additional keyword arguments propagated to the function that plots the agents (typically <code>scatter!</code>).</p></li></ul><p><strong>Preplot related</strong></p><ul><li><code>heatarray = nothing</code> : A keyword that plots a model property (that is a matrix) as a heatmap over the space. Its values can be standard data accessors given to functions like <code>run!</code>, i.e. either a symbol (directly obtain model property) or a function of the model. If the space is <code>AbstractGridSpace</code> then matrix must be the same size as the underlying space. For <code>ContinuousSpace</code> any size works and will be plotted over the space extent. For example <code>heatarray = :temperature</code> is used in the Daisyworld example. But you could also define <code>f(model) = create_matrix_from_model...</code> and set <code>heatarray = f</code>. The heatmap will be updated automatically during model evolution in videos and interactive applications.</li><li><code>heatkwargs = NamedTuple()</code> : Keywords given to <code>Makie.heatmap</code> function if <code>heatarray</code> is not nothing.</li><li><code>add_colorbar = true</code> : Whether or not a Colorbar should be added to the right side of the heatmap if <code>heatarray</code> is not nothing. It is strongly recommended to use <code>abmplot</code> instead of the <code>abmplot!</code> method if you use <code>heatarray</code>, so that a colorbar can be placed naturally.</li><li><code>static_preplot!</code> : A function <code>f(ax, abmplot)</code> that plots something after the heatmap but before the agents.</li><li><code>spaceplotkwargs = NamedTuple()</code> : keywords utilized when plotting the space. Directly passed to<ul><li><code>OSMMakie.osmplot!</code> if model space is <code>OpenStreetMapSpace</code>.</li><li><a href="https://graph.makie.org/stable/#GraphMakie.graphplot"><code>GraphMakie.graphplot!</code></a></li></ul>if model space is <code>GraphSpace</code>.</li><li><code>adjust_aspect = true</code>: Adjust axis aspect ratio to be the model&#39;s space aspect ratio.</li><li><code>enable_space_checks = true</code>: Set to <code>false</code> to disable checks related to the model space.</li></ul><p>The stand-alone function <code>abmplot</code> also takes two optional <code>NamedTuple</code>s named <code>figure</code> and <code>axis</code> which can be used to change the automatically created <code>Figure</code> and <code>Axis</code> objects.</p><p><strong>Interactivity</strong></p><p><strong>Evolution related</strong></p><ul><li><code>add_controls::Bool</code>: If <code>true</code>, <code>abmplot</code> switches to &quot;interactive application GUI&quot; mode where the model evolves interactively using <code>Agents.step!</code>. <code>add_controls</code> is by default <code>false</code> unless <code>params</code> (see below) is not empty. <code>add_controls</code> is also always <code>true</code> in <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a>. The application has the following interactive elements:<ol><li>&quot;step&quot;: advances the simulation once for <code>dt</code> time.</li><li>&quot;run&quot;: starts/stops the continuous evolution of the model.</li><li>&quot;reset model&quot;: resets the model to its initial state from right after starting the interactive application.</li><li>Two sliders control the animation speed: &quot;dt&quot; decides how much time to evolve the model before the plot is updated, and &quot;sleep&quot; the <code>sleep()</code> time between updates.</li></ol></li><li><code>enable_inspection = add_controls</code>: If <code>true</code>, enables agent inspection on mouse hover.</li><li><code>dt = 1:50</code>: The values of the &quot;dt&quot; slider which is the time to step the model forwards in each frame update, which calls <code>step!(model, dt)</code>. This defaults to <code>1:50</code> for discrete time models and to <code>0.1:0.1:10.0</code> for continuous time ones.</li><li><code>params = Dict()</code> : This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of <code>params</code> is a pair of <code>Symbol</code> to an <code>AbstractVector</code>, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only propagated to the actual model after a press of the &quot;update&quot; button.</li></ul><p><strong>Data collection related</strong></p><ul><li><code>adata, mdata, when</code>: Same as the keyword arguments of <code>Agents.run!</code>. If either or both <code>adata, mdata</code> are given, data are collected and stored in the <code>abmobs</code>, see <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a>. The same keywords provide the data plots of <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a>. This also adds the button &quot;clear data&quot; which deletes previously collected agent and model data by emptying the underlying <code>DataFrames</code> <code>adf</code>/<code>mdf</code>. Reset model and clear data are independent processes.</li></ul><p>See the documentation string of <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a> for custom interactive plots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/25bbcbf345935c4070d68104f856ced6443628fc/src/visualizations.jl#L1-L110">source</a></section></article><h2 id="Interactive-ABM-Applications"><a class="docs-heading-anchor" href="#Interactive-ABM-Applications">Interactive ABM Applications</a><a id="Interactive-ABM-Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-ABM-Applications" title="Permalink"></a></h2><p>Continuing from the Daisyworld plots above, we can turn them into interactive applications straightforwardly, simply by setting the keyword <code>add_controls = true</code> as discussed in the documentation of <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>. Note that <a href="https://makie.juliaplots.org/v0.15/documentation/backends_and_output/"><code>GLMakie</code></a> should be used instead of <code>CairoMakie</code> when wanting to use the interactive aspects of the plots!</p><pre><code class="language-julia hljs">using GLMakie</code></pre><pre><code class="language-julia hljs">fig, ax, abmobs = abmplot(model; add_controls = true, plotkwargs...)
fig</code></pre><img src="9618d339.png" alt="Example block output"/><p>One could click the run button and see the model evolve. Furthermore, one can add more sliders that allow changing the model parameters.</p><pre><code class="language-julia hljs">params = Dict(
    :surface_albedo =&gt; 0:0.01:1,
    :solar_change =&gt; -0.1:0.01:0.1,
)
fig, ax, abmobs = abmplot(model; params, plotkwargs...)
fig</code></pre><img src="4dcbff5d.png" alt="Example block output"/><p>One can furthermore collect data while the model evolves and visualize them using the convenience function <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a></p><pre><code class="language-julia hljs">using Statistics: mean
black(a) = a.breed == :black
white(a) = a.breed == :white
adata = [(black, count), (white, count)]
temperature(model) = mean(model.temperature)
mdata = [temperature, :solar_luminosity]
fig, abmobs = abmexploration(model;
    params, plotkwargs...,  adata, alabels = [&quot;Black daisys&quot;, &quot;White daisys&quot;],
    mdata, mlabels = [&quot;T&quot;, &quot;L&quot;]
)</code></pre><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmexploration-examples-agents_visualizations" href="#Agents.abmexploration-examples-agents_visualizations"><code>Agents.abmexploration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmexploration(model::ABM; alabels, mlabels, kwargs...)</code></pre><p>Open an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires <code>Agents</code>.</p><p>The application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>, and the <code>model</code> argument as well as splatted <code>kwargs</code> are propagated there as-is. This convencience function <em>only works for aggregated agent data</em>.</p><p>Calling <code>abmexploration</code> returns: <code>fig::Figure, abmobs::ABMObservable</code>. So you can save and/or further modify the figure and it is also possible to access the collected data (if any) via the <code>ABMObservable</code>.</p><p>Clicking the &quot;reset&quot; button will add a red vertical line to the data plots for visual guidance.</p><p><strong>Keywords arguments (in addition to those in <code>abmplot</code>)</strong></p><ul><li><code>alabels, mlabels</code>: If data are collected from agents or the model with <code>adata, mdata</code>, the corresponding plots&#39; y-labels are automatically named after the collected data. It is also possible to provide <code>alabels, mlabels</code> (vectors of strings with exactly same length as <code>adata, mdata</code>), and these labels will be used instead.</li><li><code>figure = NamedTuple()</code>: Keywords to customize the created Figure.</li><li><code>axis = NamedTuple()</code>: Keywords to customize the created Axis.</li><li><code>plotkwargs = NamedTuple()</code>: Keywords to customize the styling of the resulting <a href="https://makie.juliaplots.org/dev/examples/plotting_functions/scatterlines/index.html"><code>scatterlines</code></a> plots.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/25bbcbf345935c4070d68104f856ced6443628fc/src/visualizations.jl#L172-L201">source</a></section></article><h2 id="ABM-Videos"><a class="docs-heading-anchor" href="#ABM-Videos">ABM Videos</a><a id="ABM-Videos-1"></a><a class="docs-heading-anchor-permalink" href="#ABM-Videos" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmvideo-examples-agents_visualizations" href="#Agents.abmvideo-examples-agents_visualizations"><code>Agents.abmvideo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmvideo(file, model; kwargs...)</code></pre><p>This function exports the animated time evolution of an agent based model into a video saved at given path <code>file</code>, by recording the behavior of the interactive version of <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> (without sliders). The plotting is identical as in <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> and applicable keywords are propagated.</p><p><strong>Keywords</strong></p><ul><li><code>dt = 1</code>: Time to evolve between each recorded frame. For <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a> this must be an integer and it is identical to how many steps to take per frame.</li><li><code>framerate = 30</code>: The frame rate of the exported video.</li><li><code>frames = 300</code>: How many frames to record in total, including the starting frame.</li><li><code>title = &quot;&quot;</code>: The title of the figure.</li><li><code>showstep = true</code>: If current step should be shown in title.</li><li><code>figure = NamedTuple()</code>: Figure related keywords (e.g. resolution, backgroundcolor).</li><li><code>axis = NamedTuple()</code>: Axis related keywords (e.g. aspect).</li><li><code>recordkwargs = NamedTuple()</code>: Keyword arguments given to <code>Makie.record</code>. You can use <code>(compression = 1, profile = &quot;high&quot;)</code> for a higher quality output, and prefer the <code>CairoMakie</code> backend. (compression 0 results in videos that are not playable by some software)</li><li><code>kwargs...</code>: All other keywords are propagated to <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/25bbcbf345935c4070d68104f856ced6443628fc/src/visualizations.jl#L205-L227">source</a></section></article><p>E.g., continuing from above,</p><pre><code class="language-julia hljs">model = AgentsExampleZoo.daisyworld()
abmvideo(&quot;daisyworld.mp4&quot;, model; title = &quot;Daisy World&quot;, frames = 150, plotkwargs...)</code></pre><video width="auto" controls autoplay loop>
<source src="../daisyworld.mp4" type="video/mp4">
</video><p>You could of course also explicitly use <code>abmplot</code> in a <code>record</code> loop for finer control over additional plot elements.</p><h2 id="Agent-inspection"><a class="docs-heading-anchor" href="#Agent-inspection">Agent inspection</a><a id="Agent-inspection-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-inspection" title="Permalink"></a></h2><p>It is possible to inspect agents at a given position by hovering the mouse cursor over the scatter points in the agent plot. Inspection is automatically enabled for interactive applications (i.e. when either agent or model stepping functions are provided). To manually enable this functionality, simply add <code>enable_inspection = true</code> as an additional keyword argument to the <code>abmplot</code>/<code>abmplot!</code> call. A tooltip will appear which by default provides the name of the agent type, its <code>id</code>, <code>pos</code>, and all other fieldnames together with their current values. This is especially useful for interactive exploration of micro data on the agent level.</p><p><img src="https://github.com/JuliaDynamics/JuliaDynamics/tree/master/videos/agents/RabbitFoxHawk_inspection.png" alt="RabbitFoxHawk inspection example"/></p><p>The tooltip can be customized by extending <code>Agents.agent2string</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.agent2string-examples-agents_visualizations" href="#Agents.agent2string-examples-agents_visualizations"><code>Agents.agent2string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">agent2string(agent::A)</code></pre><p>Convert agent data into a string which is used to display all agent variables and their values in the tooltip on mouse hover. Concatenates strings if there are multiple agents at one position. Custom tooltips for agents can be implemented by adding a specialised method for <code>agent2string</code>.</p><p>Example:</p><pre><code class="language-julia hljs">function Agents.agent2string(agent::SpecialAgent)
    &quot;&quot;&quot;
    ✨ SpecialAgent ✨
    ID = $(agent.id)
    Main weapon = $(agent.charisma)
    Side weapon = $(agent.pistol)
    &quot;&quot;&quot;
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/25bbcbf345935c4070d68104f856ced6443628fc/src/visualizations.jl#L231-L250">source</a></section></article><h2 id="Creating-custom-ABM-plots"><a class="docs-heading-anchor" href="#Creating-custom-ABM-plots">Creating custom ABM plots</a><a id="Creating-custom-ABM-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-ABM-plots" title="Permalink"></a></h2><p>The existing convenience function <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a> will always display aggregated collected data as scatterpoints connected with lines. In cases where more granular control over the displayed plots is needed, we need to take a few extra steps and utilize the <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a> returned by <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>. The same steps are necessary when we want to create custom plots that compose animations of the model space and other aspects.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.ABMObservable-examples-agents_visualizations" href="#Agents.ABMObservable-examples-agents_visualizations"><code>Agents.ABMObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ABMObservable(model; adata, mdata, when) → abmobs</code></pre><p><code>abmobs</code> contains all information necessary to step an agent based model interactively, as well as collect data while stepping interactively. <code>ABMObservable</code> also returned by <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>.</p><p>Calling <code>Agents.step!(abmobs, t)</code> will step the model for <code>t</code> time and collect data as in <a href="../../api/#Agents.run!"><code>Agents.run!</code></a>.</p><p>The fields <code>abmobs.model, abmobs.adf, abmobs.mdf</code> are <em>observables</em> that contain the <a href="../../api/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, and the agent and model dataframes with collected data. Data are collected as described in <a href="../../api/#Agents.run!"><code>Agents.run!</code></a> using the <code>adata, mdata, when</code> keywords. All three observables are updated on stepping (when it makes sense).</p><p>All plotting and interactivity should be defined by <code>lift</code>ing these observables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/25bbcbf345935c4070d68104f856ced6443628fc/src/visualizations.jl#L142-L158">source</a></section></article><p>To do custom animations you need to have a good idea of how Makie&#39;s animation system works. Have a look <a href="https://www.youtube.com/watch?v=L-gyDvhjzGQ">at this tutorial</a> if you are not familiar yet.</p><p>create a basic abmplot with controls and sliders</p><pre><code class="language-julia hljs">model = AgentsExampleZoo.daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)
fig, ax, abmobs = abmplot(model; params, plotkwargs...,
    adata, mdata, figure = (; size = (1600,800))
)
fig</code></pre><img src="38a8271f.png" alt="Example block output"/><pre><code class="language-julia hljs">abmobs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ABMObservable with model:
StandardABM with 360 agents of type Daisy
 agents container: Dict
 space: GridSpaceSingle with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, ratio, solar_change, tick, scenario
and with data collection:
 adata: Tuple{Function, typeof(count)}[(Main.black, count), (Main.white, count)]
 mdata: Any[Main.temperature, :solar_luminosity]</code></pre><p>create a new layout to add new plots to the right of the abmplot</p><pre><code class="language-julia hljs">plot_layout = fig[:,end+1] = GridLayout()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridLayout[1:1, 1:1] with 0 children
</code></pre><p>create a sublayout on its first row and column</p><pre><code class="language-julia hljs">count_layout = plot_layout[1,1] = GridLayout()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridLayout[1:1, 1:1] with 0 children
</code></pre><p>collect tuples with x and y values for black and white daisys</p><pre><code class="language-julia hljs">blacks = @lift(Point2f.($(abmobs.adf).time, $(abmobs.adf).count_black))
whites = @lift(Point2f.($(abmobs.adf).time, $(abmobs.adf).count_white))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Observable(Point{2, Float32}[[0.0, 180.0]])
</code></pre><p>create an axis to plot into and style it to our liking</p><pre><code class="language-julia hljs">ax_counts = Axis(count_layout[1,1];
    backgroundcolor = :lightgrey, ylabel = &quot;Number of daisies by color&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Axis with 0 plots:
</code></pre><p>plot the data as scatterlines and color them accordingly</p><pre><code class="language-julia hljs">scatterlines!(ax_counts, blacks; color = :black, label = &quot;black&quot;)
scatterlines!(ax_counts, whites; color = :white, label = &quot;white&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plot{Makie.scatterlines, Tuple{Vector{Point{2, Float32}}}}</code></pre><p>add a legend to the right side of the plot</p><pre><code class="language-julia hljs">Legend(count_layout[1,2], ax_counts; bgcolor = :lightgrey)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Legend()</code></pre><p>and another plot, written in a more condensed format</p><pre><code class="language-julia hljs">ax_hist = Axis(plot_layout[2,1];
    ylabel = &quot;Distribution of mean temperatures\nacross all time steps&quot;)
hist!(ax_hist, @lift($(abmobs.mdf).temperature);
    bins = 50, color = :red,
    strokewidth = 2, strokecolor = (:black, 0.5),
)

fig</code></pre><img src="c6c15422.png" alt="Example block output"/><p>Now, once we step the <code>abmobs::ABMObservable</code>, the whole plot will be updated</p><pre><code class="language-julia hljs">Agents.step!(abmobs, 1)
Agents.step!(abmobs, 1)
fig</code></pre><img src="b606cc76.png" alt="Example block output"/><p>Of course, you need to actually adjust axis limits given that the plot is interactive</p><pre><code class="language-julia hljs">autolimits!(ax_counts)
autolimits!(ax_hist)</code></pre><p>Or, simply trigger them on any update to the model observable:</p><pre><code class="language-julia hljs">on(abmobs.model) do m
    autolimits!(ax_counts)
    autolimits!(ax_hist)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ObserverFunction defined at agents_visualizations.md:288 operating on Observable(StandardABM with 770 agents of type Daisy
 agents container: Dict
 space: GridSpaceSingle with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, ratio, solar_change, tick, scenario)</code></pre><p>and then marvel at everything being auto-updated by calling <code>step!</code> :)</p><pre><code class="language-julia hljs">for i in 1:100; step!(abmobs, 1); end
fig</code></pre><img src="f71248c0.png" alt="Example block output"/><h2 id="GraphSpace-models"><a class="docs-heading-anchor" href="#GraphSpace-models">GraphSpace models</a><a id="GraphSpace-models-1"></a><a class="docs-heading-anchor-permalink" href="#GraphSpace-models" title="Permalink"></a></h2><p>While the <code>ac, as, am</code> keyword arguments generally relate to <em>agent</em> colors, markersizes, and markers, they are handled a bit differently in the case of <a href="https://juliadynamics.github.io/Agents.jl/stable/api/#Agents.GraphSpace"><code>GraphSpace models</code></a>. Here, we collect those plot attributes for each node of the underlying graph which can contain multiple agents. If we want to use a function for this, we therefore need to handle an iterator of agents. Keeping this in mind, we can create an <a href="https://juliadynamics.github.io/Agents.jl/stable/examples/sir/">exemplary GraphSpace model</a> and plot it with <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>.</p><pre><code class="language-julia hljs">using Graphs
using ColorTypes
sir_model = AgentsExampleZoo.sir()
city_size(agents_here) = 0.005 * length(agents_here)
function city_color(agents_here)
    l_agents_here = length(agents_here)
    infected = count(a.status == :I for a in agents_here)
    recovered = count(a.status == :R for a in agents_here)
    return RGB(infected / l_agents_here, recovered / l_agents_here, 0)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">city_color (generic function with 1 method)</code></pre><p>To further style the edges and nodes of the resulting graph plot, we can leverage the functionality of <a href="https://graph.makie.org/stable/#GraphMakie.graphplot">GraphMakie.graphplot</a> and pass all the desired keyword arguments to it via a named tuple called <code>agentsplotkwargs</code>. When using functions for edge color and width, they should return either one color or a vector with the same length (or twice) as current number of edges in the underlying graph. In the example below, the <code>edge_color</code> function colors all edges to a semi-transparent shade of grey and the <code>edge_width</code> function makes use of the special ability of <code>linesegments</code> to be tapered (i.e. one end is wider than the other).</p><pre><code class="language-julia hljs">using GraphMakie: Shell
edge_color(model) = fill((:grey, 0.25), ne(abmspace(model).graph))
function edge_width(model)
    w = zeros(ne(abmspace(model).graph))
    for e in edges(abmspace(model).graph)
        w[e.src] = 0.004 * length(abmspace(model).stored_ids[e.src])
        w[e.dst] = 0.004 * length(abmspace(model).stored_ids[e.dst])
    end
    return w
end
agentsplotkwargs = (
    layout = Shell(), # node positions
    arrow_show = false, # hide directions of graph edges
    edge_color = edge_color, # change edge colors and widths with own functions
    edge_width = edge_width,
    edge_plottype = :linesegments # needed for tapered edge widths
)

fig, ax, abmobs = abmplot(sir_model; agent_size = city_size, agent_color = city_color, agentsplotkwargs)
fig</code></pre><img src="614e06be.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../api/">« API</a><a class="docs-footer-nextpage" href="../optim/">BlackBoxOptim.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Wednesday 10 April 2024 17:47">Wednesday 10 April 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
