<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/">Overview</a></li><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sugarscape/">Sugarscape</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-Prey</a></li><li><a class="tocitem" href="../examples/growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../examples/opinion_spread/">Opinion spread</a></li><li><a class="tocitem" href="../examples/battle/">Battle Royale</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak</a></li></ul></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Agent/model-retrieval"><span>Agent/model retrieval</span></a></li><li><a class="tocitem" href="#Model-agent-interaction"><span>Model-agent interaction</span></a></li><li><a class="tocitem" href="#Local-area"><span>Local area</span></a></li><li><a class="tocitem" href="#A-note-on-iteration"><span>A note on iteration</span></a></li><li><a class="tocitem" href="#Discrete-space-exclusives"><span>Discrete space exclusives</span></a></li><li><a class="tocitem" href="#Continuous-space-exclusives"><span>Continuous space exclusives</span></a></li><li><a class="tocitem" href="#OpenStreetMap-space-exclusives"><span>OpenStreetMap space exclusives</span></a></li><li><a class="tocitem" href="#Graph-space-exclusives"><span>Graph space exclusives</span></a></li><li><a class="tocitem" href="#Parameter-scanning"><span>Parameter scanning</span></a></li><li><a class="tocitem" href="#Data-collection"><span>Data collection</span></a></li><li><a class="tocitem" href="#Schedulers"><span>Schedulers</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li><li><a class="tocitem" href="#Interactive-application"><span>Interactive application</span></a></li></ul></li><li><a class="tocitem" href="../interact/">Interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">LightGraphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li></ul></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The API of Agents.jl is defined on top of the fundamental structures  <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, <a href="../tutorial/#Space">Space</a>, <a href="../tutorial/#Agents.AbstractAgent"><code>AbstractAgent</code></a> which are described in the <a href="../tutorial/#Tutorial">Tutorial</a> page.</p><h2 id="Agent/model-retrieval"><a class="docs-heading-anchor" href="#Agent/model-retrieval">Agent/model retrieval</a><a id="Agent/model-retrieval-1"></a><a class="docs-heading-anchor-permalink" href="#Agent/model-retrieval" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AgentBasedModel,Integer}" href="#Base.getindex-Tuple{AgentBasedModel,Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model[id]
getindex(model::ABM, id::Integer)</code></pre><p>Return an agent given its ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L89-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{AgentBasedModel,Symbol}" href="#Base.getproperty-Tuple{AgentBasedModel,Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model.prop
getproperty(model::ABM, prop::Symbol)</code></pre><p>Return a property from the current <code>model</code>, assuming the model <code>properties</code> are either a dictionary with key type <code>Symbol</code> or a Julia struct. For example, if a model has the set of properties <code>Dict(:weight =&gt; 5, :current =&gt; false)</code>, retrieving these values can be obtained via <code>model.weight</code>.</p><p>The property names <code>:agents, :space, :scheduler, :properties, :maxid</code> are internals and <strong>should not be accessed by the user</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L118-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_agent" href="#Agents.random_agent"><code>Agents.random_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_agent(model) → agent</code></pre><p>Return a random agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L157-L160">source</a></section><section><div><pre><code class="language-none">random_agent(model, condition) → agent</code></pre><p>Return a random agent from the model that satisfies <code>condition(agent) == true</code>. The function generates a random permutation of agent IDs and iterates through them. If no agent satisfies the condition, <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nagents" href="#Agents.nagents"><code>Agents.nagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nagents(model::ABM)</code></pre><p>Return the number of agents in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L181-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allagents" href="#Agents.allagents"><code>Agents.allagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allagents(model)</code></pre><p>Return an iterator over all agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L187-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allids" href="#Agents.allids"><code>Agents.allids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allids(model)</code></pre><p>Return an iterator over all agent IDs of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L194-L197">source</a></section></article><h2 id="Model-agent-interaction"><a class="docs-heading-anchor" href="#Model-agent-interaction">Model-agent interaction</a><a id="Model-agent-interaction-1"></a><a class="docs-heading-anchor-permalink" href="#Model-agent-interaction" title="Permalink"></a></h2><p>The following API is mostly universal across all types of <a href="../tutorial/#Space">Space</a>. Only some specific methods are exclusive to a specific type of space.</p><h3 id="Adding-agents"><a class="docs-heading-anchor" href="#Adding-agents">Adding agents</a><a id="Adding-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-agents" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent!" href="#Agents.add_agent!"><code>Agents.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent!(agent::AbstractAgent [, pos], model::ABM) → agent</code></pre><p>Add the <code>agent</code> to the model in the given position. If <code>pos</code> is not given, the <code>agent</code> is added to a random position. The <code>agent</code>&#39;s position is always updated to match <code>position</code>, and therefore for <code>add_agent!</code> the position of the <code>agent</code> is meaningless. Use <a href="#Agents.add_agent_pos!"><code>add_agent_pos!</code></a> to use the <code>agent</code>&#39;s position.</p><p>The type of <code>pos</code> must match the underlying space position type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L189-L198">source</a></section><section><div><pre><code class="language-none">add_agent!([pos,] model::ABM, args...; kwargs...) → newagent</code></pre><p>Create and add a new agent to the model by constructing an agent of the type of the <code>model</code>. Propagate all <em>extra</em> positional arguments and keyword arguemts to the agent constructor. Optionally provide a position to add the agent to as <em>first argument</em>, which must match the space position type.</p><p>Notice that this function takes care of setting the agent&#39;s id <em>and</em> position and thus <code>args...</code> and <code>kwargs...</code> are propagated to other fields the agent has (see example below).</p><pre><code class="language-none">add_agent!([pos,] A, model::ABM, args...; kwargs...) → newagent</code></pre><p>Use this version for mixed agent models, with <code>A</code> the agent type you wish to create (to be called as <code>A(id, pos, args...; kwargs...)</code>), because it is otherwise not possible to deduce a constructor for <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::Int
    w::Float64
    k::Bool
end
Agent(id, pos; w=0.5, k=false) = Agent(id, pos, w, k) # keyword constructor
model = ABM(Agent, GraphSpace(complete_digraph(5)))

add_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally
add_agent!(model, 0.5, true) # correct: w becomes 0.5
add_agent!(5, model, 0.5, true) # add at position 5, w becomes 0.5
add_agent!(model; w = 0.5) # use keywords: w becomes 0.5, k becomes false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L209-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_pos!" href="#Agents.add_agent_pos!"><code>Agents.add_agent_pos!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_pos!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Add the agent to the <code>model</code> at the agent&#39;s own position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L178-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nextid" href="#Agents.nextid"><code>Agents.nextid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextid(model::ABM) → id</code></pre><p>Return a valid <code>id</code> for creating a new agent with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L112-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_position" href="#Agents.random_position"><code>Agents.random_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_position(model) → pos</code></pre><p>Return a random position in the model&#39;s space (always with appropriate Type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L33-L36">source</a></section></article><h3 id="Moving-agents"><a class="docs-heading-anchor" href="#Moving-agents">Moving agents</a><a id="Moving-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-agents" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent!" href="#Agents.move_agent!"><code>Agents.move_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent!(agent [, pos], model::ABM) → agent</code></pre><p>Move agent to the given position, or to a random one if a position is not given. <code>pos</code> must have the appropriate position type depending on the space type.</p><p>The agent&#39;s position is updated to match <code>pos</code> after the move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L39-L46">source</a></section><section><div><pre><code class="language-none">move_agent!(agent::A, model::ABM{&lt;:ContinuousSpace,A}, dt::Real = 1.0)</code></pre><p>Propagate the agent forwards one step according to its velocity, <em>after</em> updating the agent&#39;s velocity (if configured, see <a href="../tutorial/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>). Also take care of periodic boundary conditions.</p><p>For this continuous space version of <code>move_agent!</code>, the &quot;evolution algorithm&quot; is a trivial Euler scheme with <code>dt</code> the step size, i.e. the agent position is updated as <code>agent.pos += agent.vel * dt</code>. If you want to move the agent to a specified position, do <code>move_agent!(agent, pos, model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/continuous.jl#L97-L107">source</a></section><section><div><pre><code class="language-none">move_agent!(agent, model::ABM{&lt;:OpenStreetMapSpace}, distance::Real)</code></pre><p>Move an agent by <code>distance</code> in meters along its planned route.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L386-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.walk!" href="#Agents.walk!"><code>Agents.walk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">walk!(agent, direction::NTuple, model; ifempty = false)</code></pre><p>Move agent in the given <code>direction</code> respecting periodic boundary conditions. If <code>periodic = false</code>, agents will walk to, but not exceed the boundary value. Possible on both <code>GridSpace</code> and <code>ContinuousSpace</code>s.</p><p>The dimensionality of <code>direction</code> must be the same as the space. <code>GridSpace</code> asks for <code>Int</code>, and <code>ContinuousSpace</code> for <code>Float64</code> vectors, describing the walk distance in each direction. <code>direction = (2, -3)</code> is an example of a valid direction on a <code>GridSpace</code>, which moves the agent to the right 2 positions and down 3 positions. Velocity is ignored for this opreation in <code>ContinuousSpace</code>.</p><p><strong>Keywords</strong></p><ul><li><code>ifempty</code> will check that the target position is unnocupied and only move if that&#39;s true. Available only on <code>GridSpace</code>.</li></ul><p>Example usage in <a href="../examples/battle/#Battle-Royale">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/utilities.jl#L91-L108">source</a></section><section><div><pre><code class="language-none">walk!(agent, rand, model)</code></pre><p>Invoke a random walk by providing the <code>rand</code> function in place of <code>distance</code>. For <code>GridSpace</code>, the walk will cover ±1 positions in all directions, <code>ContinuousSpace</code> will reside within [-1, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/utilities.jl#L157-L163">source</a></section></article><h3 id="Removing-agents"><a class="docs-heading-anchor" href="#Removing-agents">Removing agents</a><a id="Removing-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-agents" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.kill_agent!" href="#Agents.kill_agent!"><code>Agents.kill_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kill_agent!(agent::AbstractAgent, model::ABM)
kill_agent!(id::Int, model::ABM)</code></pre><p>Remove an agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L113-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.genocide!" href="#Agents.genocide!"><code>Agents.genocide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genocide!(model::ABM)</code></pre><p>Kill all the agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L137-L140">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, n::Int)</code></pre><p>Kill the agents of the model whose IDs are larger than n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L148-L151">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, f::Function)</code></pre><p>Kill all agents where the function <code>f(agent)</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L159-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.sample!" href="#Agents.sample!"><code>Agents.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample!(model::ABM, n [, weight]; kwargs...)</code></pre><p>Replace the agents of the <code>model</code> with a random sample of the current agents with size <code>n</code>.</p><p>Optionally, provide a <code>weight</code>: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the <code>weight</code> of the agent, the higher the probability that this agent will be chosen in the new sampling.</p><p><strong>Keywords</strong></p><ul><li><code>replace = true</code> : whether sampling is performed with replacement, i.e. all agents can</li></ul><p>be chosen more than once.</p><ul><li><code>rng = GLOBAL_RNG</code> : a random number generator to perform the sampling with.</li></ul><p>Example usage in <a href="../examples/wright-fisher/#Wright-Fisher-model-of-evolution">Wright-Fisher model of evolution</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/sample.jl#L4-L21">source</a></section></article><h2 id="Local-area"><a class="docs-heading-anchor" href="#Local-area">Local area</a><a id="Local-area-1"></a><a class="docs-heading-anchor-permalink" href="#Local-area" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_ids" href="#Agents.nearby_ids"><code>Agents.nearby_ids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_ids(position, model::ABM, r=1; kwargs...) → ids</code></pre><p>Return an iterable of the ids of the agents within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which must match type with the spatial structure of the <code>model</code>).</p><p>What the &quot;radius&quot; means depends on the space type:</p><ul><li><code>GraphSpace</code>: the degree of neighbors in the graph (thus <code>r</code> is always an integer). For example, for <code>r=2</code> include first and second degree neighbors.</li><li><code>GridSpace, ContinuousSpace</code>: Either Chebyshev (also called Moore) or Euclidean distance, in the space of cartesian indices.</li><li><code>GridSpace</code> can also take a tuple argument, e.g. <code>r = (5, 2)</code> for a 2D space, which</li></ul><p>extends 5 positions in the x direction and 2 in the y. Only possible with Chebyshev spaces.</p><p><strong>Keywords</strong></p><p>Keyword arguments are space-specific. For <code>GraphSpace</code> the keyword <code>neighbor_type=:default</code> can be used to select differing neighbors depending on the underlying graph directionality type.</p><ul><li><code>:default</code> returns neighbors of a vertex (position). If graph is directed, this is equivalent to <code>:out</code>. For undirected graphs, all options are equivalent to <code>:out</code>.</li><li><code>:all</code> returns both <code>:in</code> and <code>:out</code> neighbors.</li><li><code>:in</code> returns incoming vertex neighbors.</li><li><code>:out</code> returns outgoing vertex neighbors.</li></ul><p>For <code>ContinuousSpace</code>, the keyword <code>exact=false</code> controls whether the found neighbors are exactly accurate or approximate (with approximate always being a strict over-estimation), see <a href="../tutorial/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L68-L96">source</a></section><section><div><pre><code class="language-none">nearby_ids(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_ids(agent.pos, model, r)</code> but the iterable <em>excludes</em> the given <code>agent</code>&#39;s id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L277-L282">source</a></section><section><div><pre><code class="language-none">nearby_ids(pos, model::ABM{&lt;:GridSpace}, r::Vector{Tuple{Int,UnitRange{Int}}})</code></pre><p>Return an iterable of ids over specified dimensions of <code>space</code> with fine grained control of distances from <code>pos</code> using each value of <code>r</code> via the (dimension, range) pattern.</p><p><strong>Note:</strong> Only available for use with non-periodic chebyshev grids.</p><p>Example, with a <code>GridSpace((100, 100, 10))</code>: <code>r = [(1, -1:1), (3, 1:2)]</code> searches dimension 1 one step either side of the current position (as well as the current position) and the third dimension searches two positions above current.</p><p>For a complete tutorial on how to use this method, see <a href="../examples/battle/#Battle-Royale">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/grid.jl#L211-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_positions" href="#Agents.nearby_positions"><code>Agents.nearby_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_positions(position, model::ABM, r=1; kwargs...) → positions</code></pre><p>Return an iterable of all positions within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which excludes given <code>position</code>). The <code>position</code> must match type with the spatial structure of the <code>model</code>.</p><p>The value of <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L99-L107">source</a></section><section><div><pre><code class="language-none">nearby_positions(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_positions(agent.pos, model, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/space_interaction_API.jl#L293-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.edistance" href="#Agents.edistance"><code>Agents.edistance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edistance(a, b, model::ABM)</code></pre><p>Return the euclidean distance between <code>a</code> and <code>b</code> (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently <code>GridSpace</code> and <code>ContinuousSpace</code>.</p><p>Example usage in the <a href="../examples/flock/#Flock-model">Flock model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/utilities.jl#L7-L15">source</a></section></article><h2 id="A-note-on-iteration"><a class="docs-heading-anchor" href="#A-note-on-iteration">A note on iteration</a><a id="A-note-on-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-on-iteration" title="Permalink"></a></h2><p>Most iteration in Agents.jl is <strong>dynamic</strong> and <strong>lazy</strong>, when possible, for performance reasons.</p><p><strong>Dynamic</strong> means that when iterating over the result of e.g. the <a href="#Agents.ids_in_position"><code>ids_in_position</code></a> function, the iterator will be affected by actions that would alter its contents. Specifically, imagine the scenario</p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::NTuple{4, Int}
end

model = ABM(Agent, GridSpace((5, 5, 5, 5)))
add_agent!((1, 1, 1, 1), model)
add_agent!((1, 1, 1, 1), model)
add_agent!((2, 1, 1, 1), model)
for id in ids_in_position((1, 1, 1, 1), model)
    kill_agent!(id, model)
end
collect(allids(model))</code></pre><pre class="documenter-example-output">2-element Array{Int64,1}:
 2
 3</pre><p>You will notice that only 1 agent got killed. This is simply because the final state of the iteration of <code>ids_in_position</code> was reached unnaturally, because the length of its output was reduced by 1 <em>during</em> iteration. To avoid problems like these, you need to <code>collect</code> the iterator to have a non dynamic version.</p><p><strong>Lazy</strong> means that when possible the outputs of the iteration are not collected and instead are generated on the fly. A good example to illustrate this is <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>, where doing something like</p><pre><code class="language-julia">a = random_agent(model)
sort!(nearby_ids(random_agent(model), model))</code></pre><p>leads to error, since you cannot <code>sort!</code> the returned iterator. This can be easily solved by adding a <code>collect</code> in between:</p><pre><code class="language-julia">a = random_agent(model)
sort!(collect(nearby_agents(a, model)))</code></pre><pre class="documenter-example-output">1-element Array{Main.ex-docs.Agent,1}:
 Main.ex-docs.Agent(3, (2, 1, 1, 1))</pre><h2 id="Discrete-space-exclusives"><a class="docs-heading-anchor" href="#Discrete-space-exclusives">Discrete space exclusives</a><a id="Discrete-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.positions" href="#Agents.positions"><code>Agents.positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">positions(model::ABM{&lt;:DiscreteSpace}) → ns</code></pre><p>Return an iterator over all positions of a model with a discrete space.</p><pre><code class="language-none">positions(model::ABM{&lt;:DiscreteSpace}, by::Symbol) → ns</code></pre><p>Return all positions of a model with a discrete space, sorting them using the argument <code>by</code> which can be:</p><ul><li><code>:random</code> - randomly sorted</li><li><code>:population</code> - positions are sorted depending on how many agents they accommodate. The more populated positions are first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.ids_in_position" href="#Agents.ids_in_position"><code>Agents.ids_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ids_in_position(position, model::ABM{&lt;:DiscreteSpace})
ids_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the ids of agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.agents_in_position" href="#Agents.agents_in_position"><code>Agents.agents_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">agents_in_position(position, model::ABM{&lt;:DiscreteSpace})
agents_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.fill_space!" href="#Agents.fill_space!"><code>Agents.fill_space!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, args...; kwargs...)
fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, f::Function; kwargs...)</code></pre><p>Add one agent to each position in the model&#39;s space. Similarly with <a href="#Agents.add_agent!"><code>add_agent!</code></a>, the function creates the necessary agents and the <code>args...; kwargs...</code> are propagated into agent creation. If instead of <code>args...</code> a function <code>f</code> is provided, then <code>args = f(pos)</code> is the result of applying <code>f</code> where <code>pos</code> is each position (tuple for grid, index for graph).</p><p>An optional first argument is an agent <strong>type</strong> to be created, and targets mixed agent models where the agent constructor cannot be deduced (since it is a union).</p><p>Example usage in <a href="../examples/daisyworld/#Daisyworld">Daisyworld</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L121-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.has_empty_positions" href="#Agents.has_empty_positions"><code>Agents.has_empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_empty_positions(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are any positions in the model without agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.empty_positions" href="#Agents.empty_positions"><code>Agents.empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty_positions(model)</code></pre><p>Return a list of positions that currently have no agents on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_empty" href="#Agents.random_empty"><code>Agents.random_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_empty(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return a random position without any agents, or <code>nothing</code> if no such positions exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_single!" href="#Agents.add_agent_single!"><code>Agents.add_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agent</code></pre><p>Add the <code>agent</code> to a random position in the space while respecting a maximum of one agent per position. This function does nothing if there aren&#39;t any empty positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L95-L100">source</a></section><section><div><pre><code class="language-none">add_agent_single!(model::ABM{&lt;:DiscreteSpace}, properties...; kwargs...)</code></pre><p>Same as <code>add_agent!(model, properties...)</code> but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L109-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent_single!" href="#Agents.move_agent_single!"><code>Agents.move_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agentt</code></pre><p>Move agent to a random position while respecting a maximum of one agent per position. If there are no empty positions, the agent won&#39;t move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L165-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Integer,AgentBasedModel}" href="#Base.isempty-Tuple{Integer,AgentBasedModel}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(position, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are no agents in <code>position</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/discrete.jl#L66-L69">source</a></section></article><h2 id="Continuous-space-exclusives"><a class="docs-heading-anchor" href="#Continuous-space-exclusives">Continuous space exclusives</a><a id="Continuous-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.interacting_pairs" href="#Agents.interacting_pairs"><code>Agents.interacting_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interacting_pairs(model, r, method; scheduler = model.scheduler)</code></pre><p>Return an iterator that yields unique pairs of agents <code>(a1, a2)</code> that are close neighbors to each other, within some interaction radius <code>r</code>.</p><p>This function is usefully combined with <code>model_step!</code>, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with <code>a1</code> and with <code>a2</code>, which is unavoidable when using <code>agent_step!</code>).</p><p>The argument <code>method</code> provides three pairing scenarios</p><ul><li><code>:all</code>: return every pair of agents that are within radius <code>r</code> of each other, not only the nearest ones.</li><li><code>:nearest</code>: agents are only paired with their true nearest neighbor (existing within radius <code>r</code>). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by distance, then by next id in <code>scheduler</code>) will be paired.</li><li><code>:types</code>: For mixed agent models only. Return every pair of agents within radius <code>r</code> (similar to <code>:all</code>), only capturing pairs of differing types. For example, a model of <code>Union{Sheep,Wolf}</code> will only return pairs of <code>(Sheep, Wolf)</code>. In the case of multiple agent types, <em>e.g.</em> <code>Union{Sheep, Wolf, Grass}</code>, skipping pairings that involve <code>Grass</code>, can be achived by a <a href="#Schedulers"><code>scheduler</code></a> that doesn&#39;t schedule <code>Grass</code> types, <em>i.e.</em>: <code>scheduler(model) = (a.id for a in allagents(model) if !(a isa Grass))</code>.</li></ul><p>Example usage in <a href="../examples/growing_bacteria/#Bacterial-Growth">Bacterial Growth</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/continuous.jl#L275-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearest_neighbor" href="#Agents.nearest_neighbor"><code>Agents.nearest_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearest_neighbor(agent, model::ABM{&lt;:ContinuousSpace}, r) → nearest</code></pre><p>Return the agent that has the closest distance to given <code>agent</code>. Return <code>nothing</code> if no agent is within distance <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/continuous.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.elastic_collision!" href="#Agents.elastic_collision!"><code>Agents.elastic_collision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elastic_collision!(a, b, f = nothing)</code></pre><p>Resolve a (hypothetical) elastic collision between the two agents <code>a, b</code>. They are assumed to be disks of equal size touching tangentially. Their velocities (field <code>vel</code>) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.</p><p>If <code>f</code> is a <code>Symbol</code>, then the agent property <code>f</code>, e.g. <code>:mass</code>, is taken as a mass to weight the two agents for the collision. By default no weighting happens.</p><p>One of the two agents can have infinite &quot;mass&quot;, and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.</p><p>Example usage in <a href="../examples/social_distancing/#Continuous-space-social-distancing-for-COVID-19">Continuous space social distancing for COVID-19</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/continuous.jl#L221-L238">source</a></section></article><h2 id="OpenStreetMap-space-exclusives"><a class="docs-heading-anchor" href="#OpenStreetMap-space-exclusives">OpenStreetMap space exclusives</a><a id="OpenStreetMap-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#OpenStreetMap-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_latlon" href="#Agents.osm_latlon"><code>Agents.osm_latlon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_latlon(pos, model)
osm_latlon(agent, model)</code></pre><p>Return (latitude, longitude) of current road or intersection position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_intersection" href="#Agents.osm_intersection"><code>Agents.osm_intersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_intersection(latlon::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Returns the nearest intersection position to (latitude, longitude). Quicker, but less precise than <a href="#Agents.osm_road"><code>osm_road</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L236-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_road" href="#Agents.osm_road"><code>Agents.osm_road</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_road(latlon::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Returns a location on a road nearest to (latitude, longitude). Slower, but more precise than <a href="#Agents.osm_intersection"><code>osm_intersection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_random_road_position" href="#Agents.osm_random_road_position"><code>Agents.osm_random_road_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_random_road_position(model::ABM{OpenStreetMapSpace})</code></pre><p>Similar to <code>random_position</code>, but rather than providing only intersections, this method returns a location somewhere on a road heading in a random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L91-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_plan_route" href="#Agents.osm_plan_route"><code>Agents.osm_plan_route</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_plan_route(start, finish, model::ABM{&lt;:OpenStreetMapSpace};
               by = :shortest, return_trip = false, kwargs...)</code></pre><p>Generate a list of intersections between <code>start</code> and <code>finish</code> points on the map. <code>start</code> and <code>finish</code> can either be intersections (<code>Int</code>) or positions (<code>Tuple{Int,Int,Float64}</code>).</p><p>When either point is a position, the associated intersection index will be removed from the route to avoid double counting.</p><p>Route is planned via the shortest path by default (<code>by = :shortest</code>), but can also be planned <code>by = :fastest</code>. Road speeds are needed for this method which can be passed in via extra keyword arguments. Consult the OpenStreetMapX documentation for more details.</p><p>If <code>return_trip = true</code>, a route will be planned from start -&gt; finish -&gt; start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L114-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_random_route!" href="#Agents.osm_random_route!"><code>Agents.osm_random_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_random_route!(agent, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Selects a random destination and plans a route from the agent&#39;s current position. Will overwrite any current route.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_road_length" href="#Agents.osm_road_length"><code>Agents.osm_road_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_road_length(start::Int, finish::Int, model)
osm_road_length(pos::Tuple{Int,Int,Float64}, model)</code></pre><p>Return the road length (in meters) between two intersections given by intersection ids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L320-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_is_stationary" href="#Agents.osm_is_stationary"><code>Agents.osm_is_stationary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_is_stationary(agent)</code></pre><p>Return <code>true</code> if agent has no route left to follow and is therefore standing still.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L331-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.osm_map_coordinates" href="#Agents.osm_map_coordinates"><code>Agents.osm_map_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">osm_map_coordinates(agent, model::ABM{OpenStreetMapSpace})</code></pre><p>Return a set of coordinates for an agent on the underlying map. Useful for plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L300-L304">source</a></section></article><h2 id="Graph-space-exclusives"><a class="docs-heading-anchor" href="#Graph-space-exclusives">Graph space exclusives</a><a id="Graph-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.SimpleGraphs.add_edge!" href="#LightGraphs.SimpleGraphs.add_edge!"><code>LightGraphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_edge!(model::ABM{&lt;: GraphSpace}, n::Int, m::Int)</code></pre><p>Add a new edge (relationship between two positions) to the graph. Returns a boolean, true if the operation was succesful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/graph.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_node!" href="#Agents.add_node!"><code>Agents.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_node!(model::ABM{&lt;: GraphSpace})</code></pre><p>Add a new node (i.e. possible position) to the model&#39;s graph and return it. You can connect this new node with existing ones using <a href="#LightGraphs.SimpleGraphs.add_edge!"><code>add_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/graph.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.rem_node!" href="#Agents.rem_node!"><code>Agents.rem_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rem_node!(model::ABM{&lt;: GraphSpace}, n::Int)</code></pre><p>Remove node (i.e. position) <code>n</code> from the model&#39;s graph. All agents in that node are killed.</p><p><strong>Warning:</strong> LightGraphs.jl (and thus Agents.jl) swaps the index of the last node with that of the one to be removed, while every other node remains as is. This means that when doing <code>rem_node!(n, model)</code> the last node becomes the <code>n</code>-th node while the previous <code>n</code>-th node (and all its edges and agents) are deleted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/graph.jl#L112-L120">source</a></section></article><h2 id="Parameter-scanning"><a class="docs-heading-anchor" href="#Parameter-scanning">Parameter scanning</a><a id="Parameter-scanning-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-scanning" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.paramscan" href="#Agents.paramscan"><code>Agents.paramscan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">paramscan(parameters, initialize; kwargs...) → adf, mdf</code></pre><p>Perform a parameter scan of a ABM simulation output by collecting data from all parameter combinations into dataframes (one for agent data, one for model data). The dataframes columns are both the collected data (as in <a href="../tutorial/#Agents.run!"><code>run!</code></a>) but also the input parameter values used.</p><p><code>parameters</code> is a dictionary with key type <code>Symbol</code> which contains various parameters that will be scanned over (as well as other parameters that remain constant). This function uses <code>DrWatson</code>&#39;s <a href="https://juliadynamics.github.io/DrWatson.jl/dev/run&amp;list/#DrWatson.dict_list"><code>dict_list</code></a> convention. This means that every entry of <code>parameters</code> that is a <code>Vector</code> contains many parameters and thus is scanned. All other entries of <code>parameters</code> that are not <code>Vector</code>s are not expanded in the scan.</p><p>The second argument <code>initialize</code> is a function that creates an ABM and returns it. It should accept keyword arguments which are the <em>keys</em> of the <code>parameters</code> dictionary. Since the user decides how to use input arguments to make an ABM, <code>parameters</code> can be used to affect model properties, space type and creation as well as agent properties, see the example below.</p><p><strong>Keywords</strong></p><p>The following keywords modify the <code>paramscan</code> function:</p><ul><li><code>include_constants::Bool=false</code> determines whether constant parameters should be included in the output <code>DataFrame</code>.</li><li><code>progress::Bool = true</code> whether to show the progress of simulations.</li></ul><p>The following keywords are propagated into <a href="../tutorial/#Agents.run!"><code>run!</code></a>:</p><pre><code class="language-julia">agent_step!, model_step!, n, when, step0, parallel, replicates, adata, mdata</code></pre><p><code>agent_step!, model_step!, n</code> and at least one of <code>adata, mdata</code> are mandatory.</p><p><strong>Example</strong></p><p>A runnable example that uses <code>paramscan</code> is shown in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>. There we define</p><pre><code class="language-julia">function initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)
    space = GridSpace(griddims, moore = true)
    properties = Dict(:min_to_be_happy =&gt; min_to_be_happy)
    model = ABM(SchellingAgent, space;
                properties = properties, scheduler = random_activation)
    for n in 1:numagents
        agent = SchellingAgent(n, (1, 1), false, n &lt; numagents / 2 ? 1 : 2)
        add_agent_single!(agent, model)
    end
    return model
end</code></pre><p>and do a parameter scan by doing:</p><pre><code class="language-julia">happyperc(moods) = count(x -&gt; x == true, moods) / length(moods)
adata = [(:mood, happyperc)]

parameters = Dict(
    :min_to_be_happy =&gt; collect(2:5), # expanded
    :numagents =&gt; [200, 300],         # expanded
    :griddims =&gt; (20, 20),            # not Vector = not expanded
)

data, _ = paramscan(parameters, initialize; adata = adata, n = 3, agent_step! = agent_step!)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/paramscan.jl#L3-L66">source</a></section></article><h2 id="Data-collection"><a class="docs-heading-anchor" href="#Data-collection">Data collection</a><a id="Data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection" title="Permalink"></a></h2><p>The central simulation function is <a href="../tutorial/#Agents.run!"><code>run!</code></a>, which is mentioned in our <a href="../tutorial/#Tutorial">Tutorial</a>. But there are other functions that are related to simulations listed here.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.init_agent_dataframe" href="#Agents.init_agent_dataframe"><code>Agents.init_agent_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_agent_dataframe(model, adata) → agent_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/collect.jl#L160-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_agent_data!" href="#Agents.collect_agent_data!"><code>Agents.collect_agent_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_agent_data!(df, model, properties, step = 0; obtainer = identity)</code></pre><p>Collect and add agent data into <code>df</code> (see <a href="../tutorial/#Agents.run!"><code>run!</code></a> for the dispatch rules of <code>properties</code> and <code>obtainer</code>). <code>step</code> is given because the step number information is not known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/collect.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.init_model_dataframe" href="#Agents.init_model_dataframe"><code>Agents.init_model_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_model_dataframe(model, mdata) → model_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_model_data!"><code>collect_model_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/collect.jl#L384-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_model_data!" href="#Agents.collect_model_data!"><code>Agents.collect_model_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_model_data!(df, model, properties, step = 0, obtainer = identity)</code></pre><p>Same as <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a> but for model data instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/collect.jl#L411-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.aggname" href="#Agents.aggname"><code>Agents.aggname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggname(k) → name
aggname(k, agg) → name
aggname(k, agg, condition) → name</code></pre><p>Return the name of the column of the <code>i</code>-th collected data where <code>k = adata[i]</code> (or <code>mdata[i]</code>). <code>aggname</code> also accepts tuples with aggregate and conditional values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/collect.jl#L345-L353">source</a></section></article><p>For example, the core loop of <code>run!</code> is just</p><pre><code class="language-julia">df_agent = init_agent_dataframe(model, adata)
df_model = init_model_dataframe(model, mdata)

s = 0
while until(s, n, model)
  if should_we_collect(s, model, when)
      collect_agent_data!(df_agent, model, adata, s)
  end
  if should_we_collect(s, model, when_model)
      collect_model_data!(df_model, model, mdata, s)
  end
  step!(model, agent_step!, model_step!, 1)
  s += 1
end
return df_agent, df_model</code></pre><p>(here <code>until</code> and <code>should_we_collect</code> are internal functions)</p><h2 id="Schedulers"><a class="docs-heading-anchor" href="#Schedulers">Schedulers</a><a id="Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Schedulers" title="Permalink"></a></h2><p>The schedulers of Agents.jl have a very simple interface. All schedulers are functions, that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a &quot;true&quot; iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. You can also use the function <code>schedule(model)</code> to obtain the scheduled ID list, if you prefer to write your own <code>step!</code>-like loop.</p><p>Notice that schedulers can be given directly to model creation, and thus become the &quot;default&quot; scheduler a model uses, but they can just as easily be incorporated in a <code>model_step!</code> function as shown in <a href="../tutorial/#Advanced-stepping">Advanced stepping</a>.</p><h3 id="Predefined-schedulers"><a class="docs-heading-anchor" href="#Predefined-schedulers">Predefined schedulers</a><a id="Predefined-schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-schedulers" title="Permalink"></a></h3><p>Some useful schedulers are available below as part of the Agents.jl public API:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.fastest" href="#Agents.fastest"><code>Agents.fastest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fastest</code></pre><p>Activate all agents once per step in the order dictated by the agent&#39;s container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.by_id" href="#Agents.by_id"><code>Agents.by_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">by_id</code></pre><p>Activate agents at each step according to their id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_activation" href="#Agents.random_activation"><code>Agents.random_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_activation</code></pre><p>Activate agents once per step in a random order. Different random ordering is used at each different step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.partial_activation" href="#Agents.partial_activation"><code>Agents.partial_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partial_activation(p)</code></pre><p>At each step, activate only <code>p</code> percentage of randomly chosen agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.property_activation" href="#Agents.property_activation"><code>Agents.property_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">property_activation(property)</code></pre><p>At each step, activate the agents in an order dictated by their <code>property</code>, with agents with greater <code>property</code> acting first. <code>property</code> is a <code>Symbol</code>, which just dictates which field the agents to compare.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.by_type" href="#Agents.by_type"><code>Agents.by_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">by_type(shuffle_types::Bool, shuffle_agents::Bool)</code></pre><p>Useful only for mixed agent models using <code>Union</code> types.</p><ul><li>Setting <code>shuffle_types = true</code> groups by agent type, but randomizes the type order.</li></ul><p>Otherwise returns agents grouped in order of appearance in the <code>Union</code>.</p><ul><li><code>shuffle_agents = true</code> randomizes the order of agents within each group, <code>false</code> returns</li></ul><p>the default order of the container (equivalent to <a href="#Agents.fastest"><code>fastest</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L67-L74">source</a></section><section><div><pre><code class="language-none">by_type((C, B, A), shuffle_agents::Bool)</code></pre><p>Activate agents by type in specified order (since <code>Union</code>s are not order preserving). <code>shuffle_agents = true</code> randomizes the order of agents within each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/schedule.jl#L89-L93">source</a></section></article><h3 id="Advanced-scheduling"><a class="docs-heading-anchor" href="#Advanced-scheduling">Advanced scheduling</a><a id="Advanced-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-scheduling" title="Permalink"></a></h3><p>You can use <a href="https://docs.julialang.org/en/v1.5/manual/methods/#Function-like-objects">Function-like-objects</a> to make your scheduling possible of arbitrary events. For example, imagine that after the <code>n</code>-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define</p><pre><code class="language-julia">mutable struct MyScheduler
    n::Int # step number
    w::Float64
end</code></pre><p>and then define a calling method for it like so</p><pre><code class="language-julia">function (ms::MyScheduler)(model::ABM)
    ms.n += 1 # increment internal counter by 1 each time its called
              # be careful to use a *new* instance of this scheduler when plotting!
    if ms.n &lt; 10
        return allids(model) # order doesn&#39;t matter in this case
    else
        ids = collect(allids(model))
        # filter all ids whose agents have `w` less than some amount
        filter!(id -&gt; model[id].w &lt; ms.w, ids)
        return ids
    end
end</code></pre><p>and pass it to e.g. <code>step!</code> by initializing it</p><pre><code class="language-julia">ms = MyScheduler(100, 0.5)
step!(model, agentstep, modelstep, 100; scheduler = ms)</code></pre><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Plotting functionality comes Plots.jl. You need to install a plotting backend (we use GR and pyplot) to use the following functions.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.plotabm" href="#Agents.plotabm"><code>Agents.plotabm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plotabm(model::ABM{&lt;: ContinuousSpace}; ac, as, am, kwargs...)
plotabm(model::ABM{&lt;: DiscreteSpace}; ac, as, am, kwargs...)</code></pre><p>Plot the <code>model</code> as a <code>scatter</code>-plot, by configuring the agent shape, color and size via the keywords <code>ac, as, am</code>. These keywords can be constants, or they can be functions, each accepting an agent and outputting a valid value for color/shape/size.</p><p>The keyword <code>scheduler = model.scheduler</code> decides the plotting order of agents (which matters only if there is overlap).</p><p>The keyword <code>offset</code> is a function with argument <code>offest(a::Agent)</code>. It targets scenarios where multiple agents existin within a grid cell as it adds an offset (same type as <code>agent.pos</code>) to the plotted agent position.</p><p>All other keywords are propagated into <code>Plots.scatter</code> and the plot is returned.</p><pre><code class="language-none">plotabm(model::ABM{&lt;: GraphSpace}; ac, as, am, kwargs...)</code></pre><p>This function is the same as <code>plotabm</code> for <code>ContinuousSpace</code>, but here the three key functions <code>ac, as, am</code> do not get an agent as an input but a vector of agents at each node of the graph. Their output is the same.</p><p>Here <code>as</code> defaults to <code>length</code>. Internally, the <code>graphplot</code> recipe is used, and all other <code>kwargs...</code> are propagated there.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/visualization/plot-recipes.jl#L10-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.plotabm!" href="#Agents.plotabm!"><code>Agents.plotabm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plotabm!(model)
plotabm!(plt, model)</code></pre><p>Functionally the same as <a href="#Agents.plotabm"><code>plotabm</code></a>, however this method appends to the active plot, or one identified as <code>plt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/visualization/plot-recipes.jl#L38-L44">source</a></section></article><h2 id="Interactive-application"><a class="docs-heading-anchor" href="#Interactive-application">Interactive application</a><a id="Interactive-application-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-application" title="Permalink"></a></h2><p>You need to be using <code>InteractiveDynamics</code> to access this application, as well as <code>GLMakie</code> to provide a plotting backend. Then you can use the function <code>abm_data_exploration</code> as explained in the <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a> example.</p><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abm_data_exploration" href="#InteractiveDynamics.abm_data_exploration"><code>InteractiveDynamics.abm_data_exploration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abm_data_exploration(model::ABM, agent_step!, model_step!, params=Dict(); kwargs...)</code></pre><p>Open an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires <code>Agents</code>.</p><p>The application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in <a href="@ref"><code>abm_play</code></a>, and the arguments <code>model, agent_step!, model_step!</code> are propagated there as-is.</p><p>Calling <code>abm_data_exploration</code> returns: <code>figure, agent_df, model_df</code>. So you can save the figure, but you can also access the collected data (if any).</p><p><strong>Interaction</strong></p><p>Besides the basic time evolution interaction of <a href="@ref"><code>abm_play</code></a>, additional functionality here allows changing model parameters in real time, based on the provided fourth argument <code>params</code>. This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of <code>params</code> is a pair of <code>Symbol</code> to an <code>AbstractVector</code>, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only updated into the actual model when pressing the &quot;update&quot; button.</p><p>The &quot;reset&quot; button resets the model to its original agent and space state but it updates it to the currently selected parameter values. A red vertical line is displayed in the data plots when resetting, for visual guidance.</p><p><strong>Keywords</strong></p><ul><li><code>ac, am, as, scheduler, offset, equalaspect, scatterkwargs</code>: propagated to <a href="@ref"><code>abm_plot</code></a>.</li><li><code>adata, mdata</code>: Same as the keyword arguments of <code>Agents.run!</code>, and decide which data of the model/agents will be collected and plotted below the interactive plot. Notice that data collection can only occur on plotted steps (and thus steps not plotted due to &quot;spu&quot; are also not data-collected).</li><li><code>alabels, mlabels</code>: If data are collected from agents or the model with <code>adata, mdata</code>, the corresponding plots have a y-label named after the collected data. Instead, you can give <code>alabels, mlabels</code> (vectors of strings with exactly same length as <code>adata, mdata</code>), and these labels will be used instead.</li><li><code>when = true</code>: When to perform data collection, as in <code>Agents.run!</code>.</li><li><code>spu = 1:100</code>: Values that the &quot;spu&quot; slider will obtain.</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Predefined Models</a><a class="docs-footer-nextpage" href="../interact/">Interactive application »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 February 2021 16:15">Monday 22 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
