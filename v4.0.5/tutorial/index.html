<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#.-The-model"><span>1. The model</span></a></li><li><a class="tocitem" href="#Space"><span>2. The space</span></a></li><li><a class="tocitem" href="#.-The-agent"><span>3. The agent</span></a></li><li><a class="tocitem" href="#.-Evolving-the-model"><span>4. Evolving the model</span></a></li><li><a class="tocitem" href="#.-Collecting-data"><span>5. Collecting data</span></a></li><li><a class="tocitem" href="#An-educative-example"><span>An educative example</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/">Overview</a></li><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sugarscape/">Sugarscape</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-Prey</a></li><li><a class="tocitem" href="../examples/growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../examples/opinion_spread/">Opinion spread</a></li><li><a class="tocitem" href="../examples/battle/">Battle Royale</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak</a></li></ul></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../interact/">Interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">LightGraphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li></ul></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>Agents.jl is composed of components for building models, building and managing space structures, collecting data, running batch simulations, and data visualization.</p><p>Agents.jl structures simulations in three components:</p><ol><li>An <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> instance.</li><li>A <a href="#Space">space</a> instance.</li><li>A subtype of <a href="#Agents.AbstractAgent"><code>AbstractAgent</code></a> for the agents.</li></ol><p>To run simulations and collect data, the following are also necessary</p><ol><li>Stepping functions that controls how the agents and the model evolve.</li><li>Specifying which data should be collected from the agents and/or the model.</li></ol><p>So, in order to set up and run an ABM simulation with Agents.jl, you typically need to define a structure, function, or parameter collection for steps 1-3, define the rules of the agent evolution for step 4, and then declare which parameters of the model and the agents should be collected as data during step 5.</p><h2 id=".-The-model"><a class="docs-heading-anchor" href="#.-The-model">1. The model</a><a id=".-The-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AgentBasedModel(AgentType [, space]; scheduler, properties) → model</code></pre><p>Create an agent based model from the given agent type and <code>space</code>. You can provide an agent <em>instance</em> instead of type, and the type will be deduced.  <code>ABM</code> is equivalent with <code>AgentBasedModel</code>.</p><p>The agents are stored in a dictionary that maps unique ids (integers) to agents. Use <code>model[id]</code> to get the agent with the given <code>id</code>.</p><p><code>space</code> is a subtype of <code>AbstractSpace</code>: <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>, <a href="#Agents.GridSpace"><code>GridSpace</code></a> or <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. If it is ommited then all agents are virtually in one position and have no spatial structure.</p><p><strong>Note:</strong> Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.</p><p><code>properties = nothing</code> is additional model-level properties (typically a dictionary) that can be accessed as <code>model.properties</code>. However, if <code>properties</code> is a dictionary with key type <code>Symbol</code>, or of it is a struct, then the syntax <code>model.name</code> is short hand for <code>model.properties[:name]</code> (or <code>model.properties.name</code> for structs). This syntax can&#39;t be used for <code>name</code> being <code>agents, space, scheduler, properties</code>, which are the fields of <code>AgentBasedModel</code>.</p><p><code>scheduler = fastest</code> decides the order with which agents are activated (see e.g. <a href="../api/#Agents.by_id"><code>by_id</code></a> and the scheduler API).</p><p>Type tests for <code>AgentType</code> are done, and by default warnings are thrown when appropriate. Use keyword <code>warn=false</code> to supress that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/model.jl#L40-L69">source</a></section></article><h2 id="Space"><a class="docs-heading-anchor" href="#Space">2. The space</a><a id="Space-1"></a><a class="docs-heading-anchor-permalink" href="#Space" title="Permalink"></a></h2><p>Agents.jl offers several possibilities for the space the agents live in. In addition, it is straightforward to implement a fundamentally new type of space, see <a href="../devdocs/#Developer-Docs">Developer Docs</a>.</p><p>Spaces are separated into disrete spaces (which by definition have a <strong>finite</strong> amount of <strong>possible positions</strong>) and continuous spaces. Thus, it is common for a specific position to contain several agents.</p><h3 id="Discrete-spaces"><a class="docs-heading-anchor" href="#Discrete-spaces">Discrete spaces</a><a id="Discrete-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphSpace" href="#Agents.GraphSpace"><code>Agents.GraphSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphSpace(graph::AbstractGraph)</code></pre><p>Create a <code>GraphSpace</code> instance that is underlined by an arbitrary graph from <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>. The position type for this space is <code>Int</code>, use <a href="#Agents.GraphAgent"><code>GraphAgent</code></a> for convenience. The underlying graph can be altered using <a href="../api/#Agents.add_node!"><code>add_node!</code></a> and <a href="../api/#Agents.rem_node!"><code>rem_node!</code></a>.</p><p><code>GraphSpace</code> represents a space where each node (i.e. position) of a graph can hold an arbitrary amount of agents, and each agent can move between the nodes of the graph. An example of its usage can be found in <a href="../examples/sir/#SIR-model-for-the-spread-of-COVID-19">SIR model for the spread of COVID-19</a>. If you want to model social networks, where each agent is equivalent with a node of a graph, you&#39;re better of using <code>nothing</code> (or other spaces) as the model space, and using a graph from LightGraphs.jl directly in the model parameters, as shown in the <a href="../examples/schoolyard/#Social-networks-with-LightGraphs.jl">Social networks with LightGraphs.jl</a> integration example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/graph.jl#L11-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridSpace" href="#Agents.GridSpace"><code>Agents.GridSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridSpace(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)</code></pre><p>Create a <code>GridSpace</code> that has size given by the tuple <code>d</code>, having <code>D ≥ 1</code> dimensions. Optionally decide whether the space will be periodic and what will be the distance metric used, which decides the behavior of e.g. <a href="../api/#Agents.nearby_ids"><code>nearby_ids</code></a>. The position type for this space is <code>NTuple{D, Int}</code>, use <a href="#Agents.GridAgent"><code>GridAgent</code></a> for convenience. In our examples we typically use <code>Dims{D}</code> instead of <code>NTuple{D, Int}</code> (they are equivalent). Valid positions have indices in the range <code>1:d[i]</code> for the <code>i</code>th dimension.</p><p><code>:chebyshev</code> metric means that the <code>r</code>-neighborhood of a position are all positions within the hypercube having side length of <code>2*floor(r)</code> and being centered in the origin position.</p><p><code>:euclidean</code> metric means that the <code>r</code>-neighborhood of a position are all positions whose cartesian indices have Euclidean distance <code>≤ r</code> from the cartesian index of the given position.</p><p>An example using <code>GridSpace</code> is the <a href="../examples/forest_fire/#Forest-fire-model">Forest fire model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/grid.jl#L26-L44">source</a></section></article><h3 id="Continuous-spaces"><a class="docs-heading-anchor" href="#Continuous-spaces">Continuous spaces</a><a id="Continuous-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousSpace" href="#Agents.ContinuousSpace"><code>Agents.ContinuousSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousSpace(extent::NTuple{D, &lt;:Real}, spacing = min(extent...)/10; kwargs...)</code></pre><p>Create a <code>D</code>-dimensional <code>ContinuousSpace</code> in range 0 to (but not including) <code>extent</code>. <code>spacing</code> configures the compartment spacing that the space is divided in, in order to accelerate nearest neighbor functions like <a href="../api/#Agents.nearby_ids"><code>nearby_ids</code></a>. All dimensions in <code>extent</code> must be completely divisible by <code>spacing</code> (i.e. no fractional remainder). Your agent positions (field <code>pos</code>) must be of type <code>NTuple{D, &lt;:Real}</code>, use <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a> for convenience. In addition it is useful for agents to have a field <code>vel::NTuple{D, &lt;:Real}</code> to use in conjunction with <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a>.</p><p>The keyword <code>periodic = true</code> configures whether the space is periodic or not. If set to <code>false</code> an error will occur if an agent&#39;s position exceeds the boundary.</p><p>The keyword argument <code>update_vel!</code> is a <strong>function</strong>, <code>update_vel!(agent, model)</code> that updates the agent&#39;s velocity <strong>before</strong> the agent has been moved, see <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a>. You can of course change the agents&#39; velocities during the agent interaction, the <code>update_vel!</code> functionality targets spatial force fields acting on the agents individually (e.g. some magnetic field). By default no update is done this way. If you use <code>update_vel!</code>, the agent type must have a field <code>vel::NTuple{D, &lt;:Real}</code>.</p><p>There is no &quot;best&quot; choice for the value of <code>spacing</code>. If you need optimal performance it&#39;s advised to set up a benchmark over a range of choices. The value matters most when searching for neighbors. In <a href="../models/#Agents.Models.flocking-Tuple{}"><code>Models.flocking</code></a> for example, an optimal value for <code>spacing</code> is 66% of the search distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/continuous.jl#L13-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OpenStreetMapSpace" href="#Agents.OpenStreetMapSpace"><code>Agents.OpenStreetMapSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OpenStreetMapSpace(path::AbstractString; kwargs...)</code></pre><p>Create a space residing on the Open Street Map (OSM) file provided via <code>path</code>.</p><p>The abbreviation <code>OSMSpace</code> may be used interchangeably.</p><p>Much of the functionality of this space is provided by interfacing with <a href="https://github.com/pszufe/OpenStreetMapX.jl">OpenStreetMapX.jl</a>, for example the two keyword arguments <code>use_cache = false</code> and <code>trim_to_connected_graph = true</code> can be passed into the <code>OpenStreetMapX.get_map_data</code> function.</p><p>For details on how to obtain an OSM file for your use case, consult the OpenStreetMapX.jl README. We provide a variable <code>TEST_MAP</code> to use as a <code>path</code> for testing.</p><p>This space represents the underlying map as a <em>continuous</em> entity choosing accuracy over performance. An example of its usage can be found in <a href="../examples/zombies/#Zombie-Outbreak">Zombie Outbreak</a>.</p><p>If your solution can tolerate routes to and from intersections only, a faster implementation can be achieved by using the <a href="https://pszufe.github.io/OpenStreetMapX.jl/stable/reference/#OpenStreetMapX.MapData">graph representation</a> of your map provided by OpenStreetMapX.jl. For tips on how to implement this, see our integration example: <a href="../examples/schoolyard/#Social-networks-with-LightGraphs.jl">Social networks with LightGraphs.jl</a>.</p><p><strong>The OSMAgent</strong></p><p>The base properties for an agent residing on an <code>OSMSpace</code> are as follows:</p><pre><code class="language-julia">mutable struct OSMAgent &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int,Int,Float64}
    route::Vector{Int}
    destination::Tuple{Int,Int,Float64}
end</code></pre><p>Current <code>pos</code>ition and <code>destination</code> tuples are represented as <code>(start intersection index, finish intersection index, distance travelled in meters)</code>. The <code>route</code> is an ordered list of intersections, providing a path to reach <code>destination</code>.</p><p>Further details can be found in <a href="#Agents.OSMAgent"><code>OSMAgent</code></a>.</p><p><strong>Routing</strong></p><p>There are two ways to generate a route, depending on the situation.</p><ol><li><a href="../api/#Agents.osm_plan_route"><code>osm_plan_route</code></a>, which provides <code>:shortest</code> and <code>:fastest</code> paths (with the option of a <code>return_trip</code>) between intersections or positions.</li><li><a href="../api/#Agents.osm_random_route!"><code>osm_random_route!</code></a>, choses a new <code>destination</code> an plans a new path to it; overriding the current route (if any).</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/spaces/openstreetmap.jl#L17-L63">source</a></section></article><h2 id=".-The-agent"><a class="docs-heading-anchor" href="#.-The-agent">3. The agent</a><a id=".-The-agent-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-agent" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractAgent</code></pre><p>All agents must be a mutable subtype of <code>AbstractAgent</code>. Your agent type <strong>must have</strong> the <code>id</code> field as first field. Depending on the space structure there might be a <code>pos</code> field of appropriate type and a <code>vel</code> field of appropriate type. Each space structure quantifies precicely what extra fields (if any) are necessary, however we recommend to use the [<code>@agent</code>] macro to help you create the agent type.</p><p>Your agent type may have other additional fields relevant to your system, for example variable quantities like &quot;status&quot; or other &quot;counters&quot;.</p><p><strong>Examples</strong></p><p>As an example, a <a href="#Agents.GraphSpace"><code>GraphSpace</code></a> requires an <code>id::Int</code> field and a <code>pos::Int</code> field. To make an agent with two additional properties, <code>weight, happy</code>, we&#39;d write</p><pre><code class="language-julia">mutable struct ExampleAgent &lt;: AbstractAgent
    id::Int
    pos::Int
    weight::Float64
    happy::Bool
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/agents.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.@agent" href="#Agents.@agent"><code>Agents.@agent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@agent YourAgentType{X, Y} AgentSupertype begin
    some_property::X
    other_extra_property::Y
    # etc...
end</code></pre><p>Create a struct for your agents which includes the mandatory fields required to operate in a particular space. Depending on the space of your model, the <code>AgentSupertype</code> is chosen appropriately from <a href="#Agents.GraphAgent"><code>GraphAgent</code></a>, <a href="#Agents.GridAgent"><code>GridAgent</code></a>, <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a>.</p><p><strong>Example</strong></p><p>Using</p><pre><code class="language-julia">@agent Person{T} GridAgent{2} begin
    age::Int
    moneyz::T
end</code></pre><p>will in fact create an agent appropriate for using with 2-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a></p><pre><code class="language-julia">mutable struct Person{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    age::Int
    moneyz::T
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/agents.jl#L29-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphAgent" href="#Agents.GraphAgent"><code>Agents.GraphAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphAgent</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>. It attributes the fields <code>id::Int, pos::Int</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/agents.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridAgent" href="#Agents.GridAgent"><code>Agents.GridAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridAgent{D}</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <code>D</code>-dimensional <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>. It attributes the fields <code>id::Int, pos::NTuple{D,Int}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/agents.jl#L80-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousAgent" href="#Agents.ContinuousAgent"><code>Agents.ContinuousAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousAgent{D}</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <code>D</code>-dimensional <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. It attributes the fields <code>id::Int, pos::NTuple{D,Float64}, vel::NTuple{D,Float64}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/agents.jl#L91-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSMAgent" href="#Agents.OSMAgent"><code>Agents.OSMAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OSMAgent</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>. It attributes the fields <code>id::Int, pos::Tuple{Int,Int,Float64}, route::Vector{Int}, destination::Tuple{Int,Int,Float64}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/core/agents.jl#L104-L110">source</a></section></article><p>Once an Agent is created it can be added to a model using e.g. <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. Then, the agent can interact with the model and the space further by using e.g. <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> or <a href="../api/#Agents.kill_agent!"><code>kill_agent!</code></a>.</p><p>For more functions visit the <a href="../api/#API">API</a> page.</p><h2 id=".-Evolving-the-model"><a class="docs-heading-anchor" href="#.-Evolving-the-model">4. Evolving the model</a><a id=".-Evolving-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-Evolving-the-model" title="Permalink"></a></h2><p>Any ABM model should have at least one and at most two step functions. An <em>agent step function</em> is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a <em>model step function</em>.</p><p>An agent step function should only accept two arguments: first, an agent object, and second, a model object.</p><p>The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in <a href="#Agents.dummystep"><code>dummystep</code></a> as the agent step function.</p><p>After you have defined these two functions, you evolve your model with <code>step!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.step!" href="#Agents.step!"><code>Agents.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(model, agent_step!, n::Int = 1)
step!(model, agent_step!, model_step!, n::Int = 1, agents_first::Bool=true)</code></pre><p>Update agents <code>n</code> steps according to the stepping function <code>agent_step!</code>. Agents will be activated as specified by the <code>model.scheduler</code>. <code>model_step!</code> is triggered <em>after</em> every scheduled agent has acted, unless the argument <code>agents_first</code> is <code>false</code> (which then first calls <code>model_step!</code> and then activates the agents).</p><p><code>step!</code> ignores scheduled IDs that do not exist within the model, allowing you to safely kill agents dynamically.</p><pre><code class="language-none">step!(model, agent_step!, model_step!, n::Function, agents_first::Bool=true)</code></pre><p>In this version <code>n</code> is a function. Then <code>step!</code> runs the model until <code>n(model, s)</code> returns <code>true</code>, where <code>s</code> is the current amount of steps taken, starting from 0. For this method of <code>step!</code>, <code>model_step!</code> must be provided always (use <a href="#Agents.dummystep"><code>dummystep</code></a> if you have no model stepping dynamics).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/step.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.dummystep" href="#Agents.dummystep"><code>Agents.dummystep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dummystep(model)</code></pre><p>Use instead of <code>model_step!</code> in <a href="#Agents.step!"><code>step!</code></a> if no function is useful to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/step.jl#L26-L30">source</a></section><section><div><pre><code class="language-none">dummystep(agent, model)</code></pre><p>Use instead of <code>agent_step!</code> in <a href="#Agents.step!"><code>step!</code></a> if no function is useful to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/step.jl#L32-L36">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Current step number</header><div class="admonition-body"><p>Notice that the current step number is not explicitly given to the <code>model_step!</code> function, because this is useful only for a subset of ABMs. If you need the step information, implement this by adding a counting parameter into the model <code>properties</code>, and incrementing it by 1 each time <code>model_step!</code> is called. An example can be seen in the <code>model_step!</code> function of <a href="../examples/daisyworld/#Daisyworld">Daisyworld</a>, where a <code>tick</code> is increased at each step.</p></div></div><h3 id="Advanced-stepping"><a class="docs-heading-anchor" href="#Advanced-stepping">Advanced stepping</a><a id="Advanced-stepping-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-stepping" title="Permalink"></a></h3><p>The interface of <a href="#Agents.step!"><code>step!</code></a>, which allows the option of both <code>agent_step!</code> and <code>model_step!</code> is driven mostly by convenience. In principle, the <code>model_step!</code> function by itself can perform all operations related with stepping the ABM. However, for many models, this simplified approach offers the benefit of not having to write an explicit loop over existing agents inside the <code>model_step!</code>. Most of the examples in our documentation can be expressed using an independent <code>agent_step!</code> and <code>model_step!</code> function.</p><p>On the other hand, more advanced models require special handling for scheduling, or may need to schedule several times and act on different subsets of agents with different functions. In such a scenario, it is more sensible to provide only a <code>model_step!</code> function (and use <code>dummystep</code> as <code>agent_step!</code>), where all configuration is contained within. For example</p><pre><code class="language-julia">function complex_step!(model)
    for a in scheduler1(model)
        agent_step1!(a, model)
    end
    intermediate_model_action!(model)
    for a in scheduler2(model)
        agent_step2!(a, model)
    end
    final_model_action!(model)
end

step!(model, dummystep, complex_step!, n)</code></pre><p>For defining your own scheduler, see <a href="../api/#Schedulers">Schedulers</a>.</p><h2 id=".-Collecting-data"><a class="docs-heading-anchor" href="#.-Collecting-data">5. Collecting data</a><a id=".-Collecting-data-1"></a><a class="docs-heading-anchor-permalink" href="#.-Collecting-data" title="Permalink"></a></h2><p>Running the model and collecting data while the model runs is done with the <a href="#Agents.run!"><code>run!</code></a> function. Besides <code>run!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection, while scanning ranges of the parameters of the model.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.run!" href="#Agents.run!"><code>Agents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df
run!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df</code></pre><p>Run the model (step it with the input arguments propagated into <a href="#Agents.step!"><code>step!</code></a>) and collect data specified by the keywords, explained one by one below. Return the data as two <code>DataFrame</code>s, one for agent-level data and one for model-level data.</p><p><strong>Data-deciding keywords</strong></p><ul><li><p><code>adata::Vector</code> means &quot;agent data to collect&quot;. If an entry is a <code>Symbol</code>, e.g. <code>:weight</code>, then the data for this entry is agent&#39;s field <code>weight</code>. If an entry is a <code>Function</code>, e.g. <code>f</code>, then the data for this entry is just <code>f(a)</code> for each agent <code>a</code>. The resulting dataframe columns are named with the input symbol (here <code>:weight, :f</code>).</p></li><li><p><code>adata::Vector{&lt;:Tuple}</code>: if <code>adata</code> is a vector of tuples instead, data aggregation is done over the agent properties.</p><p>For each 2-tuple, the first entry is the &quot;key&quot; (any entry like the ones mentioned above, e.g. <code>:weight, f</code>). The second entry is an aggregating function that aggregates the key, e.g. <code>mean, maximum</code>. So, continuing from the above example, we would have <code>adata = [(:weight, mean), (f, maximum)]</code>.</p><p>It&#39;s also possible to provide a 3-tuple, with the third entry being a conditional function (returning a <code>Bool</code>), which assesses if each agent should be included in the aggregate. For example: <code>x_pos(a) = a.pos[1]&gt;5</code> with <code>(:weight, mean, x_pos)</code> will result in the average weight of agents conditional on their x-position being greater than 5.</p><p>The resulting data name columns use the function <a href="../api/#Agents.aggname"><code>aggname</code></a>, and create something like <code>:mean_weight</code> or <code>:maximum_f_x_pos</code>. This name doesn&#39;t play well with anonymous functions, but you can simply use <code>DataFrames.rename!</code> to change the returned dataframe&#39;s column names.</p><p><strong>Notice:</strong> Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. <em>E.g.</em> instead of passing <code>mean</code>, pass <code>mymean(a) = isempty(a) ? 0.0 : mean(a)</code>.</p></li><li><p><code>mdata::Vector</code> means &quot;model data to collect&quot; and works exactly like <code>adata</code>. For the model, no aggregation is possible (nothing to aggregate over).</p></li></ul><p>By default both keywords are <code>nothing</code>, i.e. nothing is collected/aggregated.</p><p><strong>Mixed-Models</strong></p><p>For mixed-models, the <code>adata</code> keyword has some additional options &amp; properties.   An additional column <code>agent_type</code> will be placed in the output   dataframe.</p><p>In the case that data is needed for one agent type that does not exist   in a second agent type, <code>missing</code> values will be added to the dataframe.</p><p><strong>Warning:</strong> Since this option is inherently type unstable, try to avoid this   in a performance critical situation.</p><p>Aggregate functions will fail if <code>missing</code> values are not handled explicitly.   If <code>a1.weight</code> but <code>a2</code> (type: Agent2) has no <code>weight</code>, use   <code>a2(a) = a isa Agent2; adata = [(:weight, sum, a2)]</code> to filter out the missing results.</p><p><strong>Other keywords</strong></p><ul><li><code>when=true</code> : at which steps <code>s</code> to perform the data collection and processing. A lot of flexibility is offered based on the type of <code>when</code>. If <code>when::Vector</code>, then data are collect if <code>s ∈ when</code>. Otherwise data are collected if <code>when(model, s)</code> returns <code>true</code>. By default data are collected in every step.</li><li><code>when_model = when</code> : same as <code>when</code> but for model data.</li><li><code>obtainer = identity</code> : method to transfer collected data to the <code>DataFrame</code>. Typically only change this to <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy"><code>copy</code></a> if some data are mutable containers (e.g. <code>Vector</code>) which change during evolution, or <a href="https://docs.julialang.org/en/v1/base/base/#Base.deepcopy"><code>deepcopy</code></a> if some data are nested mutable containers. Both of these options have performance penalties.</li><li><code>replicates=0</code> : Run <code>replicates</code> replicates of the simulation.</li><li><code>parallel=false</code> : Only when <code>replicates&gt;0</code>. Run replicate simulations in parallel.</li><li><code>agents_first=true</code> : Whether to update agents first and then the model, or vice versa.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/5ff35fd06990889fd240f2b100be2ab5f69ac7c4/src/simulations/collect.jl#L25-L97">source</a></section></article><p>The <a href="#Agents.run!"><code>run!</code></a> function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregating model data, or arbitrary combinations.</p><p>This means that <a href="#Agents.run!"><code>run!</code></a> has not been designed for maximum performance (or minimum memory allocation). However, we also expose a simple data-collection API (see <a href="../api/#Data-collection">Data collection</a>), that gives users even more flexibility, allowing them to make their own &quot;data collection loops&quot; arbitrarily calling <code>step!</code> and collecting data as, and when, needed.</p><h2 id="An-educative-example"><a class="docs-heading-anchor" href="#An-educative-example">An educative example</a><a id="An-educative-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-educative-example" title="Permalink"></a></h2><p>A simple, education-oriented example of using the basic Agents.jl API is given in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>, also discussing in detail how to visualize your ABMs.</p><p>Each of the examples listed within this documentation are designed to showcase different ways of interacting with the API. If you are not sure about how to use a particular function, most likely one of the examples can show you how to interact with it.</p><p>For a quick reference concerning the main concepts of agent based modelling, and how the Agents.jl examples implement each one, take a look at the <a href="../examples/#Overview-of-Examples">Overview of Examples</a> page.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 22 February 2021 16:15">Monday 22 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
