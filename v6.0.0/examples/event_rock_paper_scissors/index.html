<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · Agents.jl</title><meta name="title" content="- · Agents.jl"/><meta property="og:title" content="- · Agents.jl"/><meta property="twitter:title" content="- · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../flock/">Flocking model</a></li><li><a class="tocitem" href="../zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../agents_visualizations/">Plotting and Interactivity</a></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/event_rock_paper_scissors.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><a href="@id eventbased_tutorial">Spatial rock-paper-scissors (event based)</a></p><p>This is an introductory example. Similarly to <a href="@ref">Schelling&#39;s segregation model</a>, its goal is to provide a tutorial but for the <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a> instead of the <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>. It assumes that you have gone through both the <a href="../../tutorial/#Tutorial">Tutorial</a> and the <a href="@ref">Schelling&#39;s segregation model</a> example.</p><p>The spatial rock-paper-scissors (RPS) is an ABM with the following rules:</p><ul><li>Agents can be any of three types: Rock, Paper, or Scissors.</li><li>Agents live in a 2D periodic grid space allowing only one agent per cell.</li><li>When an agent activates, it can do one of three actions:<ol><li>Attack: choose a random nearby agent and attack it. If the agent loses the RPS game it gets removed.</li><li>Move: choose a random nearby position. If it is empty move to it, otherwise swap positions with the agent there.</li><li>Reproduce: choose a random empty nearby position (if any). Generate there a new agent of the same type.</li></ol></li></ul><p>And that&#39;s it really! However, we want to model this ABM as an event-based model. This means that these three actions are independent events that will get added to a queue of events. We will address this in a moment. For now, let&#39;s just make functions that represent the actions of the events.</p><h2 id="Defining-the-event-functions"><a class="docs-heading-anchor" href="#Defining-the-event-functions">Defining the event functions</a><a id="Defining-the-event-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-event-functions" title="Permalink"></a></h2><p>We start by loading <code>Agents</code></p><pre><code class="language-julia hljs">using Agents, Random</code></pre><p>and defining the three agent types</p><pre><code class="language-julia hljs">@agent struct Rock(GridAgent{2}) end
@agent struct Paper(GridAgent{2}) end
@agent struct Scissors(GridAgent{2}) end</code></pre><p>Actions of events are standard Julia functions that utilize Agents.jl <a href="../../api/#API">API</a>, exactly like those given as <code>agent_step!</code> in <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>. They act on an agent and take the model as the second input and end with an empty <code>return</code> statement (as their return value is not utilized by Agents.jl).</p><p>The first action is the attack:</p><pre><code class="language-julia hljs">function attack!(agent, model)
    # Randomly pick a nearby agent
    contender = random_nearby_agent(agent, model)
    # do nothing if there isn&#39;t anyone nearby
    isnothing(contender) &amp;&amp; return
    # else perform standard rock paper scissors logic
    # and remove the contender if you win
    if agent isa Rock &amp;&amp; contender isa Scissors
        remove_agent!(contender, model)
    elseif agent isa Scissors &amp;&amp; contender isa Paper
        remove_agent!(contender, model)
    elseif agent isa Paper &amp;&amp; contender isa Rock
        remove_agent!(contender, model)
    end
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">attack! (generic function with 1 method)</code></pre><p>The movement function is equally simple due to the many functions offered by Agents.jl <a href="../../api/#API">API</a>.</p><pre><code class="language-julia hljs">function move!(agent, model)
    rand_pos = random_nearby_position(agent.pos, model)
    if isempty(rand_pos, model)
        move_agent!(agent, rand_pos, model)
    else
        occupant_id = id_in_position(rand_pos, model)
        occupant = model[occupant_id]
        swap_agents!(agent, occupant, model)
    end
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">move! (generic function with 1 method)</code></pre><p>The reproduction function is the simplest one.</p><pre><code class="language-julia hljs">function reproduce!(agent, model)
    pos = random_nearby_position(agent, model, 1, pos -&gt; isempty(pos, model))
    isnothing(pos) &amp;&amp; return
    add_agent!(pos, typeof(agent), model)
    return
end

# Defining the propensity and timing of the events</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reproduce! (generic function with 1 method)</code></pre><p>Besides the actual event action defined as the above functions, there are two more pieces of information necessary:</p><ol><li>how likely an event is to happen, and</li><li>how long after the previous event it will happen.</li></ol><p>Now, in the &quot;Gillespie&quot; type of simulations, these two things coincide: The probability for an event is its relative propensity (rate), and the time you have to wait for it to happen is inversely the propensity (rate). When creating an <code>AgentEvent</code> (see below), the user has the option to go along this &quot;Gillespie&quot; route, which is the default. However, the user can also have more control by explicitly providing a function that returns the time until an event triggers (by default this function becomes a random sample of an exponential distribution).</p><p>Let&#39;s make this concrete. For all events we need to define their propensities. Another way to think of propensities is the relative probability mass for an event to happen. The propensities may be constants or functions of the currently actived agent and the model.</p><p>Here, the propensities for moving and attacking will be constants,</p><pre><code class="language-julia hljs">attack_propensity = 1.0
movement_propensity = 0.5</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5</code></pre><p>while the propensity for reproduction will be a function</p><pre><code class="language-julia hljs">function reproduction_propensity(agent, model)
    return (1/2) ^ ceil(Int, abmtime(model))
end

# Creating the `AgentEvent` structures</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reproduction_propensity (generic function with 1 method)</code></pre><p>Events are registered as an <a href="@ref"><code>AgentEvent</code></a>, then are added into a container, and then given to the <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a>. The attack and reproduction events affect all agents, and hence we don&#39;t need to specify an agent type that this event applies to, leaving the <code>AbstractAgent</code> as the default.</p><pre><code class="language-julia hljs">attack_event = AgentEvent(action! = attack!, propensity = attack_propensity)

reproduction_event = AgentEvent(action! = reproduce!, propensity = reproduction_propensity)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), DataType, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, AbstractAgent, Agents.exp_propensity)</code></pre><p>The movement event does not apply to rocks however, so we need to specify the agent super type that it applies to, which is <code>Union{Scissors, Paper}</code>. Additionally, we would like to change how the timing of the movement events works. We want to change it from an exponential distribution sample to something else. This &quot;something else&quot; is once again an arbitrary Julia function, and for here we will make:</p><pre><code class="language-julia hljs">function movement_time(agent, model, propensity)
    # `agent` is the agent the event will be applied to,
    # which we do not use in this function!
    t = 0.1 * randn(abmrng(model)) + 1
    return clamp(t, 0, Inf)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">movement_time (generic function with 1 method)</code></pre><p>And with this we can now create</p><pre><code class="language-julia hljs">movement_event = AgentEvent(
    action! = move!, propensity = movement_propensity,
    types = Union{Scissors, Paper}, timing = movement_time
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AgentEvent{typeof(Main.move!), Float64, Union, typeof(Main.movement_time)}(Main.move!, 0.5, Union{Main.Paper, Main.Scissors}, Main.movement_time)</code></pre><p>we wrap all events in a tuple and we are done with the setting up part!</p><pre><code class="language-julia hljs">events = (attack_event, reproduction_event, movement_event)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AgentEvent{typeof(Main.attack!), Float64, DataType, typeof(Agents.exp_propensity)}(Main.attack!, 1.0, AbstractAgent, Agents.exp_propensity), AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), DataType, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, AbstractAgent, Agents.exp_propensity), AgentEvent{typeof(Main.move!), Float64, Union, typeof(Main.movement_time)}(Main.move!, 0.5, Union{Main.Paper, Main.Scissors}, Main.movement_time))</code></pre><h2 id="Creating-and-populating-the-EventQueueABM"><a class="docs-heading-anchor" href="#Creating-and-populating-the-EventQueueABM">Creating and populating the <code>EventQueueABM</code></a><a id="Creating-and-populating-the-EventQueueABM-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-populating-the-EventQueueABM" title="Permalink"></a></h2><p>This step is almost identical to making a <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a> in the main <a href="../../tutorial/#Tutorial">Tutorial</a>. We create an instance of <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a> by giving it the agent types it will have, the events vector, and a space (optionally, defaults to no space). Here we have</p><pre><code class="language-julia hljs">space = GridSpaceSingle((100, 100))

rng = Xoshiro(42)
AgentTypes = Union{Rock, Paper, Scissors}
model = EventQueueABM(AgentTypes, events, space; rng, warn = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EventQueueABM{GridSpaceSingle{2, true}, Union{Main.Paper, Main.Rock, Main.Scissors}, Dict{Int64, Union{Main.Paper, Main.Rock, Main.Scissors}}, Nothing, Tuple{AgentEvent{typeof(Main.attack!), Float64, DataType, typeof(Agents.exp_propensity)}, AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), DataType, typeof(Agents.exp_propensity)}, AgentEvent{typeof(Main.move!), Float64, Union, typeof(Main.movement_time)}}, Random.Xoshiro, Vector{Vector{Int64}}, Vector{Vector{Float64}}, Vector{Vector{Int64}}, Dict{DataType, Int64}, DataStructures.PriorityQueue{Tuple{Int64, Int64}, Float64, Base.Order.ForwardOrdering}}(Dict{Int64, Union{Main.Paper, Main.Rock, Main.Scissors}}(), GridSpaceSingle with size (100, 100), metric=chebyshev, periodic=true, nothing, Random.Xoshiro(0xa379de7eeeb2a4e8, 0x953dccb6b532b3af, 0xf597b8ff8cfd652a, 0xccd7337c571680d1, 0xc90c4a0730db3f7e), (AgentEvent{typeof(Main.attack!), Float64, DataType, typeof(Agents.exp_propensity)}(Main.attack!, 1.0, AbstractAgent, Agents.exp_propensity), AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), DataType, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, AbstractAgent, Agents.exp_propensity), AgentEvent{typeof(Main.move!), Float64, Union, typeof(Main.movement_time)}(Main.move!, 0.5, Union{Main.Paper, Main.Scissors}, Main.movement_time)), [[1, 2, 3], [1, 2], [1, 2, 3]], [[1.0, 0.0, 0.5], [1.0, 0.0], [1.0, 0.0, 0.5]], [[2], [2], [2]], Dict{DataType, Int64}(Main.Rock =&gt; 2, Main.Paper =&gt; 1, Main.Scissors =&gt; 3), DataStructures.PriorityQueue{Tuple{Int64, Int64}, Float64, Base.Order.ForwardOrdering}(), true, true, Base.RefValue{Int64}(0), Base.RefValue{Float64}(0.0))</code></pre><p>populating the model with agents is as in the main <a href="../../tutorial/#Tutorial">Tutorial</a>, using the <a href="../../api/#Agents.add_agent!"><code>add_agent!</code></a> function. The only difference here is that (by default), when an agent is added to the model, the an event is generated for it and added to the queue.</p><pre><code class="language-julia hljs">for p in positions(model)
    type = rand(abmrng(model), (Rock, Paper, Scissors))
    add_agent!(p, type, model)
end

using CairoMakie
function dummyplot(model)
    fig = Figure()
    ax = Axis(fig[1,1])
    alla = allagents(model)
    colormap = Dict(Rock =&gt; &quot;black&quot;, Scissors =&gt; &quot;gray&quot;, Paper =&gt; &quot;orange&quot;)
    pos = [a.pos for a in alla]
    color = [colormap[typeof(a)] for a in alla]
    scatter!(ax, pos; color, markersize = 10)
    return fig
end

dummyplot(model)</code></pre><img src="f2f32bb2.png" alt="Example block output"/><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><p>Time evolution for <a href="@ref"><code>EventBasedABM</code></a> is identical to that of <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>, but time is continuous. So, when calling <code>step!</code> we pass in a real time.</p><pre><code class="language-julia hljs">step!(model, 1.0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EventQueueABM{GridSpaceSingle{2, true}, Union{Main.Paper, Main.Rock, Main.Scissors}, Dict{Int64, Union{Main.Paper, Main.Rock, Main.Scissors}}, Nothing, Tuple{AgentEvent{typeof(Main.attack!), Float64, DataType, typeof(Agents.exp_propensity)}, AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), DataType, typeof(Agents.exp_propensity)}, AgentEvent{typeof(Main.move!), Float64, Union, typeof(Main.movement_time)}}, Random.Xoshiro, Vector{Vector{Int64}}, Vector{Vector{Float64}}, Vector{Vector{Int64}}, Dict{DataType, Int64}, DataStructures.PriorityQueue{Tuple{Int64, Int64}, Float64, Base.Order.ForwardOrdering}}(Dict{Int64, Union{Main.Paper, Main.Rock, Main.Scissors}}(4986 =&gt; Main.Rock(4986, (86, 50)), 7329 =&gt; Main.Scissors(7329, (30, 73)), 10548 =&gt; Main.Scissors(10548, (18, 46)), 4700 =&gt; Main.Rock(4700, (100, 47)), 4576 =&gt; Main.Scissors(4576, (76, 46)), 7144 =&gt; Main.Scissors(7144, (45, 72)), 6073 =&gt; Main.Rock(6073, (73, 61)), 2288 =&gt; Main.Scissors(2288, (88, 23)), 1703 =&gt; Main.Paper(1703, (3, 18)), 1956 =&gt; Main.Paper(1956, (56, 20))…), GridSpaceSingle with size (100, 100), metric=chebyshev, periodic=true, nothing, Random.Xoshiro(0x42cc3cda30dda230, 0x29d24078f7f8fdff, 0x01a2b0545e328ab2, 0x4f224512bcf8f6a5, 0xc90c4a0730db3f7e), (AgentEvent{typeof(Main.attack!), Float64, DataType, typeof(Agents.exp_propensity)}(Main.attack!, 1.0, AbstractAgent, Agents.exp_propensity), AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), DataType, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, AbstractAgent, Agents.exp_propensity), AgentEvent{typeof(Main.move!), Float64, Union, typeof(Main.movement_time)}(Main.move!, 0.5, Union{Main.Paper, Main.Scissors}, Main.movement_time)), [[1, 2, 3], [1, 2], [1, 2, 3]], [[1.0, 0.5, 0.5], [1.0, 0.5], [1.0, 0.5, 0.5]], [[2], [2], [2]], Dict{DataType, Int64}(Main.Rock =&gt; 2, Main.Paper =&gt; 1, Main.Scissors =&gt; 3), DataStructures.PriorityQueue((9350, 3) =&gt; 1.00007610352171, (4559, 3) =&gt; 1.0002002459053325, (684, 3) =&gt; 1.0002139384318298, (7503, 2) =&gt; 1.0002742012535577, (5957, 1) =&gt; 1.0002929642088576, (7122, 2) =&gt; 1.000364568061554, (8107, 3) =&gt; 1.0003990625965218, (2452, 1) =&gt; 1.0004340314915374, (8579, 1) =&gt; 1.0004423583096242, (7061, 3) =&gt; 1.0005472093853127…), true, true, Base.RefValue{Int64}(10706), Base.RefValue{Float64}(1.0))</code></pre><p>Alternatively we could give a function for when to terminate the time evolution.</p><h2 id="Data-collection"><a class="docs-heading-anchor" href="#Data-collection">Data collection</a><a id="Data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection" title="Permalink"></a></h2><p>Data collection also works almost identically to <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>.</p><p>Here we will simply collect the number of each agent type.</p><pre><code class="language-julia hljs">adata = [(a -&gt; a isa X, count) for X in (Rock, Paper, Scissors)]

run!(model, 10.0; adata, when = 0.2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(<span class="sgr1">51×4 DataFrame
 Row │ step     count_#17_X=Main ⋯
     │<span class="sgr90"> Float64  Int64                                                          ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │     1.0                                                                 ⋯
   2 │     1.2
   3 │     1.4
   4 │     1.6
   5 │     1.8                                                                 ⋯
   6 │     2.0
   7 │     2.2
   8 │     2.4
  ⋮  │    ⋮                                      ⋮                             ⋱
  45 │     9.8                                                                 ⋯
  46 │    10.0
  47 │    10.2
  48 │    10.4
  49 │    10.6                                                                 ⋯
  50 │    10.8
  51 │    11.0
</span><span class="sgr36">                                                   3 columns and 36 rows omitted, 0×0 DataFrame)</span></span></code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 8 March 2024 12:37">Friday 8 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
