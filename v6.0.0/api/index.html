<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Agents.jl</title><meta name="title" content="API · Agents.jl"/><meta property="og:title" content="API · Agents.jl"/><meta property="twitter:title" content="API · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/flock/">Flocking model</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../examples/rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../examples/">More Examples for Agents.jl</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#ABM_Implementations"><span>AgentBasedModel</span></a></li><li><a class="tocitem" href="#Agent-types"><span>Agent types</span></a></li><li><a class="tocitem" href="#Agent/model-retrieval-and-access"><span>Agent/model retrieval and access</span></a></li><li><a class="tocitem" href="#[Available-spaces](@ref-available_spaces)"><span>Available spaces</span></a></li><li><a class="tocitem" href="#Adding-agents"><span>Adding agents</span></a></li><li><a class="tocitem" href="#Moving-agents"><span>Moving agents</span></a></li><li><a class="tocitem" href="#Removing-agents"><span>Removing agents</span></a></li><li><a class="tocitem" href="#Space-utility-functions"><span>Space utility functions</span></a></li><li><a class="tocitem" href="#Discrete-space-exclusives"><span>Discrete space exclusives</span></a></li><li><a class="tocitem" href="#GraphSpace-exclusives"><span><code>GraphSpace</code> exclusives</span></a></li><li><a class="tocitem" href="#ContinuousSpace-exclusives"><span><code>ContinuousSpace</code> exclusives</span></a></li><li><a class="tocitem" href="#OpenStreetMapSpace-exclusives"><span><code>OpenStreetMapSpace</code> exclusives</span></a></li><li><a class="tocitem" href="#Nearby-Agents"><span>Nearby Agents</span></a></li><li><a class="tocitem" href="#A-note-on-iteration"><span>A note on iteration</span></a></li><li><a class="tocitem" href="#Higher-order-interactions"><span>Higher-order interactions</span></a></li><li><a class="tocitem" href="#Data-collection-and-analysis"><span>Data collection and analysis</span></a></li><li><a class="tocitem" href="#Schedulers"><span>Schedulers</span></a></li><li><a class="tocitem" href="#Path-finding"><span>Path-finding</span></a></li><li><a class="tocitem" href="#Save,-Load,-Checkpoints"><span>Save, Load, Checkpoints</span></a></li><li><a class="tocitem" href="#Visualizations"><span>Visualizations</span></a></li></ul></li><li><a class="tocitem" href="../examples/agents_visualizations/">Plotting and Interactivity</a></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../examples/celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The API of Agents.jl is defined on top of the fundamental structures <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, <a href="@ref Space">Space</a>, <a href="#Agents.AbstractAgent"><code>AbstractAgent</code></a> which are described in the <a href="../tutorial/#Tutorial">Tutorial</a> page. In this page we list the remaining API functions, which constitute the bulk of Agents.jl functionality.</p><h2 id="ABM_Implementations"><a class="docs-heading-anchor" href="#ABM_Implementations">AgentBasedModel</a><a id="ABM_Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#ABM_Implementations" title="Permalink"></a></h2><ul><li><a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a></li><li><a href="#Agents.StandardABM"><code>StandardABM</code></a></li><li><a href="#Agents.EventQueueABM"><code>EventQueueABM</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AgentBasedModel</code></pre><p><code>AgentBasedModel</code> is the abstract supertype encompassing models in Agents.jl. All models are some concrete implementation of <code>AgentBasedModel</code> and follow its interface (see below). <code>ABM</code> is an alias to <code>AgentBasedModel</code>.</p><p><strong>Available concrete implementations</strong></p><ul><li><a href="#Agents.StandardABM"><code>StandardABM</code></a></li><li><a href="#Agents.EventQueueABM"><code>EventQueueABM</code></a></li></ul><p>It is also straightforward to create your own versions of <code>AgentBasedModel</code>, see <a href="@ref make_new_model">the corresponding entry in the developer documentation</a>.</p><p><strong>Interface of <code>AgentBasedModel</code></strong></p><ul><li><code>model[id]</code> returns the agent with given <code>id</code>.</li><li><code>abmproperties(model)</code> returns the <code>properties</code> container storing model-level properties.</li><li><code>model.property</code>:  If the model <code>properties</code> is a dictionary with key type <code>Symbol</code>, or if it is a composite type (<code>struct</code>), then the syntax <code>model.property</code> will return the model property with key <code>:property</code>.</li><li><code>abmtime(model)</code> will return the current time of the model. All models start from time 0 and time is incremented as the model is <a href="@ref"><code>step!</code></a>-ped.</li><li><code>abmrng(model)</code> will return the random number generator of the model. It is strongly recommended to give <code>abmrng(model)</code> to all calls to <code>rand</code> and similar functions, so that reproducibility can be established in your modelling workflow.</li><li><code>allids(model)/allagents(model)</code> returns an iterator over all IDs/agents in the model.</li><li><code>hasid(model, id)</code> returns <code>true</code> if the model has an agent with given <code>id</code>.</li></ul><p><code>AgentBasedModel</code> defines an extendable interface composed of the above syntax as well as a few more additional functions described in the Developer&#39;s Docs. Following this interface you can implement new variants of an <code>AgentBasedModel</code>. The interface allows instances of <code>AgentBasedModel</code> to be used with any of the <a href="#API">API</a>. For example, functions such as <a href="#Agents.random_agent"><code>random_agent</code></a>, <a href="#Agents.move_agent!"><code>move_agent!</code></a> or <a href="@ref"><code>add_agent</code></a> do not need to be implemented manually but work out of the box provided the <code>AgentBasedModel</code> interface is followed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L30-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.StandardABM" href="#Agents.StandardABM"><code>Agents.StandardABM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StandardABM &lt;: AgentBasedModel</code></pre><p>A concrete implementation of an <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, which is also the most commonly used in agent based modelling studies. It operates in discrete time. As input, it requires at least one, or at most two functions: an agent stepping function and a model stepping function. At each discrete step of the simulation, the agent stepping function is applied once to all scheduled agents, and the model stepping function is applied once to the model.</p><p>See also <a href="#Agents.EventQueueABM"><code>EventQueueABM</code></a> for a continuous time variant.</p><p>To construct a <code>StandardABM</code> use the syntax:</p><pre><code class="nohighlight hljs">StandardABM(AgentType(s) [, space]; properties, agent_step!, model_step!, kwargs...)</code></pre><p>The model expects agents of type <code>AgentType(s)</code> living in the given <code>space</code>. <code>AgentType(s)</code> is the result of <a href="#Agents.@agent"><code>@agent</code></a>, <a href="#Agents.@multiagent"><code>@multiagent</code></a> or a <code>Union</code> of agent types.</p><p><code>space</code> is a subtype of <code>AbstractSpace</code>, see <a href="@ref Space">Space</a> for all available spaces. If it is omitted then all agents are virtually in one position and there is no spatial structure. Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.</p><p>The evolution rules are functions given to the keywords <code>agent_step!</code>, <code>model_step!</code>.</p><p><strong>Keywords</strong></p><ul><li><code>agent_step!</code>: the optional agent stepping function that must be in the form <code>agent_step!(agent, model)</code> and is called for each scheduled <code>agent</code>.</li><li><code>model_step!</code>: the optional model stepping function that must be in the form <code>model_step!(model)</code>. At least one of <code>agent_step!</code> or <code>model_step!</code> must be given. For complicated models, it could be more suitable to use only <code>model_step!</code> to evolve the model, see below the &quot;advanced stepping&quot; example.</li><li><code>container = Dict</code>: the type of container the agents are stored at. Use <code>Vector</code> if no agents are removed during the simulation. This allows storing agents more efficiently, yielding faster retrieval and iteration over agents. Use <code>Dict</code> if agents are expected to be removed during the simulation.</li><li><code>properties = nothing</code>: additional model-level properties that the user may include in the model. <code>properties</code> can be an arbitrary container of data, however it is most typically a <code>Dict</code> with <code>Symbol</code> keys, or a composite type (<code>struct</code>).</li><li><code>scheduler = Schedulers.fastest</code>: is the scheduler that decides the (default) activation order of the agents. See the <a href="#Schedulers">scheduler API</a> for more options. By default all agents are activated once per step in the fastest sequence possible. <code>scheduler</code> is completely ignored if no <code>agent_step!</code> function is given, as it is assumed that in this case the user takes control of scheduling, e.g., as in the &quot;advanced stepping&quot; example below.</li><li><code>rng = Random.default_rng()</code>: the random number generator stored and used by the model in all calls to random functions. Accepts any subtype of <code>AbstractRNG</code>.</li><li><code>agents_first::Bool = true</code>: whether to schedule and activate agents first and then call the <code>model_step!</code> function, or vice versa. Ignored if no <code>agent_step!</code> is given.</li><li><code>warn=true</code>: some type tests for <code>AgentType(s)</code> are done, and by default warnings are thrown when appropriate.</li></ul><p><strong>Advanced stepping</strong></p><p>Some advanced models may require special handling for scheduling, or may need to schedule agents several times and act on different subsets of agents with different functions during a single simulation step. In such a scenario, it is more sensible to provide only a model stepping function, where all the dynamics is contained within.</p><p>Note that if you do not use the automated <code>agent_step!</code> option, you need to manually check for removed agents during evolution, using the <a href="#Agents.hasid"><code>hasid</code></a> function.</p><p>Here is an example:</p><pre><code class="language-julia hljs">function complex_model_step!(model)
    # tip: these schedulers should be defined as properties of the model
    scheduler1 = Schedulers.Randomly()
    scheduler2 = user_defined_function_with_model_as_input
    for id in scheduler1(model)
        agent_step1!(model[id], model)
    end
    intermediate_model_action!(model)
    for id in scheduler2(model)
        # here `agent_step2!` may delete agents, so we check for it manually
        hasid(model, id) || continue
        agent_step2!(model[id], model)
    end
    if model.step_counter % 100 == 0
        model_action_every_100_steps!(model)
    end
    final_model_action!(model)
    return
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_standard.jl#L38-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.EventQueueABM" href="#Agents.EventQueueABM"><code>Agents.EventQueueABM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EventQueueABM &lt;: AgentBasedModel</code></pre><p>A concrete implementation of an <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> which operates in continuous time, in contrast with the discrete time nature of <a href="#Agents.StandardABM"><code>StandardABM</code></a>.</p><p>This is still experimental which means that it is subject to breaking changes in the future. Also, while all the core functionalities have been implemented, this model type  has some more limited features than <code>StandardABM</code>: in particular, visualizations and  IO functionalities are incomplete.</p><p>Here is a summary of how the time evolution of this model works:</p><p>A list of possible events that can be created is provided to the model. The events have four pieces of information:</p><ol><li>The action that they perform once triggered. The action is a generic Julia function <code>action!(agent, model)</code> that will act on the agent corresponding to the event. Similarly with <code>agent_step!</code> for <a href="#Agents.StandardABM"><code>StandardABM</code></a>, this function may do anything and utilize any function from the Agents.jl <a href="#API">API</a> or the entire Julia ecosystem. The <code>action!</code> function may spawn new events by using the automatic or the manual of the <a href="@ref"><code>add_event!</code></a> function, the default behavior is to generate new events  automatically.</li><li>The propensity of the event. A propensity is a concept similar to a probability mass. When automatically generating a new event for an agent, first all applicable events for that agent are collected. Then, their propensities are calculated. The event generated then is selected randomly by weighting each possible event by its propensity.</li><li>The agent type(s) the event applies to. By default it applies to all types.</li><li>The timing of the event, i.e., when should it be triggered once it is generated. By default this is an exponentially distributed random variable divided by the propensity of the event. I.e., it follows a Poisson process with the propensity as the &quot;rate&quot;. The timings of the events therefore establish the natural timescales of the system.</li></ol><p>Events are scheduled in a temporally ordered queue, and once the model evolution time reaches the event time, the event is &quot;triggered&quot;. This means that first the event action is performed on its corresponding agent. By default, once an event has finished its action, a new event is generated for the same agent (if the agent still exists), chosen randomly based on the propensities as discussed above. Then a time for the new event is generated and the new event is added back to the queue. In this way, an event always generates a new event after it has finished its action (by default; can be overwritten).</p><p><code>EventQueueABM</code> is a generalization of &quot;Gillespie&quot;-like simulations, offering more power and flexibility than a standard Gillespie simulation, while also allowing &quot;Gillespie&quot;-like configuration with the default settings.</p><p>Here is how to construct an <code>EventQueueABM</code>:</p><pre><code class="nohighlight hljs">EventQueueABM(AgentTypes, events [, space]; kwargs...)</code></pre><p>Create an instance of an <a href="#Agents.EventQueueABM"><code>EventQueueABM</code></a>. <code>AgentTypes, space</code> are exactly as in <a href="#Agents.StandardABM"><code>StandardABM</code></a>. <code>events</code> is a container (typically a tuple) of instances of <a href="@ref"><code>AgentEvent</code></a>, which are the events that are scheduled and then affect agents. The key type of <code>events</code> is also what is given to <a href="@ref"><code>add_event!</code></a>, hence, <code>events</code> can be e.g., a dictionary with string keys so that it is easier to reference events in <a href="@ref"><code>add_event!</code></a>.</p><p>By default, each time a new agent is added to the model via <a href="#Agents.add_agent!"><code>add_agent!</code></a>, a new event is generated based on the pool of possible events that can affect the agent. In this way the simulation can immediatelly start once agents have been added to the model. You can disable this behavior with a keyword. In this case, you need to manually use the function <a href="@ref"><code>add_event!</code></a> to add events to the queue so that the model can be evolved in time. (you can always use this function regardless of the default event scheduling behavior)</p><p><strong>Keywords</strong></p><ul><li><code>container, properties, rng, warn</code>: same as in <a href="#Agents.StandardABM"><code>StandardABM</code></a>.</li><li><code>autogenerate_on_add::Bool = true</code>: whether to automatically generate a new event for an agent when the agent is added to the model.</li><li><code>autogenerate_after_action::Bool = true</code>: whether to automatically generate a new event for an agent after an event affected said agent has been triggered.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_event_queue.jl#L59-L134">source</a></section></article><h2 id="Agent-types"><a class="docs-heading-anchor" href="#Agent-types">Agent types</a><a id="Agent-types-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.@agent" href="#Agents.@agent"><code>Agents.@agent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@agent struct YourAgentType{X}(AgentTypeToInherit) [&lt;: OptionalSupertype]
    extra_property::X
    other_extra_property_with_default::Bool = true
    const other_extra_const_property::Int
    # etc...
end</code></pre><p>Define an agent struct which includes all fields that <code>AgentTypeToInherit</code> has, as well as any additional ones the user may provide. The macro supports all syntaxes that the standard Julia <code>mutable struct</code> command allows for, such as <code>const</code> field declaration or default values for some fields. Additionally, the resulting type will always have a keyword constructor defined for it (using <code>@kwdef</code>). See below for examples and see also <a href="#Agents.@multiagent"><code>@multiagent</code></a>.</p><p>Using <code>@agent</code> is the recommended way to create agent types for Agents.jl.</p><p>Structs created with <code>@agent</code> by default subtype <code>AbstractAgent</code>. They cannot subtype each other, as all structs created from <code>@agent</code> are concrete types and <code>AgentTypeToInherit</code> itself is also concrete (only concrete types have fields). If you want <code>YourAgentType</code> to subtype something other than <code>AbstractAgent</code>, use the optional argument <code>OptionalSupertype</code> (which itself must then subtype <code>AbstractAgent</code>).</p><p><strong>Usage</strong></p><p>The macro <code>@agent</code> has two primary uses:</p><ol><li>To include the mandatory fields for a particular space in your agent struct. In this case you would use one of the minimal agent types as <code>AnotherAgentType</code>.</li><li>A convenient way to include fields from another, already existing struct, thereby establishing a toolkit for &quot;type inheritance&quot; in Julia.</li></ol><p>The existing minimal agent types are:</p><ul><li><a href="#Agents.NoSpaceAgent"><code>NoSpaceAgent</code></a></li><li><a href="#Agents.GraphAgent"><code>GraphAgent</code></a></li><li><a href="#Agents.GridAgent"><code>GridAgent</code></a></li><li><a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a></li><li><a href="#Agents.OSMAgent"><code>OSMAgent</code></a></li></ul><p>which describe which fields they will contribute to the new type.</p><p><strong>Examples</strong></p><p><strong>Example without optional hierarchy</strong></p><p>Using</p><pre><code class="language-julia hljs">@agent struct Person{T}(GridAgent{2})
    age::Int
    moneyz::T
end</code></pre><p>will create an agent appropriate for using with 2-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a></p><pre><code class="language-julia hljs">mutable struct Person{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    const age::Int
    moneyz::T
end</code></pre><p>Notice that you can also use default values for some fields, in this case you will need to specify the field names with the non-default values</p><pre><code class="language-julia hljs">@agent struct Person2{T}(GridAgent{2})
    age::Int = 30
    moneyz::T
end
# default age value
Person2(id = 1, pos = (1, 1), moneyz = 2000)
# new age value
Person2(1, (1, 1), 40, 2000)</code></pre><p><strong>Example with optional hierarchy</strong></p><p>An alternative way to make the above structs, that also establishes a user-specific subtyping hierarchy would be to do:</p><pre><code class="language-julia hljs">abstract type AbstractHuman &lt;: AbstractAgent end

@agent struct Worker(GridAgent{2}) &lt;: AbstractHuman
    age::Int
    moneyz::Float64
end

@agent struct Fisher(Worker) &lt;: AbstractHuman
    fish_per_day::Float64
end</code></pre><p>which would now make both <code>Fisher</code> and <code>Worker</code> subtypes of <code>AbstractHuman</code>.</p><pre><code class="language-julia hljs">julia&gt; supertypes(Fisher)
(Fisher, AbstractHuman, AbstractAgent, Any)

julia&gt; supertypes(Worker)
(Worker, AbstractHuman, AbstractAgent, Any)</code></pre><p>Note that <code>Fisher</code> will <em>not</em> be a subtype of <code>Worker</code> although <code>Fisher</code> has inherited the fields from <code>Worker</code>.</p><p><strong>Example highlighting problems with parametric types</strong></p><p>Notice that in Julia parametric types are union types. Hence, the following cannot be used:</p><pre><code class="language-julia hljs">@agent struct Dummy{T}(GridAgent{2})
    moneyz::T
end

@agent struct Fisherino{T}(Dummy{T})
    fish_per_day::T
end</code></pre><p>You will get an error in the definition of <code>Fisherino</code>, because the fields of <code>Dummy{T}</code> cannot be obtained, because it is a union type. Same with using <code>Dummy</code>. You can only use <code>Dummy{Float64}</code>.</p><p><strong>Example with common dispatch and no subtyping</strong></p><p>It may be that you do not even need to create a subtyping relation if you want to utilize multiple dispatch. Consider the example:</p><pre><code class="language-julia hljs">@agent struct CommonTraits(GridAgent{2})
    age::Int
    speed::Int
    energy::Int
end</code></pre><p>and then two more structs are made from these traits:</p><pre><code class="language-julia hljs">@agent struct Bird(CommonTraits)
    height::Float64
end

@agent struct Rabbit(CommonTraits)
    underground::Bool
end</code></pre><p>If you wanted a function that dispatches to both <code>Rabbit, Bird</code>, you only have to define:</p><pre><code class="language-julia hljs">Animal = Union{Bird, Rabbit}
f(x::Animal) = ... # uses `CommonTraits` fields</code></pre><p>However, it should also be said, that there is no real reason here to explicitly type-annotate <code>x::Animal</code> in <code>f</code>. Don&#39;t annotate any type. Annotating a type only becomes useful if there are at least two &quot;abstract&quot; groups, like <code>Animal, Person</code>. Then it would make sense to define</p><pre><code class="language-julia hljs">Person = Union{Fisher, Baker}
f(x::Animal) = ... # uses `CommonTraits` fields
f(x::Person) = ... # uses fields that all &quot;persons&quot; have</code></pre><p>Agents.jl has a convenience function <a href="#Agents.add_agent!"><code>add_agent!</code></a> to create and add agents to the model automatically. In the case you want to create some agents by yourself you can use a constructor accepting the model as first argument so that internal fields, such as the <code>id</code>, are set automatically</p><pre><code class="language-julia hljs">model = StandardABM(GridAgent{2}, GridSpace((10,10)))
a = GridAgent{2}(model, (3,4)) # the id is set automatically</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/agents.jl#L40-L197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">YourAgentType &lt;: AbstractAgent</code></pre><p>Agents participating in Agents.jl simulations are instances of user-defined types that are subtypes of <code>AbstractAgent</code>.</p><p>Your agent type(s) <strong>must have</strong> the <code>id::Int</code> field as first field. If any space is used (see <a href="@ref">Available spaces</a>), a <code>pos</code> field of appropriate type is also mandatory. The core model structure, and each space, may also require additional fields that may, or may not, be communicated as part of the public API.</p><p>The <a href="#Agents.@agent"><code>@agent</code></a> macro ensures that all of these constrains are in place and hence it is the <strong>the only supported way to create agent types</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/agents.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.@multiagent" href="#Agents.@multiagent"><code>Agents.@multiagent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@multiagent struct YourAgentType{X,Y}(AgentTypeToInherit) [&lt;: OptionalSupertype]
    @subagent FirstAgentSubType{X}
        first_property::X # shared with second agent
        second_property_with_default::Bool = true
    end
    @subagent SecondAgentSubType{X,Y}
        first_property::X = 3
        third_property::Y
    end
    # etc...
end</code></pre><p>Define multiple agent &quot;subtypes&quot;, which are actually only variants of a unique overarching type <code>YourAgentType</code>. This means that all &quot;subtypes&quot; are conceptual: they are simply convenience functions defined that initialize the common proper type correctly (see examples below for more). Because the &quot;subtypes&quot; are not real Julia <code>Types</code>, you cannot use multiple dispatch on them. You also cannot distinguish them on the basis of <code>typeof</code>, but need to use instead the <code>kindof</code> function.</p><p>See the <a href="../tutorial/#Tutorial">Tutorial</a> or the <a href="../performance_tips/#multi_vs_union">performance comparison versus <code>Union</code> types</a> for why in most cases it is better to use <code>@multiagent</code> than making multiple agent types manually.</p><p>Two different versions of <code>@multiagent</code> can be used by passing either <code>:opt_speed</code> or <code>:opt_memory</code> as the first argument (before the <code>struct</code> keyword). The first optimizes the agents representation for speed, the second does the same for memory, at the cost of a moderate drop in performance. By default it uses <code>:opt_speed</code>.</p><p><strong>Examples</strong></p><p>Let&#39;s say you have this definition:</p><pre><code class="nohighlight hljs">@multiagent :opt_speed struct Animal{T}(GridAgent{2})
    @subagent struct Wolf
        energy::Float64 = 0.5
        ground_speed::Float64
        const fur_color::Symbol
    end
    @subagent struct Hawk{T}
        energy::Float64 = 0.1
        ground_speed::Float64
        flight_speed::T
    end
end</code></pre><p>Then you can create <code>Wolf</code> and <code>Hawk</code> agents normally, like so</p><pre><code class="nohighlight hljs">hawk_1 = Hawk(1, (1, 1), 1.0, 2.0, 3)
hawk_2 = Hawk(; id = 2, pos = (1, 2), ground_speed = 2.3, flight_speed = 2)
wolf_1 = Wolf(3, (2, 2), 2.0, 3.0, :black)
wolf_2 = Wolf(; id = 4, pos = (2, 1), ground_speed = 2.0, fur_color = :white)</code></pre><p>It is important to notice, though, that the <code>Wolf</code> and <code>Hawk</code> types are just conceptual and all agents are actually of type <code>Animal</code> in this case. The way to retrieve the variant of the agent is through the function <code>kindof</code> e.g.</p><pre><code class="nohighlight hljs">kindof(hawk_1) # :Hawk
kindof(wolf_2) # :Wolf</code></pre><p>See the <a href="@ref">rabbit<em>fox</em>hawk</a> example to see how to use this macro in a model.</p><p><strong>Current limitations</strong></p><ul><li>Impossibility to inherit from a compactified agent.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/agents.jl#L233-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MixedStructTypes.kindof" href="#MixedStructTypes.kindof"><code>MixedStructTypes.kindof</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kindof(agent::AbstractAgent) → kind::Symbol</code></pre><p>Return the &quot;kind&quot; (instead of type) of the agent, which is the name given to the agent subtype when it was created with <a href="#Agents.@multiagent"><code>@multiagent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/agents.jl#L411-L416">source</a></section></article><h3 id="Minimal-agent-types"><a class="docs-heading-anchor" href="#Minimal-agent-types">Minimal agent types</a><a id="Minimal-agent-types-1"></a><a class="docs-heading-anchor-permalink" href="#Minimal-agent-types" title="Permalink"></a></h3><p>The <a href="#Agents.@agent"><code>@agent</code></a> macro can be used to define new agent types from the minimal agent types that are listed below:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.NoSpaceAgent" href="#Agents.NoSpaceAgent"><code>Agents.NoSpaceAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoSpaceAgent &lt;: AbstractAgent</code></pre><p>The minimal agent struct for usage with <code>nothing</code> as space (i.e., no space). It has the field <code>id::Int</code>, and potentially other internal fields that are not documented as part of the public API. See also <a href="#Agents.@agent"><code>@agent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/agents.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.GraphAgent" href="#Agents.GraphAgent"><code>Agents.GraphAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphAgent &lt;: AbstractAgent</code></pre><p>The minimal agent struct for usage with <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>. It has an additional <code>pos::Int</code> field. See also <a href="#Agents.@agent"><code>@agent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/graph.jl#L54-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.GridAgent" href="#Agents.GridAgent"><code>Agents.GridAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridAgent{D} &lt;: AbstractAgent</code></pre><p>The minimal agent struct for usage with <code>D</code>-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a>. It has an additional <code>pos::NTuple{D,Int}</code> field. See also <a href="#Agents.@agent"><code>@agent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/grid_general.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.ContinuousAgent" href="#Agents.ContinuousAgent"><code>Agents.ContinuousAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousAgent{D,T} &lt;: AbstractAgent</code></pre><p>The minimal agent struct for usage with <code>D</code>-dimensional <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. It has the additional fields <code>pos::SVector{D,T}, vel::SVector{D,T}</code> where <code>T</code> can be any <code>AbstractFloat</code> type. See also <a href="#Agents.@agent"><code>@agent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSMAgent" href="#Agents.OSMAgent"><code>Agents.OSMAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OSMAgent &lt;: AbstractAgent</code></pre><p>The minimal agent struct for usage with <a href="@ref"><code>OpenStreetMapSpace</code></a>. It has an additional field <code>pos::Tuple{Int,Int,Float64}</code>. See also <a href="#Agents.@agent"><code>@agent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L152-L156">source</a></section></article><h2 id="Agent/model-retrieval-and-access"><a class="docs-heading-anchor" href="#Agent/model-retrieval-and-access">Agent/model retrieval and access</a><a id="Agent/model-retrieval-and-access-1"></a><a class="docs-heading-anchor-permalink" href="#Agent/model-retrieval-and-access" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AgentBasedModel, Integer}" href="#Base.getindex-Tuple{AgentBasedModel, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model[id]
getindex(model::ABM, id::Int)</code></pre><p>Return an agent given its ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getproperty-Tuple{AgentBasedModel, Symbol}" href="#Base.getproperty-Tuple{AgentBasedModel, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">model.prop
getproperty(model::ABM, :prop)</code></pre><p>Return a property with name <code>:prop</code> from the current <code>model</code>, assuming the model <code>properties</code> are either a dictionary with key type <code>Symbol</code> or a Julia struct. For example, if a model has the set of properties <code>Dict(:weight =&gt; 5, :current =&gt; false)</code>, retrieving these values can be obtained via <code>model.weight</code> or <code>model.current</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L116-L124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_id" href="#Agents.random_id"><code>Agents.random_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_id(model) → id</code></pre><p>Return a random id from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_agent" href="#Agents.random_agent"><code>Agents.random_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_agent(model) → agent</code></pre><p>Return a random agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L39-L43">source</a></section><section><div><pre><code class="language-julia hljs">random_agent(model, condition; optimistic=true, alloc = false) → agent</code></pre><p>Return a random agent from the model that satisfies <code>condition(agent) == true</code>. The function generates a random permutation of agent IDs and iterates through them. If no agent satisfies the condition, <code>nothing</code> is returned instead.</p><p><strong>Keywords</strong></p><p><code>optimistic = true</code> changes the algorithm used to be non-allocating but potentially more variable in performance. This should be faster if the condition is <code>true</code> for a large proportion of the population (for example if the agents are split into groups).</p><p><code>alloc</code> can be used to employ a different fallback strategy in case the optimistic version doesn&#39;t find any agent satisfying the condition: if the filtering condition is expensive an allocating fallback can be more performant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L46-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.nagents" href="#Agents.nagents"><code>Agents.nagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nagents(model::ABM)</code></pre><p>Return the number of agents in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L26-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.allagents" href="#Agents.allagents"><code>Agents.allagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allagents(model)</code></pre><p>Return an iterator over all agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.allids" href="#Agents.allids"><code>Agents.allids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">allids(model)</code></pre><p>Return an iterator over all agent IDs of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_free_extensions.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.hasid" href="#Agents.hasid"><code>Agents.hasid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">hasid(model, id::Int) → true/false
hasid(model, agent::AbstractAgent) → true/false</code></pre><p>Return <code>true</code> if the <code>model</code> has an agent with given <code>id</code> or has the given <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmproperties" href="#Agents.abmproperties"><code>Agents.abmproperties</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmproperties(model::ABM)</code></pre><p>Return the properties container stored in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L90-L93">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmrng" href="#Agents.abmrng"><code>Agents.abmrng</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmrng(model::ABM)</code></pre><p>Return the random number generator stored in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmscheduler" href="#Agents.abmscheduler"><code>Agents.abmscheduler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmscheduler(model::ABM)</code></pre><p>Return the default scheduler stored in <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmspace" href="#Agents.abmspace"><code>Agents.abmspace</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmspace(model::ABM)</code></pre><p>Return the space instance stored in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L103-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmtime" href="#Agents.abmtime"><code>Agents.abmtime</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmtime(model::ABM)</code></pre><p>Return the current time of the <code>model</code>. All models are initialized at time 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_abstract.jl#L109-L113">source</a></section><section><div><pre><code class="language-julia hljs">abmtime(model::AgentBasedModel)</code></pre><p>Return the current time of the model. All models are initialized at time 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_event_queue.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmevents" href="#Agents.abmevents"><code>Agents.abmevents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmevents(model::EventQueueABM)</code></pre><p>Return all possible events stored in the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/model_event_queue.jl#L190-L194">source</a></section></article><h2 id="[Available-spaces](@ref-available_spaces)"><a class="docs-heading-anchor" href="#[Available-spaces](@ref-available_spaces)"><a href="@ref available_spaces">Available spaces</a></a><a id="[Available-spaces](@ref-available_spaces)-1"></a><a class="docs-heading-anchor-permalink" href="#[Available-spaces](@ref-available_spaces)" title="Permalink"></a></h2><p>Here we list the spaces that are available &quot;out of the box&quot; from Agents.jl. To create your own, see the developer documentation on <a href="@ref make_new_space">creating a new space type</a>.</p><h3 id="Discrete-spaces"><a class="docs-heading-anchor" href="#Discrete-spaces">Discrete spaces</a><a id="Discrete-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.GraphSpace" href="#Agents.GraphSpace"><code>Agents.GraphSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GraphSpace(graph::AbstractGraph)</code></pre><p>Create a <code>GraphSpace</code> instance that is underlined by an arbitrary graph from <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a>. <code>GraphSpace</code> represents a space where each node (i.e. position) of a graph can hold an arbitrary amount of agents, and each agent can move between the nodes of the graph. The position type for this space is <code>Int</code>, use <a href="#Agents.GraphAgent"><code>GraphAgent</code></a> for convenience.</p><p><code>Graphs.nv</code> and <code>Graphs.ne</code> can be used in a model with a <code>GraphSpace</code> to obtain the number of nodes or edges in the graph. The underlying graph can be altered using <a href="#Graphs.SimpleGraphs.add_vertex!"><code>add_vertex!</code></a> and <a href="#Graphs.SimpleGraphs.rem_vertex!"><code>rem_vertex!</code></a>.</p><p>An example using <code>GraphSpace</code> is <a href="../examples/sir/#SIR-model-for-the-spread-of-COVID-19">SIR model for the spread of COVID-19</a>.</p><p>If you want to model social networks, where each agent is equivalent with a node of a graph, you&#39;re better of using <code>nothing</code> as the model space, and using a graph from Graphs.jl directly in the model parameters, as shown in the <a href="../examples/schoolyard/#Social-networks-with-Graphs.jl">Social networks with Graphs.jl</a> integration example.</p><p><strong>Distance specification</strong></p><p>In functions like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>, distance for <code>GraphSpace</code> means the degree of neighbors in the graph (thus distance is always an integer). For example, for <code>r=2</code> includes first and second degree neighbors. For 0 distance, the search occurs only on the origin node.</p><p>In functions like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a> the keyword <code>neighbor_type=:default</code> can be used to select differing neighbors depending on the underlying graph directionality type.</p><ul><li><code>:default</code> returns neighbors of a vertex (position). If graph is directed, this is equivalent to <code>:out</code>. For undirected graphs, all options are equivalent to <code>:out</code>.</li><li><code>:all</code> returns both <code>:in</code> and <code>:out</code> neighbors.</li><li><code>:in</code> returns incoming vertex neighbors.</li><li><code>:out</code> returns outgoing vertex neighbors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/graph.jl#L12-L44">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.GridSpace" href="#Agents.GridSpace"><code>Agents.GridSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridSpace(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)</code></pre><p>Create a <code>GridSpace</code> that has size given by the tuple <code>d</code>, having <code>D ≥ 1</code> dimensions. Optionally decide whether the space will be periodic and what will be the distance metric. The position type for this space is <code>NTuple{D, Int}</code>, use <a href="#Agents.GridAgent"><code>GridAgent</code></a> for convenience. Valid positions have indices in the range <code>1:d[i]</code> for the <code>i</code>-th dimension.</p><p>An example using <code>GridSpace</code> is <a href="@ref">Schelling&#39;s segregation model</a>.</p><p><strong>Distance specification</strong></p><p>The typical terminology when searching neighbors in agent based modelling is &quot;Von Neumann&quot; neighborhood or &quot;Moore&quot; neighborhoods. However, because Agents.jl provides a much more powerful infrastructure for finding neighbors, both in arbitrary dimensions but also of arbitrary neighborhood size, this established terminology is no longer appropriate. Instead, distances that define neighborhoods are specified according to a proper metric space, that is both well defined for any distance, and applicable to any dimensionality.</p><p>The allowed metrics are (and see docs online for a plotted example):</p><ul><li><p><code>:chebyshev</code> metric means that the <code>r</code>-neighborhood of a position are all positions within the hypercube having side length of <code>2*floor(r)</code> and being centered in the origin position. This is similar to &quot;Moore&quot; for <code>r = 1</code> and two dimensions.</p></li><li><p><code>:manhattan</code> metric means that the <code>r</code>-neighborhood of a position are all positions whose cartesian indices have Manhattan distance <code>≤ r</code> from the cartesian index of the origin position. This similar to &quot;Von Neumann&quot; for <code>r = 1</code> and two dimensions.</p></li><li><p><code>:euclidean</code> metric means that the <code>r</code>-neighborhood of a position are all positions whose cartesian indices have Euclidean distance <code>≤ r</code> from the cartesian index of the origin position.</p></li></ul><p><strong>Advanced dimension-dependent distances in Chebyshev metric</strong></p><p>If <code>metric = :chebyshev</code>, some advanced specification of distances is allowed when providing <code>r</code> to functions like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p><ol><li><code>r::NTuple{D,Int}</code> such as <code>r = (5, 2)</code>. This would mean a distance of 5 in the first dimension and 2 in the second. This can be useful when different coordinates in the space need to be searched with different ranges, e.g., if the space corresponds to a full building, with the third dimension the floor number.</li><li><code>r::Vector{Tuple{Int,UnitRange{Int}}}</code> such as <code>r = [(1, -1:1), (3, 1:2)]</code>. This allows explicitly specifying the difference between position indices in each specified dimension. The example <code>r = [(1, -1:1), (3, 1:2)]</code> when given to e.g., <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>, would search dimension 1 one step of either side of the current position (as well as the current position since <code>0 ∈ -1:1</code>) and would search the third dimension one and two positions above current. Unspecified dimensions (like the second in this example) are searched throughout all their possible ranges.</li></ol><p>See the <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/battle/">Battle Royale</a> example for usage of this advanced specification of dimension-dependent distances where one dimension is used as a categorical one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/grid_multi.jl#L15-L67">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.GridSpaceSingle" href="#Agents.GridSpaceSingle"><code>Agents.GridSpaceSingle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GridSpaceSingle(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)</code></pre><p>This is a specialized version of <a href="#Agents.GridSpace"><code>GridSpace</code></a> that allows only one agent per position, and utilizes this knowledge to offer significant performance gains versus <a href="#Agents.GridSpace"><code>GridSpace</code></a>.</p><p>This space <strong>reserves agent ID = 0 for internal usage.</strong> Agents should be initialized with non-zero IDs, either positive or negative. This is not checked internally.</p><p>All arguments and keywords behave exactly as in <a href="#Agents.GridSpace"><code>GridSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/grid_single.jl#L21-L32">source</a></section></article><p>Here is a specification of how the metrics look like:</p><img src="edf65748.png" alt="Example block output"/><h3 id="Continuous-spaces"><a class="docs-heading-anchor" href="#Continuous-spaces">Continuous spaces</a><a id="Continuous-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.ContinuousSpace" href="#Agents.ContinuousSpace"><code>Agents.ContinuousSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousSpace(extent::NTuple{D, &lt;:Real}; kwargs...)</code></pre><p>Create a <code>D</code>-dimensional <code>ContinuousSpace</code> in range 0 to (but not including) <code>extent</code>. Your agent positions (field <code>pos</code>) must be of type <code>SVector{D, &lt;:Real}</code>, and it is strongly recommend that agents also have a field <code>vel::SVector{D, &lt;:Real}</code> to use in conjunction with <a href="#Agents.move_agent!"><code>move_agent!</code></a>. Use <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a> for convenience.</p><p><code>ContinuousSpace</code> is a representation of agent dynamics on a continuous medium where agent position, orientation, and speed, are true floats. In addition, support is provided for representing spatial properties in a model that contains a <code>ContinuousSpace</code>. Spatial properties (which typically are contained in the model properties) can either be functions of the position vector, <code>f(pos) = value</code>, or <code>AbstractArrays</code>, representing discretizations of spatial data that may not be available in analytic form. In the latter case, the position is automatically mapped into the discretization represented by the array. Use <a href="#Agents.get_spatial_property"><code>get_spatial_property</code></a> to access spatial properties in conjunction with <code>ContinuousSpace</code>.</p><p>See also <a href="@ref">Continuous space exclusives</a> on the online docs for more functionality. An example using continuous space is the <a href="../examples/flock/#Flocking-model">Flocking model</a>.</p><p><strong>Distance specification</strong></p><p>Distances specified by <code>r</code> in functions like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a> are always based on the Euclidean distance between two points in <code>ContinuousSpace</code>.</p><p>In <code>ContinuousSpace</code> <code>nearby_*</code> searches are accelerated using a grid system, see discussion around the keyword <code>spacing</code> below. <a href="#Agents.nearby_ids"><code>nearby_ids</code></a> is not an exact search, but can be a possible over-estimation, including agent IDs whose distance slightly exceeds <code>r</code> with &quot;slightly&quot; being as much as <code>spacing</code>. If you want exact searches use the slower <a href="#Agents.nearby_ids_exact"><code>nearby_ids_exact</code></a>.</p><p><strong>Keywords</strong></p><ul><li><code>periodic = true</code>: Whether the space is periodic or not. If set to <code>false</code> an error will occur if an agent&#39;s position exceeds the boundary.</li><li><code>spacing::Real = minimum(extent)/20</code>: Configures an internal compartment spacing that is used to accelerate nearest neighbor searches like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>. The compartments are actually a full instance of <code>GridSpace</code> in which agents move. All dimensions in <code>extent</code> must be completely divisible by <code>spacing</code>. There is no best choice for the value of <code>spacing</code> and if you need optimal performance it&#39;s advised to set up a benchmark over a range of choices. The finer the spacing, the faster and more accurate the inexact version of <code>nearby_ids</code> becomes. However, a finer spacing also means slower <code>move_agent!</code>, as agents change compartments more often.</li><li><code>update_vel!</code>: A <strong>function</strong>, <code>update_vel!(agent, model)</code> that updates the agent&#39;s velocity <strong>before</strong> the agent has been moved, see <a href="#Agents.move_agent!"><code>move_agent!</code></a>. You can of course change the agents&#39; velocities during the agent interaction, the <code>update_vel!</code> functionality targets spatial force fields acting on the agents individually (e.g. some magnetic field). If you use <code>update_vel!</code>, the agent type must have a field <code>vel::SVector{D, &lt;:Real}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L40-L88">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OpenStreetMapSpace" href="#Agents.OpenStreetMapSpace"><code>Agents.OpenStreetMapSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OpenStreetMapSpace(path::AbstractString; kwargs...)</code></pre><p>Create a space residing on the Open Street Map (OSM) file provided via <code>path</code>. This space represents the underlying map as a <em>continuous</em> entity choosing accuracy over performance. The map is represented as a graph, consisting of nodes connected by edges. Nodes are not necessarily intersections, and there may be multiple nodes on a road joining two intersections. Agents move along the available roads of the map using routing, see below.</p><p>The functionality related to Open Street Map spaces is in the submodule <code>OSM</code>. An example of its usage can be found in <a href="../examples/zombies/#Zombie-Outbreak-in-a-City">Zombie Outbreak in a City</a>.</p><p><strong>The <code>OSMAgent</code></strong></p><p>The base properties for an agent residing on an <code>OSMSpace</code> are as follows:</p><pre><code class="language-julia hljs">mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int,Int,Float64}
end</code></pre><p>Current <code>pos</code>ition tuple is represented as (first intersection index, second intersection index, distance travelled). The indices are the indices of the nodes of the graph that internally represents the map. Functions like <a href="#Agents.OSM.nearest_node"><code>OSM.nearest_node</code></a> or <a href="#Agents.OSM.nearest_road"><code>OSM.nearest_road</code></a> can help find those node indices from a (lon, lat) real world coordinate. The distance travelled is in the units of <code>weight_type</code>. This ensures that the map is a <em>continuous</em> kind of space, as an agent can truly be at any possible point on an existing road.</p><p>Use <a href="@ref"><code>OSMAgent</code></a> for convenience.</p><p><strong>Obtaining map files</strong></p><p>Maps files can be downloaded using the functions provided by <a href="https://github.com/DeloitteDigitalAPAC/LightOSM.jl">LightOSM.jl</a>. Agents.jl also re-exports <a href="#LightOSM.download_osm_network"><code>OSM.download_osm_network</code></a>, the main function used to download maps and provides a test map in <a href="#Agents.OSM.test_map"><code>OSM.test_map</code></a>. An example usage to download the map of London to <code>&quot;london.json&quot;</code>:</p><pre><code class="language-julia hljs">OSM.download_osm_network(
    :place_name;
    place_name = &quot;London&quot;,
    save_to_file_location = &quot;london.json&quot;
)</code></pre><p>The length of an edge between two nodes is specified in the units of the map&#39;s <code>weight_type</code> as listed in the documentation for <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/types/#LightOSM.OSMGraph"><code>LightOSM.OSMGraph</code></a>. The possible <code>weight_type</code>s are:</p><ul><li><code>:distance</code>: The distance in kilometers of an edge</li><li><code>:time</code>: The time in hours to travel along an edge at the maximum speed allowed on that road</li><li><code>:lane_efficiency</code>: Time scaled by number of lanes</li></ul><p>The default <code>weight_type</code> used is <code>:distance</code>.</p><p>All <code>kwargs</code> are propagated to <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/create_graph/#LightOSM.graph_from_file"><code>LightOSM.graph_from_file</code></a>.</p><p><strong>Routing with OSM</strong></p><p>You can use <a href="#Agents.plan_route!"><code>plan_route!</code></a> or <a href="#Agents.OSM.plan_random_route!"><code>plan_random_route!</code></a>. To actually move along a planned route use <a href="#Agents.move_along_route!"><code>move_along_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L67-L130">source</a></section></article><h2 id="Adding-agents"><a class="docs-heading-anchor" href="#Adding-agents">Adding agents</a><a id="Adding-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.add_agent!" href="#Agents.add_agent!"><code>Agents.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_agent!(agent::AbstractAgent [, pos], model::ABM) → agent</code></pre><p>Add the <code>agent</code> to the model in the given position. If <code>pos</code> is not given, the <code>agent</code> is added to a random position. The <code>agent</code>&#39;s position is always updated to match <code>position</code>, and therefore for <code>add_agent!</code> the position of the <code>agent</code> is meaningless. Use <a href="#Agents.add_agent_own_pos!"><code>add_agent_own_pos!</code></a> to use the <code>agent</code>&#39;s position. The type of <code>pos</code> must match the underlying space position type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L205-L214">source</a></section><section><div><pre><code class="language-julia hljs">add_agent!([pos,] model::ABM, args...) → newagent
add_agent!([pos,] model::ABM; kwargs...) → newagent</code></pre><p>Use one of these two versions to create and add a new agent to the model using the constructor of the agent type of the model. Optionally provide a position to add the agent to as <em>first argument</em>, which must match the space position type.</p><p>This function takes care of setting the agent id <em>and</em> position. The extra provided <code>args...</code> or <code>kwargs...</code> are propagated to other fields of the agent constructor (see example below). Mixing <code>args...</code> and <code>kwargs...</code> is not possible, only one of the two can be used to set the fields.</p><pre><code class="nohighlight hljs">add_agent!([pos,] A::Type, model::ABM, args...) → newagent
add_agent!([pos,] A::Type, model::ABM; kwargs...) → newagent</code></pre><p>Use one of these two versions for mixed agent models, with <code>A</code> the agent type you wish to create, because it is otherwise not possible to deduce a constructor for <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Agents
@agent struct Agent(GraphAgent)
    w::Float64 = 0.1
    k::Bool = false
end
model = StandardABM(Agent, GraphSpace(complete_digraph(5)))

add_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally
add_agent!(model, 0.5, true) # correct: w becomes 0.5
add_agent!(5, model, 0.5, true) # add at position 5, w becomes 0.5
add_agent!(model; w = 0.5) # use keywords: w becomes 0.5, k becomes false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L225-L259">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.add_agent_own_pos!" href="#Agents.add_agent_own_pos!"><code>Agents.add_agent_own_pos!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_agent_own_pos!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Add the agent to the <code>model</code> at the agent&#39;s own position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L194-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.replicate!" href="#Agents.replicate!"><code>Agents.replicate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replicate!(agent, model; kwargs...)</code></pre><p>Add a new agent to the <code>model</code> copying the values of the fields of the given agent. With the <code>kwargs</code> it is possible to override the values by specifying new ones for some fields (except for the <code>id</code> field which is set to a new one automatically). Return the new agent instance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Agents
@agent struct A(GridAgent{2})
    k::Float64
    w::Float64
end

model = StandardABM(A, GridSpace((5, 5)))
a = A(1, (2, 2), 0.5, 0.5)
b = replicate!(a, model; w = 0.8)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/sample.jl#L77-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_position" href="#Agents.random_position"><code>Agents.random_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_position(model) → pos</code></pre><p>Return a random position in the model&#39;s space (always with appropriate Type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L34-L38">source</a></section></article><h2 id="Moving-agents"><a class="docs-heading-anchor" href="#Moving-agents">Moving agents</a><a id="Moving-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.move_agent!" href="#Agents.move_agent!"><code>Agents.move_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_agent!(agent [, pos], model::ABM) → agent</code></pre><p>Move agent to the given position, or to a random one if a position is not given. <code>pos</code> must have the appropriate position type depending on the space type.</p><p>The agent&#39;s position is updated to match <code>pos</code> after the move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L119-L126">source</a></section><section><div><pre><code class="language-julia hljs">move_agent!(agent, model::ABM{&lt;:ContinuousSpace}, dt::Real)</code></pre><p>Propagate the agent forwards one step according to its velocity, <em>after</em> updating the agent&#39;s velocity (if configured using <code>update_vel!</code>, see <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>).</p><p>For this continuous space version of <code>move_agent!</code>, the &quot;time evolution&quot; is a trivial Euler scheme with <code>dt</code> the step size, i.e. the agent position is updated as <code>agent.pos += agent.vel * dt</code>.</p><p>Unlike <code>move_agent!(agent, [pos,] model)</code>, this function respects the space size. For non-periodic spaces, agents will walk up to, but not reach, the space extent. For periodic spaces movement properly wraps around the extent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L162-L175">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.walk!" href="#Agents.walk!"><code>Agents.walk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">walk!(agent, direction::NTuple, model::ABM{&lt;:AbstractGridSpace}; ifempty = true)
walk!(agent, direction::SVector, model::ABM{&lt;:ContinuousSpace})</code></pre><p>Move agent in the given <code>direction</code> respecting periodic boundary conditions. For non-periodic spaces, agents will walk to, but not exceed the boundary value. Available for both <code>AbstractGridSpace</code> and <code>ContinuousSpace</code>s.</p><p>The type of <code>direction</code> must be the same as the space position. <code>AbstractGridSpace</code> asks for <code>Int</code> tuples, and <code>ContinuousSpace</code> for <code>Float64</code> static vectors, describing the walk distance in each direction. <code>direction = (2, -3)</code> is an example of a valid direction on a <code>AbstractGridSpace</code>, which moves the agent to the right 2 positions and down 3 positions. Agent velocity is ignored for this operation in <code>ContinuousSpace</code>.</p><p><strong>Keywords</strong></p><ul><li><code>ifempty</code> will check that the target position is unoccupied and only move if that&#39;s true. Available only on <code>AbstractGridSpace</code>.</li></ul><p>Example usage in <a href="     https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/battle/">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/walk.jl#L11-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.randomwalk!" href="#Agents.randomwalk!"><code>Agents.randomwalk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">randomwalk!(agent, model::ABM{&lt;:AbstractGridSpace}, r::Real = 1; kwargs...)</code></pre><p>Move <code>agent</code> for a distance <code>r</code> in a random direction respecting boundary conditions and space metric. For Chebyshev and Manhattan metric, the step size <code>r</code> is rounded to  <code>floor(Int,r)</code>; for Euclidean metric in a GridSpace, random walks are ill defined  and hence not supported.</p><p>For example, for <code>Chebyshev</code> metric and <code>r=1</code>, this will move the agent with equal probability to any of the 8 surrounding cells. For Manhattan metric, it will move to any of the 4 surrounding cells.</p><p><strong>Keywords</strong></p><ul><li><code>ifempty</code> will check that the target position is unoccupied and only move if that&#39;s true. So if <code>ifempty</code> is true, this can result in the agent not moving even if there are available  positions. By default this is true, set it to false if different agents can occupy the same  position. In a <code>GridSpaceSingle</code>, agents cannot overlap anyways and this keyword has no effect.</li><li><code>force_motion</code> has an effect only if <code>ifempty</code> is true or the space is a <code>GridSpaceSingle</code>.  If set to true, the search for the random walk will be done only on the empty positions,  so in this case the agent will always move if there is at least one empty position to choose from.  By default this is false.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/walk.jl#L132-L153">source</a></section><section><div><pre><code class="language-julia hljs">randomwalk!(agent, model::ABM{&lt;:ContinuousSpace} [, r];
    [polar=Uniform(-π,π), azimuthal=Arccos(-1,1)]
)</code></pre><p>Re-orient and move <code>agent</code> for a distance <code>r</code> in a random direction respecting space boundary conditions. By default <code>r = norm(agent.vel)</code>.</p><p>The <code>ContinuousSpace</code> version is slightly different than the grid space. Here, the agent&#39;s velocity is updated by the random vector generated for the random walk. </p><p>Uniform/isotropic random walks are supported in any number of dimensions while an angles distribution can be specified for 2D and 3D random walks. In this case, the velocity vector is rotated using random angles given by  the distributions for polar (2D and 3D) and azimuthal (3D only) angles, and  scaled to have measure <code>r</code>. After the re-orientation the agent is moved for  <code>r</code> in the new direction.</p><p>Anything that supports <code>rand</code> can be used as an angle distribution instead.  This can be useful to create correlated random walks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/walk.jl#L212-L233">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.get_direction" href="#Agents.get_direction"><code>Agents.get_direction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_direction(from, to, model::ABM)</code></pre><p>Return the direction vector from the position <code>from</code> to position <code>to</code> taking into account periodicity of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/utilities.jl#L122-L126">source</a></section></article><h3 id="Movement-with-paths"><a class="docs-heading-anchor" href="#Movement-with-paths">Movement with paths</a><a id="Movement-with-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Movement-with-paths" title="Permalink"></a></h3><p>For <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>, and <a href="#Agents.GridSpace"><code>GridSpace</code></a>/<a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> using <a href="@ref"><code>Pathfinding.Pathfinder</code></a>, a special movement method is available.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.plan_route!" href="#Agents.plan_route!"><code>Agents.plan_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plan_route!(agent, dest, model::ABM{&lt;:OpenStreetMapSpace};
            return_trip = false, kwargs...) → success</code></pre><p>Plan a route from the current position of <code>agent</code> to the location specified in <code>dest</code>, which can be an intersection or a point on a road. Overwrite any existing route.</p><p>If <code>return_trip = true</code>, a route will be planned from start ⟶ finish ⟶ start. All other keywords are passed to <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/shortest_path/#LightOSM.shortest_path"><code>LightOSM.shortest_path</code></a>.</p><p>Return <code>true</code> if a path to <code>dest</code> exists, and hence the route planning was successful. Otherwise return <code>false</code>. Specifying <code>return_trip = true</code> also requires the existence of a return path for a route to be planned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L221-L235">source</a></section><section><div><pre><code class="language-julia hljs">plan_route!(agent, dest, pathfinder::AStar{D})</code></pre><p>Calculate and store the shortest path to move the agent from its current position to <code>dest</code> (a position e.g. <code>(1, 5)</code> or <code>(1.3, 5.2)</code>) using the provided <code>pathfinder</code>.</p><p>Use this method in conjunction with <a href="#Agents.move_along_route!"><code>move_along_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_grid.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.plan_best_route!" href="#Agents.plan_best_route!"><code>Agents.plan_best_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plan_best_route!(agent, dests, pathfinder::AStar{D}; kwargs...)</code></pre><p>Calculate, store, and return the best path to move the agent from its current position to a chosen destination taken from <code>dests</code> using <code>pathfinder</code>.</p><p>The <code>condition = :shortest</code> keyword returns the shortest path which is shortest out of the possible destinations. Alternatively, the <code>:longest</code> path may also be requested.</p><p>Return the position of the chosen destination. Return <code>nothing</code> if none of the supplied destinations are reachable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_grid.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.move_along_route!" href="#Agents.move_along_route!"><code>Agents.move_along_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_along_route!(agent, model::ABM{&lt;:OpenStreetMapSpace}, distance::Real) → remaining</code></pre><p>Move an agent by <code>distance</code> along its planned route. Units of distance are as specified by the underlying graph&#39;s <code>weight_type</code>. If the provided <code>distance</code> is greater than the distance to the end of the route, return the remaining distance. Otherwise, return <code>0</code>. <code>0</code> is also returned if <code>is_stationary(agent, model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L757-L764">source</a></section><section><div><pre><code class="language-julia hljs">move_along_route!(agent, model::ABM{&lt;:GridSpace{D}}, pathfinder::AStar{D})</code></pre><p>Move <code>agent</code> for one step along the route toward its target set by <a href="#Agents.plan_route!"><code>plan_route!</code></a></p><p>For pathfinding in models with <a href="#Agents.GridSpace"><code>GridSpace</code></a>.</p><p>If the agent does not have a precalculated path or the path is empty, it remains stationary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_grid.jl#L53-L60">source</a></section><section><div><pre><code class="language-julia hljs">move_along_route!(agent, model::ABM{&lt;:ContinuousSpace{D}}, pathfinder::AStar{D}, speed, dt = 1.0)</code></pre><p>Move <code>agent</code> for one step along the route toward its target set by <a href="#Agents.plan_route!"><code>plan_route!</code></a> at the given <code>speed</code> and timestep <code>dt</code>.</p><p>For pathfinding in models with <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a></p><p>If the agent does not have a precalculated path or the path is empty, it remains stationary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_continuous.jl#L99-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.is_stationary" href="#Agents.is_stationary"><code>Agents.is_stationary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_stationary(agent, model)</code></pre><p>Return <code>true</code> if agent has reached the end of its route, or no route has been set for it. Used in setups where using <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L109-L113">source</a></section><section><div><pre><code class="language-julia hljs">is_stationary(agent, astar::AStar)</code></pre><p>Same, but for pathfinding with A*.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar.jl#L214-L217">source</a></section></article><h2 id="Removing-agents"><a class="docs-heading-anchor" href="#Removing-agents">Removing agents</a><a id="Removing-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.remove_agent!" href="#Agents.remove_agent!"><code>Agents.remove_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_agent!(agent::AbstractAgent, model::ABM)
remove_agent!(id::Int, model::ABM)</code></pre><p>Remove an agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L137-L142">source</a></section><section><div><pre><code class="language-julia hljs">Pathfinding.remove_agent!(agent, model, pathfinder)</code></pre><p>The same as <code>remove_agent!(agent, model)</code>, but also removes the agent&#39;s path data from <code>pathfinder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.remove_all!" href="#Agents.remove_all!"><code>Agents.remove_all!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">remove_all!(model::ABM)</code></pre><p>Remove all the agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L149-L152">source</a></section><section><div><pre><code class="language-julia hljs">remove_all!(model::ABM, n::Int)</code></pre><p>Remove the agents whose IDs are larger than n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L159-L162">source</a></section><section><div><pre><code class="language-julia hljs">remove_all!(model::ABM, IDs)</code></pre><p>Remove the agents with the given IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L170-L173">source</a></section><section><div><pre><code class="language-julia hljs">remove_all!(model::ABM, f::Function)</code></pre><p>Remove all agents where the function <code>f(agent)</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L180-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.sample!" href="#Agents.sample!"><code>Agents.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sample!(model::ABM, n [, weight]; kwargs...)</code></pre><p>Replace the agents of the <code>model</code> with a random sample of the current agents with size <code>n</code>.</p><p>Optionally, provide a <code>weight</code>: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the <code>weight</code> of the agent, the higher the probability that this agent will be chosen in the new sampling.</p><p><strong>Keywords</strong></p><ul><li><code>replace = true</code> : whether sampling is performed with replacement, i.e. all agents can</li></ul><p>be chosen more than once.</p><p>Example usage in <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/wright-fisher/">Wright-Fisher model of evolution</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/sample.jl#L4-L20">source</a></section></article><h2 id="Space-utility-functions"><a class="docs-heading-anchor" href="#Space-utility-functions">Space utility functions</a><a id="Space-utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Space-utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.normalize_position" href="#Agents.normalize_position"><code>Agents.normalize_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">normalize_position(pos, model::ABM{&lt;:Union{AbstractGridSpace,ContinuousSpace}})</code></pre><p>Return the position <code>pos</code> normalized for the extents of the space of the given <code>model</code>. For periodic spaces, this wraps the position along each dimension, while for non-periodic spaces this clamps the position to the space extent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/walk.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.spacesize" href="#Agents.spacesize"><code>Agents.spacesize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">spacesize(model::ABM)</code></pre><p>Return the size of the model&#39;s space. Works for <a href="@ref"><code>AbstractGridSpace</code></a> and <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/utilities.jl#L4-L9">source</a></section></article><h2 id="Discrete-space-exclusives"><a class="docs-heading-anchor" href="#Discrete-space-exclusives">Discrete space exclusives</a><a id="Discrete-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.positions" href="#Agents.positions"><code>Agents.positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">positions(model::ABM{&lt;:DiscreteSpace}) → ns</code></pre><p>Return an iterator over all positions of a model with a discrete space.</p><pre><code class="nohighlight hljs">positions(model::ABM{&lt;:DiscreteSpace}, by::Symbol) → ns</code></pre><p>Return all positions of a model with a discrete space, sorting them using the argument <code>by</code> which can be:</p><ul><li><code>:random</code> - randomly sorted</li><li><code>:population</code> - positions are sorted depending on how many agents they accommodate. The more populated positions are first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L19-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.npositions" href="#Agents.npositions"><code>Agents.npositions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">npositions(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the number of positions of a model with a discrete space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.ids_in_position" href="#Agents.ids_in_position"><code>Agents.ids_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ids_in_position(position, model::ABM{&lt;:DiscreteSpace})
ids_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the ids of agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.id_in_position" href="#Agents.id_in_position"><code>Agents.id_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">id_in_position(pos, model::ABM{&lt;:GridSpaceSingle}) → id</code></pre><p>Return the agent ID in the given position. This will be <code>0</code> if there is no agent in this position.</p><p>This is similar to <a href="#Agents.ids_in_position"><code>ids_in_position</code></a>, but specialized for <code>GridSpaceSingle</code>. See also <a href="@ref"><code>isempty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/grid_single.jl#L67-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.agents_in_position" href="#Agents.agents_in_position"><code>Agents.agents_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">agents_in_position(position, model::ABM{&lt;:DiscreteSpace})
agents_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return an iterable of the agents in <code>position</code><code>, or in the position of</code>agent`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_id_in_position" href="#Agents.random_id_in_position"><code>Agents.random_id_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_id_in_position(pos, model::ABM, [f, alloc = false]) → id</code></pre><p>Return a random id in the position specified in <code>pos</code>.</p><p>A filter function <code>f(id)</code> can be passed so that to restrict the sampling on only those agents for which the function returns <code>true</code>. The argument <code>alloc</code> can be used if the filtering condition is expensive since in this case the allocating version can be more performant. <code>nothing</code> is returned if no nearby position satisfies <code>f</code>.</p><p>Use <a href="#Agents.random_nearby_id"><code>random_nearby_id</code></a> instead to return the <code>id</code> of a random agent near the position of a given <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L131-L142">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_agent_in_position" href="#Agents.random_agent_in_position"><code>Agents.random_agent_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_agent_in_position(pos, model::ABM, [f, alloc = false]) → agent</code></pre><p>Return a random agent in the position specified in <code>pos</code>.</p><p>A filter function <code>f(agent)</code> can be passed so that to restrict the sampling on only those agents for which the function returns <code>true</code>. The argument <code>alloc</code> can be used if the filtering condition is expensive since in this case the allocating version can be more performant. <code>nothing</code> is returned if no nearby position satisfies <code>f</code>.</p><p>Use <a href="#Agents.random_nearby_agent"><code>random_nearby_agent</code></a> instead to return a random agent near the position of a given <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L160-L170">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.fill_space!" href="#Agents.fill_space!"><code>Agents.fill_space!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, args...)
fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}; kwargs...)
fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, f::Function)</code></pre><p>Add one agent to each position in the model&#39;s space. Similarly with <a href="#Agents.add_agent!"><code>add_agent!</code></a>, <code>fill_space</code> creates the necessary agents and adds them to the model. Like in <a href="#Agents.add_agent!"><code>add_agent!</code></a> you may use either <code>args...</code> or <code>kwargs...</code> to set the remaining properties of the agent.</p><p>Alternatively, you may use the third version. If instead of <code>args...</code> a function <code>f</code> is provided, then <code>args = f(pos)</code> is the result of applying <code>f</code> where <code>pos</code> is each position (tuple for grid, integer index for graph). Hence, in this case <code>f</code> must create all other agent properties besides mandatory <code>id, pos</code>.</p><p>An optional first argument is an agent <strong>type</strong> to be created, and targets mixed agent models where the agent constructor cannot be deduced (since it is a union).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L227-L244">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.has_empty_positions" href="#Agents.has_empty_positions"><code>Agents.has_empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">has_empty_positions(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are any positions in the model without agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L84-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.empty_positions" href="#Agents.empty_positions"><code>Agents.empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_positions(model)</code></pre><p>Return a list of positions that currently have no agents on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.empty_nearby_positions" href="#Agents.empty_nearby_positions"><code>Agents.empty_nearby_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">empty_nearby_positions(pos, model::ABM{&lt;:DiscreteSpace}, r = 1; kwargs...)
empty_nearby_positions(agent, model::ABM{&lt;:DiscreteSpace}, r = 1; kwargs...)</code></pre><p>Return an iterable of all empty positions within radius <code>r</code> from the given position or the given agent.</p><p>The value of <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_positions"><code>nearby_positions</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_empty" href="#Agents.random_empty"><code>Agents.random_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_empty(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return a random position without any agents, or <code>nothing</code> if no such positions exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L92-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.add_agent_single!" href="#Agents.add_agent_single!"><code>Agents.add_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agent</code></pre><p>Add the <code>agent</code> to a random position in the space while respecting a maximum of one agent per position, updating the agent&#39;s position to the new one.</p><p>This function does nothing if there aren&#39;t any empty positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L187-L194">source</a></section><section><div><pre><code class="language-julia hljs">add_agent_single!(model::ABM{&lt;:DiscreteSpace}, properties...; kwargs...)</code></pre><p>Same as <code>add_agent!(model, properties...; kwargs...)</code> but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L203-L207">source</a></section><section><div><pre><code class="language-julia hljs">add_agent_single!(A, model::ABM{&lt;:DiscreteSpace}, properties...; kwargs...)</code></pre><p>Same as <code>add_agent!(A, model, properties...; kwargs...)</code> but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L215-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.move_agent_single!" href="#Agents.move_agent_single!"><code>Agents.move_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">move_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}; cutoff) → agent</code></pre><p>Move agent to a random position while respecting a maximum of one agent per position. If there are no empty positions, the agent won&#39;t move.</p><p>The keyword <code>cutoff = 0.998</code> is sent to <a href="#Agents.random_empty"><code>random_empty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L270-L277">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.swap_agents!" href="#Agents.swap_agents!"><code>Agents.swap_agents!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">swap_agents!(agent1, agent2, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Swap the given agent&#39;s positions, moving each of them to the position of the other agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/discrete.jl#L289-L294">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>isempty(::Integer, ::ABM)</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="GraphSpace-exclusives"><a class="docs-heading-anchor" href="#GraphSpace-exclusives"><code>GraphSpace</code> exclusives</a><a id="GraphSpace-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#GraphSpace-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!" href="#Graphs.SimpleGraphs.add_edge!"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_edge!(model::ABM{&lt;:GraphSpace},  args...; kwargs...)</code></pre><p>Add a new edge (relationship between two positions) to the graph. Returns a boolean, true if the operation was successful.</p><p><code>args</code> and <code>kwargs</code> are directly passed to the <code>add_edge!</code> dispatch that acts the underlying graph type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/graph.jl#L187-L193">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_edge!" href="#Graphs.SimpleGraphs.rem_edge!"><code>Graphs.SimpleGraphs.rem_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rem_edge!(model::ABM{&lt;:GraphSpace}, n, m)</code></pre><p>Remove an edge (relationship between two positions) from the graph. Returns a boolean, true if the operation was successful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/graph.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.SimpleGraphs.add_vertex!" href="#Graphs.SimpleGraphs.add_vertex!"><code>Graphs.SimpleGraphs.add_vertex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_vertex!(model::ABM{&lt;:GraphSpace})</code></pre><p>Add a new node (i.e. possible position) to the model&#39;s graph and return it. You can connect this new node with existing ones using <a href="#Graphs.SimpleGraphs.add_edge!"><code>add_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/graph.jl#L176-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Graphs.SimpleGraphs.rem_vertex!" href="#Graphs.SimpleGraphs.rem_vertex!"><code>Graphs.SimpleGraphs.rem_vertex!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rem_vertex!(model::ABM{&lt;:GraphSpace}, n::Int)</code></pre><p>Remove node (i.e. position) <code>n</code> from the model&#39;s graph. All agents in that node are removed from the model.</p><p><strong>Warning:</strong> Graphs.jl (and thus Agents.jl) swaps the index of the last node with that of the one to be removed, while every other node remains as is. This means that when doing <code>rem_vertex!(n, model)</code> the last node becomes the <code>n</code>-th node while the previous <code>n</code>-th node (and all its edges and agents) are deleted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/graph.jl#L155-L163">source</a></section></article><h2 id="ContinuousSpace-exclusives"><a class="docs-heading-anchor" href="#ContinuousSpace-exclusives"><code>ContinuousSpace</code> exclusives</a><a id="ContinuousSpace-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#ContinuousSpace-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.nearby_ids_exact" href="#Agents.nearby_ids_exact"><code>Agents.nearby_ids_exact</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearby_ids_exact(x, model, r = 1)</code></pre><p>Return an iterator over agent IDs nearby <code>x</code> (a position or an agent). Only valid for <code>ContinuousSpace</code> models. Use instead of <a href="#Agents.nearby_ids"><code>nearby_ids</code></a> for a slower, but 100% accurate version. See <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L213-L219">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.nearest_neighbor" href="#Agents.nearest_neighbor"><code>Agents.nearest_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearest_neighbor(agent, model::ABM{&lt;:ContinuousSpace}, r) → nearest</code></pre><p>Return the agent that has the closest distance to given <code>agent</code>. Return <code>nothing</code> if no agent is within distance <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L286-L291">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.get_spatial_property" href="#Agents.get_spatial_property"><code>Agents.get_spatial_property</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_spatial_property(pos, property::AbstractArray, model::ABM)</code></pre><p>Convert the continuous agent position into an appropriate <code>index</code> of <code>property</code>, which represents some discretization of a spatial field over a <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. Then, return <code>property[index]</code>. To get the <code>index</code> directly, for e.g. mutating the <code>property</code> in-place, use <a href="#Agents.get_spatial_index"><code>get_spatial_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L528-L534">source</a></section><section><div><pre><code class="language-julia hljs">get_spatial_property(pos, property::Function, model::ABM)</code></pre><p>Literally equivalent with <code>property(pos, model)</code>, provided just for syntax consistency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L540-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.get_spatial_index" href="#Agents.get_spatial_index"><code>Agents.get_spatial_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_spatial_index(pos, property::AbstractArray, model::ABM)</code></pre><p>Convert the continuous agent position into an appropriate <code>index</code> of <code>property</code>, which represents some discretization of a spatial field over a <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>.</p><p>The dimensionality of <code>property</code> and the continuous space do not have to match. If <code>property</code> has lower dimensionality than the space (e.g. representing some surface property in 3D space) then the front dimensions of <code>pos</code> will be used to index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L546-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.interacting_pairs" href="#Agents.interacting_pairs"><code>Agents.interacting_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">interacting_pairs(model, r, method; scheduler = abmscheduler(model)) → piter</code></pre><p>Return an iterator that yields <strong>unique pairs</strong> of agents <code>(a, b)</code> that are close neighbors to each other, within some interaction radius <code>r</code>.</p><p>This function is usefully combined with <code>model_step!</code>, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with <code>a</code> and with <code>b</code>, which would be unavoidable when using <code>agent_step!</code>). This means, that if a pair <code>(a, b)</code> exists, the pair <code>(b, a)</code> is not included in the iterator!</p><p>Use <code>piter.pairs</code> to get a vector of pair IDs from the iterator.</p><p>The argument <code>method</code> provides three pairing scenarios</p><ul><li><code>:all</code>: return every pair of agents that are within radius <code>r</code> of each other, not only the nearest ones.</li><li><code>:nearest</code>: agents are only paired with their true nearest neighbor (existing within radius <code>r</code>). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by distance, then by next id in <code>scheduler</code>) will be paired.</li><li><code>:types</code>: For mixed agent models only. Return every pair of agents within radius <code>r</code> (similar to <code>:all</code>), only capturing pairs of differing types. For example, a model of <code>Union{Sheep,Wolf}</code> will only return pairs of <code>(Sheep, Wolf)</code>. In the case of multiple agent types, e.g. <code>Union{Sheep, Wolf, Grass}</code>, skipping pairings that involve <code>Grass</code>, can be achieved by a <a href="#Schedulers"><code>scheduler</code></a> that doesn&#39;t schedule <code>Grass</code> types, i.e.: <code>scheduler(model) = (a.id for a in allagents(model) if !(a isa Grass))</code>.</li></ul><p>The following keywords can be used:</p><ul><li><code>scheduler = abmscheduler(model)</code>, which schedulers the agents during iteration for finding pairs. Especially in the <code>:nearest</code> case, this is important, as different sequencing for the agents may give different results (if <code>b</code> is the nearest agent for <code>a</code>, but <code>a</code> is not the nearest agent for <code>b</code>, whether you get the pair <code>(a, b)</code> or not depends on whether <code>a</code> was scheduler first or not).</li><li><code>nearby_f = nearby_ids_exact</code> is the function that decides how to find nearby IDs in the <code>:all, :types</code> cases. Must be <code>nearby_ids_exact</code> or <code>nearby_ids</code>.</li></ul><p>Example usage in <a href="@ref">https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/growing_bacteria/</a>.</p><div class="admonition is-info"><header class="admonition-header">Better performance with CellListMap.jl</header><div class="admonition-body"><p>Notice that in most applications that <a href="#Agents.interacting_pairs"><code>interacting_pairs</code></a> is useful, there is significant (10x-100x) performance gain to be made by integrating with CellListMap.jl. Checkout the <a href="../examples/celllistmap/#Integrating-Agents.jl-with-CellListMap.jl">Integrating Agents.jl with CellListMap.jl</a> integration example for how to do this.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L370-L415">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.elastic_collision!" href="#Agents.elastic_collision!"><code>Agents.elastic_collision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elastic_collision!(a, b, f = nothing) → happened</code></pre><p>Resolve a (hypothetical) elastic collision between the two agents <code>a, b</code>. They are assumed to be disks of equal size touching tangentially. Their velocities (field <code>vel</code>) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.</p><p>If <code>f</code> is a <code>Symbol</code>, then the agent property <code>f</code>, e.g. <code>:mass</code>, is taken as a mass to weight the two agents for the collision. By default no weighting happens.</p><p>One of the two agents can have infinite &quot;mass&quot;, and then acts as an immovable object that specularly reflects the other agent. In this case momentum is not conserved, but kinetic energy is still conserved.</p><p>Return a boolean encoding whether the collision happened.</p><p>Example usage in <a href=" https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/social_distancing/">Continuous space social distancing</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/continuous.jl#L310-L331">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.euclidean_distance" href="#Agents.euclidean_distance"><code>Agents.euclidean_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">euclidean_distance(a, b, model::ABM)</code></pre><p>Return the euclidean distance between <code>a</code> and <code>b</code> (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently <code>AbstractGridSpace</code> and <code>ContinuousSpace</code>.</p><p>Example usage in the <a href="../examples/flock/#Flocking-model">Flocking model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/utilities.jl#L15-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.manhattan_distance" href="#Agents.manhattan_distance"><code>Agents.manhattan_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">manhattan_distance(a, b, model::ABM)</code></pre><p>Return the manhattan distance between <code>a</code> and <code>b</code> (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently <code>AbstractGridSpace</code> and <code>ContinuousSpace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/utilities.jl#L70-L76">source</a></section></article><h2 id="OpenStreetMapSpace-exclusives"><a class="docs-heading-anchor" href="#OpenStreetMapSpace-exclusives"><code>OpenStreetMapSpace</code> exclusives</a><a id="OpenStreetMapSpace-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#OpenStreetMapSpace-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM" href="#Agents.OSM"><code>Agents.OSM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">OSM</code></pre><p>Submodule for functionality related to <code>OpenStreetMapSpace</code>. See the docstring of the space for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.lonlat" href="#Agents.OSM.lonlat"><code>Agents.OSM.lonlat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.lonlat(pos, model)
OSM.lonlat(agent, model)</code></pre><p>Return <code>(longitude, latitude)</code> of current road or intersection position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L492-L497">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.nearest_node" href="#Agents.OSM.nearest_node"><code>Agents.OSM.nearest_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.nearest_node(lonlat::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return the nearest intersection position to <strong>(longitude, latitude)</strong>. Quicker, but less precise than <a href="#Agents.OSM.nearest_road"><code>OSM.nearest_road</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L525-L530">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.nearest_road" href="#Agents.OSM.nearest_road"><code>Agents.OSM.nearest_road</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.nearest_road(lonlat::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return a location on a road nearest to <strong>(longitude, latitude)</strong>. Slower, but more precise than <a href="#Agents.OSM.nearest_node"><code>OSM.nearest_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L539-L544">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.random_road_position" href="#Agents.OSM.random_road_position"><code>Agents.OSM.random_road_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.random_road_position(model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Similar to <a href="#Agents.random_position"><code>random_position</code></a>, but rather than providing only intersections, this method returns a location somewhere on a road heading in a random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L175-L180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.plan_random_route!" href="#Agents.OSM.plan_random_route!"><code>Agents.OSM.plan_random_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.plan_random_route!(agent, model::ABM{&lt;:OpenStreetMapSpace}; kwargs...) → success</code></pre><p>Plan a new random route for the agent, by selecting a random destination and planning a route from the agent&#39;s current position. Overwrite any existing route.</p><p>The keyword <code>limit = 10</code> specifies the limit on the number of attempts at planning a random route, as no connection may be possible given the random destination. Return <code>true</code> if a route was successfully planned, <code>false</code> otherwise. All other keywords are passed to <a href="#Agents.plan_route!"><code>plan_route!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L192-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.road_length" href="#Agents.OSM.road_length"><code>Agents.OSM.road_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.road_length(start::Int, finish::Int, model)
OSM.road_length(pos::Tuple{Int,Int,Float64}, model)</code></pre><p>Return the road length between two intersections. This takes into account the direction of the road, so <code>OSM.road_length(pos_1, pos_2, model)</code> may not be the same as <code>OSM.road_length(pos_2, pos_1, model)</code>. Units of the returned quantity are as specified by the underlying graph&#39;s <code>weight_type</code>. If <code>start</code> and <code>finish</code> are the same or <code>pos[1]</code> and <code>pos[2]</code> are the same, then return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L562-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.route_length" href="#Agents.OSM.route_length"><code>Agents.OSM.route_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.route_length(agent, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return the length of the route planned for the given <code>agent</code>, correctly taking into account the amount of route already traversed by the <code>agent</code>. Return 0 if <code>is_stationary(agent, model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L587-L592">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.same_position" href="#Agents.OSM.same_position"><code>Agents.OSM.same_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.same_position(a::Tuple{Int,Int,Float64}, b::Tuple{Int,Int,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return <code>true</code> if the given positions <code>a</code> and <code>b</code> are (approximately) identical</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L624-L628">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.same_road" href="#Agents.OSM.same_road"><code>Agents.OSM.same_road</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.same_road(a::Tuple{Int,Int,Float64}, b::Tuple{Int,Int,Float64})</code></pre><p>Return <code>true</code> if both points lie on the same road of the graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L688-L692">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.OSM.test_map" href="#Agents.OSM.test_map"><code>Agents.OSM.test_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">OSM.test_map()</code></pre><p>Download a small test map of <a href="https://www.openstreetmap.org/export#map=16/51.5333/9.9363">Göttingen</a> as an artifact. Return a path to the downloaded file.</p><p>Using this map requires <code>network_type = :none</code> to be passed as a keyword to <a href="@ref"><code>OSMSpace</code></a>. The unit of distance used for this map is <code>:time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/spaces/openstreetmap.jl#L161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LightOSM.download_osm_network" href="#LightOSM.download_osm_network"><code>LightOSM.download_osm_network</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_osm_network(download_method::Symbol;
                     network_type::Symbol=:drive,
                     metadata::Bool=false,
                     download_format::Symbol=:json,
                     save_to_file_location::Union{String,Nothing}=nothing,
                     download_kwargs...
                     )::Union{XMLDocument,Dict{String,Any}}</code></pre><p>Downloads an OpenStreetMap network by querying with a place name, bounding box, or centroid point.</p><p><strong>Arguments</strong></p><ul><li><code>download_method::Symbol</code>: Download method, choose from <code>:place_name</code>, <code>:bbox</code> or <code>:point</code>.</li><li><code>network_type::Symbol=:drive</code>: Network type filter, pick from <code>:drive</code>, <code>:drive_service</code>, <code>:walk</code>, <code>:bike</code>, <code>:all</code>, <code>:all_private</code>, <code>:none</code>, <code>:rail</code></li><li><code>metadata::Bool=false</code>: Set true to return metadata.</li><li><code>download_format::Symbol=:json</code>: Download format, either <code>:osm</code>, <code>:xml</code> or <code>json</code>.</li><li><code>save_to_file_location::Union{String,Nothing}=nothing</code>: Specify a file location to save downloaded data to disk.</li></ul><p><strong>Required Kwargs for each Download Method</strong></p><p><em><code>download_method=:place_name</code></em></p><ul><li><code>place_name::String</code>: Any place name string used as a search argument to the Nominatim API.</li></ul><p><em><code>download_method=:bbox</code></em></p><ul><li><code>minlat::AbstractFloat</code>: Bottom left bounding box latitude coordinate.</li><li><code>minlon::AbstractFloat</code>: Bottom left bounding box longitude coordinate.</li><li><code>maxlat::AbstractFloat</code>: Top right bounding box latitude coordinate.</li><li><code>maxlon::AbstractFloat</code>: Top right bounding box longitude coordinate.</li></ul><p><em><code>download_method=:point</code></em></p><ul><li><code>point::GeoLocation</code>: Centroid point to draw the bounding box around.</li><li><code>radius::Number</code>: Distance (km) from centroid point to each bounding box corner.</li></ul><p><em><code>download_method=:polygon</code></em></p><ul><li><code>polygon::AbstractVector</code>: Vector of longitude-latitude pairs.</li></ul><p><em><code>download_method=:custom_filters</code></em></p><ul><li><code>custom_filters::String</code>: Filters for the query, e.g. polygon filter, highways only, traffic lights only, etc.</li><li><code>metadata::Bool=false</code>: Set true to return metadata.</li><li><code>download_format::Symbol=:json</code>: Download format, either <code>:osm</code>, <code>:xml</code> or <code>json</code>.</li><li><code>bbox::Union{Vector{AbstractFloat},Nothing}=nothing</code>: Optional bounding box filter.</li></ul><p><strong>Network Types</strong></p><ul><li><code>:drive</code>: Motorways excluding private and service ways.</li><li><code>:drive_service</code>: Motorways including private and service ways.</li><li><code>:walk</code>: Walkways only.</li><li><code>:bike</code>: Cycleways only.</li><li><code>:all</code>: All motorways, walkways and cycleways excluding private ways.</li><li><code>:all_private</code>: All motorways, walkways and cycleways including private ways.</li><li><code>:none</code>: No network filters.</li><li><code>:rail</code>: Railways excluding proposed and platform.</li></ul><p><strong>Return</strong></p><ul><li><code>Union{XMLDocument,Dict{String,Any}}</code>: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/DeloitteOptimalReality/LightOSM.jl/blob/v0.2.11/src/download.jl#L374-L428">source</a></section></article><h2 id="Nearby-Agents"><a class="docs-heading-anchor" href="#Nearby-Agents">Nearby Agents</a><a id="Nearby-Agents-1"></a><a class="docs-heading-anchor-permalink" href="#Nearby-Agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.nearby_ids" href="#Agents.nearby_ids"><code>Agents.nearby_ids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearby_ids(pos, model::ABM, r = 1; kwargs...) → ids</code></pre><p>Return an iterable over the IDs of the agents within distance <code>r</code> (inclusive) from the given position. The position must match type with the spatial structure of the <code>model</code>. The specification of what &quot;distance&quot; means depends on the space, hence it is explained in each space&#39;s documentation string. Keyword arguments are space-specific and also described in each space&#39;s documentation string.</p><p><code>nearby_ids</code> always includes IDs with 0 distance to <code>pos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L61-L71">source</a></section><section><div><pre><code class="language-julia hljs">nearby_ids(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_ids(agent.pos, model, r)</code> but the iterable <em>excludes</em> the given <code>agent</code>&#39;s id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.nearby_agents" href="#Agents.nearby_agents"><code>Agents.nearby_agents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearby_agents(agent, model::ABM, r = 1; kwargs...) -&gt; agent</code></pre><p>Return an iterable of the agents near the position of the given <code>agent</code>.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L320-L326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.nearby_positions" href="#Agents.nearby_positions"><code>Agents.nearby_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nearby_positions(pos, model::ABM{&lt;:DiscreteSpace}, r=1; kwargs...)</code></pre><p>Return an iterable of all positions within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which excludes given <code>position</code>). The <code>position</code> must match type with the spatial structure of the <code>model</code>.</p><p>The value of <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p><p>This function only exists for discrete spaces with a finite amount of positions.</p><pre><code class="nohighlight hljs">nearby_positions(position, model::ABM{&lt;:OpenStreetMapSpace}; kwargs...) → positions</code></pre><p>For <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a> this means &quot;nearby intersections&quot; and operates directly on the underlying graph of the OSM, providing the intersection nodes nearest to the given position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L74-L90">source</a></section><section><div><pre><code class="language-julia hljs">nearby_positions(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_positions(agent.pos, model, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L311-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_nearby_id" href="#Agents.random_nearby_id"><code>Agents.random_nearby_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_nearby_id(agent, model::ABM, r = 1, f = nothing, alloc = false; kwargs...) → id</code></pre><p>Return the <code>id</code> of a random agent near the position of the given <code>agent</code>.</p><p>Return <code>nothing</code> if no agents are nearby.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p><p>A filter function <code>f(id)</code> can be passed so that to restrict the sampling on only those ids for which the function returns <code>true</code>. The argument <code>alloc</code> can be used if the filtering condition is expensive since in this case the allocating version can be more performant. <code>nothing</code> is returned if no nearby id satisfies <code>f</code>.</p><p>For discrete spaces, use <a href="#Agents.random_id_in_position"><code>random_id_in_position</code></a> instead to return a random id at a given position.</p><p>This function, as all the other methods which sample from lazy iterators, uses an optimized algorithm which doesn&#39;t require to collect all elements to just sample one of them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L330-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_nearby_agent" href="#Agents.random_nearby_agent"><code>Agents.random_nearby_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_nearby_agent(agent, model::ABM, r = 1, f = nothing, alloc = false; kwargs...) → agent</code></pre><p>Return a random agent near the position of the given <code>agent</code> or <code>nothing</code> if no agent is nearby.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p><p>A filter function <code>f(agent)</code> can be passed so that to restrict the sampling on only those agents for which the function returns <code>true</code>. The argument <code>alloc</code> can be used if the filtering condition is expensive since in this case the allocating version can be more performant. <code>nothing</code> is returned if no nearby agent satisfies <code>f</code>.</p><p>For discrete spaces, use <a href="#Agents.random_agent_in_position"><code>random_agent_in_position</code></a> instead to return a random agent at a given position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L363-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.random_nearby_position" href="#Agents.random_nearby_position"><code>Agents.random_nearby_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">random_nearby_position(pos, model::ABM, r=1, f = nothing, alloc = false; kwargs...) → position</code></pre><p>Return a random position near the given position. Return <code>nothing</code> if the space doesn&#39;t allow for nearby positions.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_positions"><code>nearby_positions</code></a>.</p><p>A filter function <code>f(pos)</code> can be passed so that to restrict the sampling on only those positions for which the function returns <code>true</code>. The argument <code>alloc</code> can be used if the filtering condition is expensive since in this case the allocating version can be more performant. <code>nothing</code> is returned if no nearby position satisfies <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/space_interaction_API.jl#L394-L405">source</a></section></article><h2 id="A-note-on-iteration"><a class="docs-heading-anchor" href="#A-note-on-iteration">A note on iteration</a><a id="A-note-on-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-on-iteration" title="Permalink"></a></h2><p>Most iteration in Agents.jl is <strong>dynamic</strong> and <strong>lazy</strong>, when possible, for performance reasons.</p><p><strong>Dynamic</strong> means that when iterating over the result of e.g. the <a href="#Agents.ids_in_position"><code>ids_in_position</code></a> function, the iterator will be affected by actions that would alter its contents. Specifically, imagine the scenario</p><pre><code class="language-julia hljs">using Agents
# We don&#39;t need to make a new agent type here,
# we use the minimal agent for 4-dimensional grid spaces
model = StandardABM(GridAgent{4}, GridSpace((5, 5, 5, 5)))
add_agent!((1, 1, 1, 1), model)
add_agent!((1, 1, 1, 1), model)
add_agent!((2, 1, 1, 1), model)
for id in ids_in_position((1, 1, 1, 1), model)
    remove_agent!(id, model)
end
collect(allids(model))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Int64}:
 2
 3</code></pre><p>You will notice that only 1 agent was removed. This is simply because the final state of the iteration of <code>ids_in_position</code> was reached unnaturally, because the length of its output was reduced by 1 <em>during</em> iteration. To avoid problems like these, you need to <code>collect</code> the iterator to have a non dynamic version.</p><p><strong>Lazy</strong> means that when possible the outputs of the iteration are not collected and instead are generated on the fly. A good example to illustrate this is <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>, where doing something like</p><pre><code class="language-julia hljs">a = random_agent(model)
sort!(nearby_ids(random_agent(model), model))</code></pre><p>leads to error, since you cannot <code>sort!</code> the returned iterator. This can be easily solved by adding a <code>collect</code> in between:</p><pre><code class="language-julia hljs">a = random_agent(model)
sort!(collect(nearby_agents(a, model)))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{GridAgent{4}}:
 GridAgent{4}(3, (2, 1, 1, 1))</code></pre><h2 id="Higher-order-interactions"><a class="docs-heading-anchor" href="#Higher-order-interactions">Higher-order interactions</a><a id="Higher-order-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-order-interactions" title="Permalink"></a></h2><p>There may be times when pair-wise, triplet-wise or higher interactions need to be accounted for across most or all of the model&#39;s agent population. The following methods provide an interface for such calculation.</p><p>These methods follow the conventions outlined above in <a href="#A-note-on-iteration">A note on iteration</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.iter_agent_groups" href="#Agents.iter_agent_groups"><code>Agents.iter_agent_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iter_agent_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)</code></pre><p>Return an iterator over all agents of the model, grouped by order. When <code>order = 2</code>, the iterator returns agent pairs, e.g <code>(agent1, agent2)</code> and when <code>order = 3</code>: agent triples, e.g. <code>(agent1, agent7, agent8)</code>. <code>order</code> must be larger than <code>1</code> but has no upper bound.</p><p>Index order is provided by the <code>scheduler</code> input which is a scheduler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/higher_order_iteration.jl#L4-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.map_agent_groups" href="#Agents.map_agent_groups"><code>Agents.map_agent_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_agent_groups(order::Int, f::Function, model::ABM; kwargs...)
map_agent_groups(order::Int, f::Function, model::ABM, filter::Function; kwargs...)</code></pre><p>Applies function <code>f</code> to all grouped agents of an <a href="#Agents.iter_agent_groups"><code>iter_agent_groups</code></a> iterator. <code>kwargs</code> are passed to the iterator method. <code>f</code> must take the form <code>f(NTuple{O,AgentType})</code>, where the dimension <code>O</code> is equal to <code>order</code>.</p><p>Optionally, a <code>filter</code> function that accepts an iterable and returns a <code>Bool</code> can be applied to remove unwanted matches from the results. <strong>Note:</strong> This option cannot keep matrix order, so should be used in conjunction with <a href="#Agents.index_mapped_groups"><code>index_mapped_groups</code></a> to associate agent ids with the resultant data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/higher_order_iteration.jl#L16-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.index_mapped_groups" href="#Agents.index_mapped_groups"><code>Agents.index_mapped_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">index_mapped_groups(order::Int, model::ABM; scheduler = Schedulers.ByID)
index_mapped_groups(order::Int, model::ABM, filter::Function; scheduler = Schedulers.ByID)</code></pre><p>Return an iterable of agent ids in the model, meeting the <code>filter</code> criteria if used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/core/higher_order_iteration.jl#L35-L39">source</a></section></article><h2 id="Data-collection-and-analysis"><a class="docs-heading-anchor" href="#Data-collection-and-analysis">Data collection and analysis</a><a id="Data-collection-and-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection-and-analysis" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.run!" href="#Agents.run!"><code>Agents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run!(model::ABM, n::Integer; kwargs...) → agent_df, model_df
run!(model::ABM, f::Function; kwargs...) → agent_df, model_df
run!(model::EventQueueABM, n::Float64; kwargs...) → agent_df, model_df</code></pre><p>Run the model (step it with the input arguments propagated into <a href="@ref"><code>step!</code></a>) and collect data specified by the keywords, explained one by one below. Return the data as two <code>DataFrame</code>s, one for agent-level data and one for model-level data. </p><p>See also <a href="#Agents.offline_run!"><code>offline_run!</code></a> to write data to file while running the model.</p><p><strong>Data-deciding keywords</strong></p><ul><li><p><code>adata::Vector</code> means &quot;agent data to collect&quot;. If an entry is a <code>Symbol</code>, e.g. <code>:weight</code>, then the data for this entry is agent&#39;s field <code>weight</code>. If an entry is a <code>Function</code>, e.g. <code>f</code>, then the data for this entry is just <code>f(a)</code> for each agent <code>a</code>. The resulting dataframe columns are named with the input symbol (here <code>:weight, :f</code>).</p></li><li><p><code>adata::Vector{&lt;:Tuple}</code>: if <code>adata</code> is a vector of tuples instead, data aggregation is done over the agent properties.</p><p>For each 2-tuple, the first entry is the &quot;key&quot; (any entry like the ones mentioned above, e.g. <code>:weight, f</code>). The second entry is an aggregating function that aggregates the key, e.g. <code>mean, maximum</code>. So, continuing from the above example, we would have <code>adata = [(:weight, mean), (f, maximum)]</code>.</p><p>It&#39;s also possible to provide a 3-tuple, with the third entry being a conditional function (returning a <code>Bool</code>), which assesses if each agent should be included in the aggregate. For example: <code>x_pos(a) = a.pos[1]&gt;5</code> with <code>(:weight, mean, x_pos)</code> will result in the average weight of agents conditional on their x-position being greater than 5.</p><p>The resulting data name columns use the function <a href="#Agents.dataname"><code>dataname</code></a>. They create something like <code>:mean_weight</code> or <code>:maximum_f_x_pos</code>. In addition, you can use anonymous functions in a list comprehension to assign elements of an array into different columns: <code>adata = [(a)-&gt;(a.interesting_array[i]) for i=1:N]</code>. Column names can also be renamed with <code>DataFrames.rename!</code> after data is collected.</p><p><strong>Notice:</strong> Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. <em>E.g.</em> instead of passing <code>mean</code>, pass <code>mymean(a) = isempty(a) ? 0.0 : mean(a)</code>.</p></li><li><p><code>mdata::Vector</code> means &quot;model data to collect&quot; and works exactly like <code>adata</code>. For the model, no aggregation is possible (nothing to aggregate over).</p><p>Alternatively, <code>mdata</code> can also be a function. This is a &quot;generator&quot; function, that accepts <code>model</code> as input and provides a <code>Vector</code> that represents <code>mdata</code>. Useful in combination with an <a href="#Agents.ensemblerun!"><code>ensemblerun!</code></a> call that requires a generator function.</p></li></ul><p>By default both keywords are <code>nothing</code>, i.e. nothing is collected/aggregated.</p><p><strong>Mixed-Models</strong></p><p>For mixed-models, the <code>adata</code> keyword has some additional options &amp; properties. An additional column <code>agent_type</code> will be placed in the output dataframe.</p><p>In the case that data is needed for one agent type that does not exist in a second agent type, <code>missing</code> values will be added to the dataframe.</p><p><strong>Warning:</strong> Since this option is inherently type unstable, try to avoid this in a performance critical situation.</p><p>Aggregate functions will fail if <code>missing</code> values are not handled explicitly. If <code>a1.weight</code> but <code>a2</code> (type: Agent2) has no <code>weight</code>, use <code>a2(a) = a isa Agent2; adata = [(:weight, sum, a2)]</code> to filter out the missing results.</p><p><strong>Other keywords</strong></p><ul><li><code>when=true</code> : at which time <code>s</code> to perform the data collection and processing. A lot of flexibility is offered based on the type of <code>when</code>. If <code>when::AbstractVector</code>, then data are collected if <code>s ∈ when</code>. Otherwise data are collected if <code>when(model, s)</code> returns <code>true</code>. By default data are collected in every step. If <code>model</code> is a <code>EventQueueABM</code>, passing <code>when</code> as a function is not supported.</li><li><code>when_model = when</code> : same as <code>when</code> but for model data. If <code>model</code> is a <code>EventQueueABM</code>, only <code>when_model = when</code> is supported.</li><li><code>obtainer = identity</code> : method to transfer collected data to the <code>DataFrame</code>. Typically only change this to <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy"><code>copy</code></a> if some data are mutable containers (e.g. <code>Vector</code>) which change during evolution, or <a href="https://docs.julialang.org/en/v1/base/base/#Base.deepcopy"><code>deepcopy</code></a> if some data are nested mutable containers. Both of these options have performance penalties.</li><li><code>showprogress=false</code> : Whether to show progress</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L24-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.ensemblerun!" href="#Agents.ensemblerun!"><code>Agents.ensemblerun!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ensemblerun!(models::Vector, n; kwargs...)</code></pre><p>Perform an ensemble simulation of <a href="#Agents.run!"><code>run!</code></a> for all <code>model ∈ models</code>. Each <code>model</code> should be a (different) instance of an <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> but probably initialized with a different random seed or different initial agent distribution. All models obey the same evolution rules contained in  the model and are evolved for <code>n</code>.</p><p>Similarly to <a href="#Agents.run!"><code>run!</code></a> this function will collect data. It will furthermore add one additional column to the dataframe called <code>:ensemble</code>, which has an integer value counting the ensemble member. The function returns <code>agent_df, model_df, models</code>.</p><p>If you want to scan parameters and at the same time run multiple simulations at each parameter combination, simply use <code>seed</code> as a parameter, and use that parameter to tune the model&#39;s initial random seed and/or agent distribution.</p><p>See example usage in <a href="@ref">Schelling&#39;s segregation model</a>.</p><p><strong>Keywords</strong></p><p>The following keywords modify the <code>ensemblerun!</code> function:</p><ul><li><code>parallel::Bool = false</code> whether <code>Distributed.pmap</code> is invoked to run simulations in parallel. This must be used in conjunction with <code>@everywhere</code> (see <a href="../performance_tips/#Performance-Tips">Performance Tips</a>).</li><li><code>showprogress::Bool = false</code> whether a progressbar will be displayed to indicate % runs finished.</li></ul><p>All other keywords are propagated to <a href="#Agents.run!"><code>run!</code></a> as-is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/ensemblerun.jl#L4-L29">source</a></section><section><div><pre><code class="language-julia hljs">ensemblerun!(generator, n; kwargs...)</code></pre><p>Generate many <code>ABM</code>s and propagate them into <code>ensemblerun!(models, ...)</code> using the provided <code>generator</code> which is a one-argument function whose input is a seed.</p><p>This method has additional keywords <code>ensemble = 5, seeds = rand(UInt32, ensemble)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/ensemblerun.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.paramscan" href="#Agents.paramscan"><code>Agents.paramscan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">paramscan(parameters::AbstractDict, initialize; kwargs...) → adf, mdf</code></pre><p>Perform a parameter scan of an ABM simulation output by collecting data from all parameter combinations into dataframes (one for agent data, one for model data). The dataframes columns are both the collected data (as in <a href="#Agents.run!"><code>run!</code></a>) but also the input parameter values used.</p><p><code>parameters</code> is a dictionary with key type <code>Symbol</code>. Each entry of the dictionary maps a parameter key to the parameter values that should be scanned over (or to a single parameter value that will remain constant throughout the scans). The approach regarding <code>parameters</code> is as follows:</p><ul><li>If the value of a specific key is a <code>Vector</code>, all values of the vector are expended as values for the parameter to scan over.</li><li>If the value of a specific key is not a <code>Vector</code>, it is assumed that whatever this value is, it corresponds to a single and constant parameter value and therefore it is not expanded or scanned over.</li></ul><p>This is done so that parameter values that are inherently iterable (such as a <code>String</code>) are not wrongly expanded into their constituents. (if the value of a parameter is itself a <code>Vector</code>, then you need to pass in a vector of vectors to scan the parameter)</p><p>The second argument <code>initialize</code> is a function that creates an ABM and returns it. It must accept keyword arguments which are the <em>keys</em> of the <code>parameters</code> dictionary. Since the user decides how to use input arguments to make an ABM, <code>parameters</code> can be used to affect model properties, space type and creation as well as agent properties, see the example below.</p><p><strong>Keywords</strong></p><p>The following keywords modify the <code>paramscan</code> function:</p><ul><li><code>include_constants::Bool = false</code>: by default, only the varying parameters (<code>Vector</code> values in <code>parameters</code>) will be included in the output <code>DataFrame</code>. If <code>true</code>, constant parameters (non-Vector in <code>parameters</code>) will also be included.</li><li><code>parallel::Bool = false</code> whether <code>Distributed.pmap</code> is invoked to run simulations in parallel. This must be used in conjunction with <code>@everywhere</code> (see <a href="../performance_tips/#Performance-Tips">Performance Tips</a>).</li><li><code>showprogress::Bool = false</code> whether a progressbar will be displayed to indicate % runs finished.</li></ul><p>All other keywords are propagated into <a href="#Agents.run!"><code>run!</code></a>. Furthermore, <code>n</code> is also a keyword here, that is given to <a href="#Agents.run!"><code>run!</code></a> as argument. Naturally, the number of time steps <code>n</code> and at least one of <code>adata, mdata</code> are mandatory. The <code>adata, mdata</code> lists shouldn&#39;t contain the parameters that are already in the <code>parameters</code> dictionary to avoid duplication.</p><p><strong>Example</strong></p><p>A runnable example that uses <code>paramscan</code> is shown in <a href="@ref">Schelling&#39;s segregation model</a>. There, we define</p><pre><code class="language-julia hljs">function initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)
    space = GridSpaceSingle(griddims, periodic = false)
    properties = Dict(:min_to_be_happy =&gt; min_to_be_happy)
    model = StandardABM(SchellingAgent, space;
                properties = properties, scheduler = Schedulers.randomly)
    for n in 1:numagents
        add_agent_single!(SchellingAgent, model, n &lt; numagents / 2 ? 1 : 2)
    end
    return model
end</code></pre><p>and do a parameter scan by doing:</p><pre><code class="language-julia hljs">happyperc(moods) = count(moods) / length(moods)
adata = [(:mood, happyperc)]

parameters = Dict(
    :min_to_be_happy =&gt; collect(2:5), # expanded
    :numagents =&gt; [200, 300],         # expanded
    :griddims =&gt; (20, 20),            # not Vector = not expanded
)

adf, _ = paramscan(parameters, initialize; adata, n = 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/paramscan.jl#L3-L77">source</a></section></article><h3 id="Manual-data-collection"><a class="docs-heading-anchor" href="#Manual-data-collection">Manual data collection</a><a id="Manual-data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Manual-data-collection" title="Permalink"></a></h3><p>The central simulation function is <a href="#Agents.run!"><code>run!</code></a>. Here are some functions that aid in making custom data collection loops, instead of using the <code>run!</code> function:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.init_agent_dataframe" href="#Agents.init_agent_dataframe"><code>Agents.init_agent_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_agent_dataframe(model, adata) → agent_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L442-L445">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.collect_agent_data!" href="#Agents.collect_agent_data!"><code>Agents.collect_agent_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collect_agent_data!(df, model, properties; obtainer = identity)</code></pre><p>Collect and add agent data into <code>df</code> (see <a href="#Agents.run!"><code>run!</code></a> for the dispatch rules of <code>properties</code> and <code>obtainer</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L544-L548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.init_model_dataframe" href="#Agents.init_model_dataframe"><code>Agents.init_model_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">init_model_dataframe(model, mdata) → model_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_model_data!"><code>collect_model_data!</code></a>. <code>mdata</code> can be a <code>Vector</code> or generator <code>Function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L502-L506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.collect_model_data!" href="#Agents.collect_model_data!"><code>Agents.collect_model_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collect_model_data!(df, model, properties, obtainer = identity)</code></pre><p>Same as <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a> but for model data instead. <code>properties</code> can be a <code>Vector</code> or generator <code>Function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L589-L593">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.dataname" href="#Agents.dataname"><code>Agents.dataname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dataname(k) → name</code></pre><p>Return the name of the column of the <code>i</code>-th collected data where <code>k = adata[i]</code> (or <code>mdata[i]</code>). <code>dataname</code> also accepts tuples with aggregate and conditional values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L742-L748">source</a></section></article><p>For example, the core loop of <code>run!</code> is just</p><pre><code class="language-julia hljs">df_agent = init_agent_dataframe(model, adata)
df_model = init_model_dataframe(model, mdata)

t0 = abmtime(model)
t = t0
while until(t, t0, n, model)
  if should_we_collect(t, model, when)
      collect_agent_data!(df_agent, model, adata)
  end
  if should_we_collect(t, model, when_model)
      collect_model_data!(df_model, model, mdata)
  end
  step!(model, 1)
  t = abmtime(model)
end
return df_agent, df_model</code></pre><p>(here <code>until</code> and <code>should_we_collect</code> are internal functions)</p><h2 id="Schedulers"><a class="docs-heading-anchor" href="#Schedulers">Schedulers</a><a id="Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Schedulers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers" href="#Agents.Schedulers"><code>Agents.Schedulers</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Schedulers</code></pre><p>Submodule containing all predefined schedulers of Agents.jl that can be used with <a href="#Agents.StandardABM"><code>StandardABM</code></a>.</p><p>Schedulers have a very simple interface. They are functions that take as an input the ABM and return an iterator over agent IDs: <code>f(model) -&gt; iterator</code>. Notice that this iterator can be non-allocated specialized type or just a standard vector of IDs.</p><p>Schedulers have many purposes:</p><ol><li>Can be given in <a href="#Agents.StandardABM"><code>StandardABM</code></a> as a default scheduler. This functionality is only meaningful when the <code>agent_step!</code> has been configured. The function <code>schedule(model)</code> will return the scheduled IDs.</li><li>Can be used by a user when performing <a href="@ref manual_scheduling">manual scheduling</a> in case <code>agent_step!</code> has not been configured.</li><li>Can be used to globally filter agents by type/property/whatever. For example, one can use the <a href="#Agents.Schedulers.ByProperty"><code>ByProperty</code></a> scheduler to simply obtain the list of all agent IDs that satisfy a particular property.</li></ol><p>See also <a href="#Advanced-scheduling">Advanced scheduling</a> for making more advanced schedulers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L12-L35">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>schedule</code>. Check Documenter&#39;s build log for details.</p></div></div><h3 id="Predefined-schedulers"><a class="docs-heading-anchor" href="#Predefined-schedulers">Predefined schedulers</a><a id="Predefined-schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-schedulers" title="Permalink"></a></h3><p>Some useful schedulers are available below as part of the Agents.jl API:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers.fastest" href="#Agents.Schedulers.fastest"><code>Agents.Schedulers.fastest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Schedulers.fastest</code></pre><p>A scheduler that orders all agent IDs in the fastest way possible, which is the default order dictated by the agent container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers.ByID" href="#Agents.Schedulers.ByID"><code>Agents.Schedulers.ByID</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schedulers.ByID()</code></pre><p>A scheduler that orders all agent IDs by their integer value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers.Randomly" href="#Agents.Schedulers.Randomly"><code>Agents.Schedulers.Randomly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schedulers.Randomly()</code></pre><p>A scheduler that randomly orders all agent IDs. Different random ordering is used at each different step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers.Partially" href="#Agents.Schedulers.Partially"><code>Agents.Schedulers.Partially</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schedulers.Partially(p)</code></pre><p>A scheduler that orders only <code>p</code> percentage of randomly chosen agent IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers.ByProperty" href="#Agents.Schedulers.ByProperty"><code>Agents.Schedulers.ByProperty</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schedulers.ByProperty(property)</code></pre><p>A scheduler that orders agent IDs by their <code>property</code>, with agents with greater <code>property</code> being ordered first. <code>property</code> can be a <code>Symbol</code>, which just dictates which field of the agents to compare, or a function which inputs an agent and outputs a real number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Schedulers.ByType" href="#Agents.Schedulers.ByType"><code>Agents.Schedulers.ByType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Schedulers.ByType(shuffle_types::Bool, shuffle_agents::Bool, agent_union)</code></pre><p>A scheduler useful only for mixed agent models using <code>Union</code> types.</p><ul><li>Setting <code>shuffle_types = true</code> groups by agent type, but randomizes the type order. Otherwise returns agent IDs grouped in order of appearance in the <code>Union</code>.</li><li><code>shuffle_agents = true</code> randomizes the order of agents within each group, <code>false</code> returns the default order of the container (equivalent to <a href="#Agents.Schedulers.fastest"><code>Schedulers.fastest</code></a>).</li><li><code>agent_union</code> is a <code>Union</code> of all valid agent types (as passed to <a href="@ref"><code>ABM</code></a>)</li></ul><pre><code class="nohighlight hljs">Schedulers.ByType((C, B, A), shuffle_agents::Bool)</code></pre><p>A scheduler that orders agent IDs by type in specified order (since <code>Union</code>s are not order preserving). <code>shuffle_agents = true</code> randomizes the order of agents within each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/schedulers.jl#L151-L167">source</a></section></article><h3 id="Advanced-scheduling"><a class="docs-heading-anchor" href="#Advanced-scheduling">Advanced scheduling</a><a id="Advanced-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-scheduling" title="Permalink"></a></h3><p>You can use <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">Function-like objects</a> to make your scheduling possible of arbitrary events. For example, imagine that after the <code>n</code>-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define</p><pre><code class="language-julia hljs">mutable struct MyScheduler
    n::Int # step number
    w::Float64
end</code></pre><p>and then define a calling method for it like so</p><pre><code class="language-julia hljs">function (ms::MyScheduler)(model::ABM)
    ms.n += 1 # increment internal counter by 1 each time its called
              # be careful to use a *new* instance of this scheduler when plotting!
    if ms.n &lt; 10
        return allids(model) # order doesn&#39;t matter in this case
    else
        ids = collect(allids(model))
        # filter all ids whose agents have `w` less than some amount
        filter!(id -&gt; model[id].w &lt; ms.w, ids)
        return ids
    end
end</code></pre><p>and pass it to e.g. <code>step!</code> by initializing it</p><pre><code class="language-julia hljs">ms = MyScheduler(100, 0.5)
step!(model, agentstep, modelstep, 100; scheduler = ms)</code></pre><h3 id="How-to-use-Distributed"><a class="docs-heading-anchor" href="#How-to-use-Distributed">How to use <code>Distributed</code></a><a id="How-to-use-Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-Distributed" title="Permalink"></a></h3><p>To use the <code>parallel=true</code> option of <a href="#Agents.ensemblerun!"><code>ensemblerun!</code></a> you need to load <code>Agents</code> and define your fundamental types at all processors. How to do this is shown in <a href="@ref">Ensembles and distributed computing</a> section of Schelling&#39;s Segregation Model example. See also the <a href="../performance_tips/#Performance-Tips">Performance Tips</a> page for parallelization.</p><h2 id="Path-finding"><a class="docs-heading-anchor" href="#Path-finding">Path-finding</a><a id="Path-finding-1"></a><a class="docs-heading-anchor-permalink" href="#Path-finding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding" href="#Agents.Pathfinding"><code>Agents.Pathfinding</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">Pathfinding</code></pre><p>Submodule containing functionality for path-finding based on the A* algorithm. Currently available for <a href="#Agents.GridSpace"><code>GridSpace</code></a> and <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. Discretization of <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> is taken care of internally.</p><p>You can enable path-finding and set its options by creating an instance of a <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a> struct. This must be passed to the relevant pathfinding functions during the simulation. Call <a href="#Agents.plan_route!"><code>plan_route!</code></a> to set the destination for an agent. This triggers the algorithm to calculate a path from the agent&#39;s current position to the one specified. You can alternatively use <a href="#Agents.plan_best_route!"><code>plan_best_route!</code></a> to choose the best target from a list. Once a target has been set, you can move an agent one step along its precalculated path using the <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> function.</p><p>Refer to the <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/maze/">Maze Solver</a>, <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/runners/">Mountain Runners</a> and <a href="@ref">Rabbit, Fox, Hawk</a> examples using path-finding and see the available functions below as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/Pathfinding.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.AStar" href="#Agents.Pathfinding.AStar"><code>Agents.Pathfinding.AStar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.AStar(space; kwargs...)</code></pre><p>Enables pathfinding for agents in the provided <code>space</code> (which can be a <a href="#Agents.GridSpace"><code>GridSpace</code></a> or <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>) using the A* algorithm. This struct must be passed into any pathfinding functions.</p><p>For <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>, a walkmap or instance of <a href="#Agents.Pathfinding.PenaltyMap"><code>PenaltyMap</code></a> must be provided to specify the level of discretisation of the space.</p><p><strong>Keywords</strong></p><ul><li><code>diagonal_movement = true</code> specifies if movement can be to diagonal neighbors of a tile, or only orthogonal neighbors. Only available for <a href="#Agents.GridSpace"><code>GridSpace</code></a></li><li><code>admissibility = 0.0</code> allows the algorithm to approximate paths to speed up pathfinding. A value of <code>admissibility</code> allows paths with at most <code>(1+admissibility)</code> times the optimal length.</li><li><code>walkmap = trues(spacesize(space))</code> specifies the (un)walkable positions of the space. If specified, it should be a <code>BitArray</code> of the same size as the corresponding <code>GridSpace</code>. By default, agents can walk anywhere in the space.</li><li><code>cost_metric = DirectDistance{D}()</code> is an instance of a cost metric and specifies the metric used to approximate the distance between any two points.</li></ul><p>Utilization of all features of <code>AStar</code> occurs in the <a href="../examples/rabbit_fox_hawk/#3D-Mixed-Agent-Ecosystem-with-Pathfinding">3D Mixed-Agent Ecosystem with Pathfinding</a> example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar.jl#L40-L63">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.penaltymap" href="#Agents.Pathfinding.penaltymap"><code>Agents.Pathfinding.penaltymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.penaltymap(pathfinder)</code></pre><p>Return the penalty map of a <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a> if the <a href="#Agents.Pathfinding.PenaltyMap"><code>Pathfinding.PenaltyMap</code></a> metric is in use, <code>nothing</code> otherwise.</p><p>It is possible to mutate the map directly, for example <code>Pathfinding.penaltymap(pathfinder)[15, 40] = 115</code> or <code>Pathfinding.penaltymap(pathfinder) .= rand(50, 50)</code>. If this is mutated, a new path needs to be planned using <a href="#Agents.plan_route!"><code>plan_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar.jl#L223-L232">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.nearby_walkable" href="#Agents.Pathfinding.nearby_walkable"><code>Agents.Pathfinding.nearby_walkable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.nearby_walkable(position, model::ABM{&lt;:GridSpace{D}}, pathfinder::AStar{D}, r = 1)</code></pre><p>Return an iterator over all <a href="#Agents.nearby_positions"><code>nearby_positions</code></a> within &quot;radius&quot; <code>r</code> of the given <code>position</code> (excluding <code>position</code>), which are walkable as specified by the given <code>pathfinder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_grid.jl#L71-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.random_walkable" href="#Agents.Pathfinding.random_walkable"><code>Agents.Pathfinding.random_walkable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.random_walkable(model, pathfinder::AStar{D})</code></pre><p>Return a random position in the given <code>model</code> that is walkable as specified by the given <code>pathfinder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_grid.jl#L80-L84">source</a></section><section><div><pre><code class="language-julia hljs">Pathfinding.random_walkable(pos, model::ABM{&lt;:ContinuousSpace{D}}, pathfinder::AStar{D}, r = 1.0)</code></pre><p>Return a random position within radius <code>r</code> of <code>pos</code> which is walkable, as specified by <code>pathfinder</code>. Return <code>pos</code> if no such position exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/astar_continuous.jl#L188-L192">source</a></section></article><h3 id="Pathfinding-Metrics"><a class="docs-heading-anchor" href="#Pathfinding-Metrics">Pathfinding Metrics</a><a id="Pathfinding-Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Pathfinding-Metrics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.DirectDistance" href="#Agents.Pathfinding.DirectDistance"><code>Agents.Pathfinding.DirectDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.DirectDistance{D}([direction_costs::Vector{Int}]) &lt;: CostMetric{D}</code></pre><p>Distance is approximated as the shortest path between the two points, provided the <code>walkable</code> property of <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a> allows. Optionally provide a <code>Vector{Int}</code> that represents the cost of going from a tile to the neighboring tile on the <code>i</code> dimensional diagonal (default is <code>10√i</code>).</p><p>If <code>diagonal_movement=false</code> in <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a>, neighbors in diagonal positions will be excluded. Cost defaults to the first value of the provided vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/metrics.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.MaxDistance" href="#Agents.Pathfinding.MaxDistance"><code>Agents.Pathfinding.MaxDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.MaxDistance{D}() &lt;: CostMetric{D}</code></pre><p>Distance between two tiles is approximated as the maximum of absolute difference in coordinates between them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/metrics.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.Pathfinding.PenaltyMap" href="#Agents.Pathfinding.PenaltyMap"><code>Agents.Pathfinding.PenaltyMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pathfinding.PenaltyMap(pmap::Array{Int,D} [, base_metric::CostMetric]) &lt;: CostMetric{D}</code></pre><p>Distance between two positions is the sum of the shortest distance between them and the absolute difference in penalty.</p><p>A penalty map (<code>pmap</code>) is required. For pathfinding in <a href="#Agents.GridSpace"><code>GridSpace</code></a>, this should be the same dimensions as the space. For pathfinding in <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>, the size of this map determines the granularity of the underlying grid, and should agree with the size of the <code>walkable</code> map.</p><p>Distance is calculated using <a href="#Agents.Pathfinding.DirectDistance"><code>Pathfinding.DirectDistance</code></a> by default, and can be changed by specifying <code>base_metric</code>.</p><p>An example usage can be found in <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/runners/">Mountain Runners</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/pathfinding/metrics.jl#L41-L55">source</a></section></article><p>Building a custom metric is straightforward, if the provided ones do not suit your purpose. See the <a href="../devdocs/#Developer-Docs">Developer Docs</a> for details.</p><h2 id="Save,-Load,-Checkpoints"><a class="docs-heading-anchor" href="#Save,-Load,-Checkpoints">Save, Load, Checkpoints</a><a id="Save,-Load,-Checkpoints-1"></a><a class="docs-heading-anchor-permalink" href="#Save,-Load,-Checkpoints" title="Permalink"></a></h2><p>There may be scenarios where interacting with data in the form of files is necessary. The following functions provide an interface to save/load data to/from files.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.AgentsIO.save_checkpoint" href="#Agents.AgentsIO.save_checkpoint"><code>Agents.AgentsIO.save_checkpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AgentsIO.save_checkpoint(filename, model::ABM)</code></pre><p>Write the entire <code>model</code> to file specified by <code>filename</code>. The following points should be considered before using this functionality:</p><ul><li>OpenStreetMap data is not saved. The path to the map should be specified when loading the model using the <code>map</code> keyword of <a href="#Agents.AgentsIO.load_checkpoint"><code>AgentsIO.load_checkpoint</code></a>.</li><li>Functions are not saved, including stepping functions, schedulers, and <code>update_vel!</code>. The last two can be provided to <a href="#Agents.AgentsIO.load_checkpoint"><code>AgentsIO.load_checkpoint</code></a> using the appropriate keyword arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/io/jld2_integration.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.AgentsIO.load_checkpoint" href="#Agents.AgentsIO.load_checkpoint"><code>Agents.AgentsIO.load_checkpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AgentsIO.load_checkpoint(filename; kwargs...)</code></pre><p>Load the model saved to the file specified by <code>filename</code>.</p><p><strong>Keywords</strong></p><ul><li><code>scheduler = Schedulers.fastest</code> specifies what scheduler should be used for the model.</li><li><code>warn = true</code> can be used to disable warnings from type checks on the   agent type.</li></ul><p><a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> specific:</p><ul><li><code>update_vel!</code> specifies a function that should be used to update each agent&#39;s velocity before it is moved. Refer to <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> for details.</li></ul><p><a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a> specific:</p><ul><li><code>map</code> is a path to the OpenStreetMap to be used for the space. This is a required parameter if the space is <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>.</li><li><code>use_cache = false</code>, <code>trim_to_connected_graph = true</code> refer to <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/io/jld2_integration.jl#L217-L235">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.AgentsIO.populate_from_csv!" href="#Agents.AgentsIO.populate_from_csv!"><code>Agents.AgentsIO.populate_from_csv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AgentsIO.populate_from_csv!(model, filename [, agent_type, col_map]; row_number_is_id, kwargs...)</code></pre><p>Populate the given <code>model</code> using CSV data contained in <code>filename</code>. Use <code>agent_type</code> to specify the type of agent to create (In the case of multi-agent models) or a function that returns an agent to add to the model. The CSV row is splatted into the <code>agent_type</code> constructor/function.</p><p><code>col_map</code> is a <code>Dict{Symbol,Int}</code> specifying a mapping of keyword-arguments to row number. If <code>col_map</code> is specified, the specified data is splatted as keyword arguments.</p><p>The keyword <code>row_number_is_id = false</code> specifies whether the row number will be passed as the first argument (or as <code>id</code> keyword) to <code>agent_type</code>.</p><p>Any other keyword arguments are forwarded to <code>CSV.Rows</code>. If the <code>types</code> keyword is not specified and <code>agent_type</code> is a struct, then the mapping from struct field to type will be used. <code>Tuple{...}</code> fields will be suffixed with <code>_1</code>, <code>_2</code>, ... similarly to <a href="#Agents.AgentsIO.dump_to_csv"><code>AgentsIO.dump_to_csv</code></a></p><p>For example,</p><pre><code class="nohighlight hljs">struct Foo &lt;: AbstractAgent
    id::Int
    pos::NTuple{2,Int}
    foo::Tuple{Int,String}
end

model = StandardABM(Foo, ...)
AgentsIO.populate_from_csv!(model, &quot;test.csv&quot;)</code></pre><p>Here, <code>types</code> will be inferred to be</p><pre><code class="nohighlight hljs">Dict(
    :id =&gt; Int,
    :pos_1 =&gt; Int,
    :pos_2 =&gt; Int,
    :foo_1 =&gt; Int,
    :foo_2 =&gt; String,
)</code></pre><p>It is not necessary for all these fields to be present as columns in the CSV. Any column names that match will be converted to the appropriate type. There should exist a constructor for <code>Foo</code> taking the appropriate combination of fields as parameters.</p><p>If <code>&quot;test.csv&quot;</code> contains the following columns: <code>pos_1, pos_2, foo_1, foo_2</code>, then <code>model</code> can be populated as <code>AgentsIO.populate_from_csv!(model, &quot;test.csv&quot;; row_number_is_id = true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/io/csv_integration.jl#L4-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.AgentsIO.dump_to_csv" href="#Agents.AgentsIO.dump_to_csv"><code>Agents.AgentsIO.dump_to_csv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">AgentsIO.dump_to_csv(filename, agents [, fields]; kwargs...)</code></pre><p>Dump <code>agents</code> to the CSV file specified by <code>filename</code>. <code>agents</code> is any iterable sequence of types, such as from <a href="#Agents.allagents"><code>allagents</code></a>. <code>fields</code> is an iterable sequence of <code>Symbol</code>s specifying which fields of each agent are dumped. If not explicitly specified, it is automatically inferred using <code>eltype(agents)</code>. All <code>kwargs...</code> are forwarded to <code>CSV.write</code>.</p><p>All <code>Tuple{...}</code> fields are flattened to multiple columns suffixed by <code>_1</code>, <code>_2</code>... similarly to <a href="#Agents.AgentsIO.populate_from_csv!"><code>AgentsIO.populate_from_csv!</code></a></p><p>For example,</p><pre><code class="nohighlight hljs">struct Foo &lt;: AbstractAgent
    id::Int
    pos::NTuple{2,Int}
    foo::Tuple{Int,String}
end

model = StandardABM(Foo, ...)
...
AgentsIO.dump_to_csv(&quot;test.csv&quot;, allagents(model))</code></pre><p>The resultant <code>&quot;test.csv&quot;</code> file will contain the following columns: <code>id</code>, <code>pos_1</code>, <code>pos_2</code>, <code>foo_1</code>, <code>foo_2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/submodules/io/csv_integration.jl#L102-L128">source</a></section></article><p>It is also possible to write data to file at predefined intervals while running your model, instead of storing it in memory:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.offline_run!" href="#Agents.offline_run!"><code>Agents.offline_run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">offline_run!(model, n::Integer; kwargs...)
offline_run!(model, f::Function; kwargs...)</code></pre><p>Do the same as <a href="@ref"><code>run</code></a>, but instead of collecting the whole run into an in-memory dataframe, write the output to a file after collecting data <code>writing_interval</code> times and empty the dataframe after each write. Useful when the amount of collected data is expected to exceed the memory available during execution.</p><p><strong>Keywords</strong></p><ul><li><code>backend=:csv</code> : backend to use for writing data. Currently supported backends: <code>:csv</code>, <code>:arrow</code></li><li><code>adata_filename=&quot;adata.$backend&quot;</code> : a file to write agent data on. Appends to the file if it already exists, otherwise creates the file.</li><li><code>mdata_filename=&quot;mdata.$backend&quot;</code>: a file to write the model data on. Appends to the file if it already exists, otherwise creates the file.</li><li><code>writing_interval=1</code> : write to file every <code>writing_interval</code> times data collection is triggered. If the <code>when</code> keyword is not set, this corresponds to writing to file every <code>writing_interval</code> steps; otherwise, the data will be written every <code>writing_interval</code> times the <code>when</code> condition is satisfied (the same applies to <code>when_model</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/simulations/collect.jl#L215-L237">source</a></section></article><p>In case you require custom serialization for model properties, refer to the <a href="../devdocs/#Developer-Docs">Developer Docs</a> for details.</p><h2 id="Visualizations"><a class="docs-heading-anchor" href="#Visualizations">Visualizations</a><a id="Visualizations-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmplot" href="#Agents.abmplot"><code>Agents.abmplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmplot(model::ABM; kwargs...) → fig, ax, abmobs
abmplot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmobs</code></pre><p>Plot an agent based model by plotting each individual agent as a marker and using the agent&#39;s position field as its location on the plot. The same function is used to make custom composite plots and animations for the model evolution using the returned <code>abmobs</code>. <code>abmplot</code> is also used to launch interactive GUIs for evolving agent based models, see &quot;Interactivity&quot; below.</p><p>See also <a href="#Agents.abmvideo"><code>abmvideo</code></a> and <a href="#Agents.abmexploration"><code>abmexploration</code></a>.</p><p><strong>Keyword arguments</strong></p><p><strong>Agent related</strong></p><ul><li><p><code>agent_color, agent_size, agent_marker</code> : These three keywords decide the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a <em>function</em>, which takes as an input a single agent and outputs the corresponding value. If the model uses a <code>GraphSpace</code>, <code>agent_color, agent_size, agent_marker</code> functions instead take an <em>iterable of agents</em> in each position (i.e. node of the graph).</p><p>Using constants: <code>agent_color = &quot;#338c54&quot;, agent_size = 15, agent_marker = :diamond</code></p><p>Using functions:</p><pre><code class="language-julia hljs">agent_color(a) = a.status == :S ? &quot;#2b2b33&quot; : a.status == :I ? &quot;#bf2642&quot; : &quot;#338c54&quot;
agent_size(a) = 10rand()
agent_marker(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect</code></pre><p>Notice that for 2D models, <code>agent_marker</code> can be/return a <code>Makie.Polygon</code> instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent&#39;s position when creating the polygon. In this case, the keyword <code>as</code> is meaningless, as each polygon has its own size. Use the functions <code>scale, rotate_polygon</code> to transform this polygon.</p><p>3D models currently do not support having different markers. As a result, <code>agent_marker</code> cannot be a function. It should be a <code>Mesh</code> or 3D primitive (such as <code>Sphere</code> or <code>Rect3D</code>).</p></li><li><p><code>offset = nothing</code> : If not <code>nothing</code>, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent&#39;s position (which matters only if there is overlap).</p></li><li><p><code>agentsplotkwargs = ()</code> : Additional keyword arguments propagated to the function that  plots the agents (typically <code>scatter!</code>).</p></li></ul><p><strong>Preplot related</strong></p><ul><li><code>heatarray = nothing</code> : A keyword that plots a model property (that is a matrix) as a heatmap over the space. Its values can be standard data accessors given to functions like <code>run!</code>, i.e. either a symbol (directly obtain model property) or a function of the model. If the space is <code>AbstractGridSpace</code> then matrix must be the same size as the underlying space. For <code>ContinuousSpace</code> any size works and will be plotted over the space extent. For example <code>heatarray = :temperature</code> is used in the Daisyworld example. But you could also define <code>f(model) = create_matrix_from_model...</code> and set <code>heatarray = f</code>. The heatmap will be updated automatically during model evolution in videos and interactive applications.</li><li><code>heatkwargs = NamedTuple()</code> : Keywords given to <code>Makie.heatmap</code> function if <code>heatarray</code> is not nothing.</li><li><code>add_colorbar = true</code> : Whether or not a Colorbar should be added to the right side of the heatmap if <code>heatarray</code> is not nothing. It is strongly recommended to use <code>abmplot</code> instead of the <code>abmplot!</code> method if you use <code>heatarray</code>, so that a colorbar can be placed naturally.</li><li><code>static_preplot!</code> : A function <code>f(ax, abmplot)</code> that plots something after the heatmap but before the agents.</li><li><code>spaceplotkwargs = NamedTuple()</code> : keywords utilized when plotting the space.  Directly passed to<ul><li><code>OSMMakie.osmplot!</code> if model space is <code>OpenStreetMapSpace</code>.</li><li><a href="https://graph.makie.org/stable/#GraphMakie.graphplot"><code>GraphMakie.graphplot!</code></a></li></ul>if model space is <code>GraphSpace</code>.</li><li><code>adjust_aspect = true</code>: Adjust axis aspect ratio to be the model&#39;s space aspect ratio.</li><li><code>enable_space_checks = true</code>: Set to <code>false</code> to disable checks related to the model space.</li></ul><p>The stand-alone function <code>abmplot</code> also takes two optional <code>NamedTuple</code>s named <code>figure</code> and <code>axis</code> which can be used to change the automatically created <code>Figure</code> and <code>Axis</code> objects.</p><p><strong>Interactivity</strong></p><p><strong>Evolution related</strong></p><ul><li><code>add_controls::Bool</code>: If <code>true</code>, <code>abmplot</code> switches to &quot;interactive application&quot; mode. This is by default <code>true</code> if the model contains either <code>agent_step!</code> or <code>model_step!</code>. The model evolves interactively using <code>Agents.step!</code>. The application has the following interactive elements:<ol><li>&quot;step&quot;: advances the simulation once for <code>spu</code> steps.</li><li>&quot;run&quot;: starts/stops the continuous evolution of the model.</li><li>&quot;reset model&quot;: resets the model to its initial state from right after starting the interactive application.</li><li>Two sliders control the animation speed: &quot;spu&quot; decides how many model steps should be done before the plot is updated, and &quot;sleep&quot; the <code>sleep()</code> time between updates.</li></ol></li><li><code>enable_inspection = add_controls</code>: If <code>true</code>, enables agent inspection on mouse hover.</li><li><code>spu = 1:50</code>: The values of the &quot;spu&quot; slider.</li><li><code>params = Dict()</code> : This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of <code>params</code> is a pair of <code>Symbol</code> to an <code>AbstractVector</code>, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only propagated to the actual model after a press of the &quot;update&quot; button.</li></ul><p><strong>Data collection related</strong></p><ul><li><code>adata, mdata, when</code>: Same as the keyword arguments of <code>Agents.run!</code>. If either or both <code>adata, mdata</code> are given, data are collected and stored in the <code>abmobs</code>, see <a href="#Agents.ABMObservable"><code>ABMObservable</code></a>. The same keywords provide the data plots of <a href="#Agents.abmexploration"><code>abmexploration</code></a>. This also adds the button &quot;clear data&quot; which deletes previously collected agent and model data by emptying the underlying <code>DataFrames</code> <code>adf</code>/<code>mdf</code>. Reset model and clear data are independent processes.</li></ul><p>See the documentation string of <a href="#Agents.ABMObservable"><code>ABMObservable</code></a> for custom interactive plots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L1-L104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmplot!" href="#Agents.abmplot!"><code>Agents.abmplot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmplot!(ax::Axis, model::ABM; kwargs...)</code></pre><p>See <code>abmplot</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L106-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmexploration" href="#Agents.abmexploration"><code>Agents.abmexploration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmexploration(model::ABM; alabels, mlabels, kwargs...)</code></pre><p>Open an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires <code>Agents</code>.</p><p>The application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in <a href="#Agents.abmplot"><code>abmplot</code></a>, and the <code>model</code> argument as well as splatted <code>kwargs</code> are propagated there as-is. This convencience function <em>only works for aggregated agent data</em>.</p><p>Calling <code>abmexploration</code> returns: <code>fig::Figure, abmobs::ABMObservable</code>. So you can save and/or further modify the figure and it is also possible to access the collected data (if any) via the <code>ABMObservable</code>.</p><p>Clicking the &quot;reset&quot; button will add a red vertical line to the data plots for visual guidance.</p><p><strong>Keywords arguments (in addition to those in <code>abmplot</code>)</strong></p><ul><li><code>alabels, mlabels</code>: If data are collected from agents or the model with <code>adata, mdata</code>, the corresponding plots&#39; y-labels are automatically named after the collected data. It is also possible to provide <code>alabels, mlabels</code> (vectors of strings with exactly same length as <code>adata, mdata</code>), and these labels will be used instead.</li><li><code>figure = NamedTuple()</code>: Keywords to customize the created Figure.</li><li><code>axis = NamedTuple()</code>: Keywords to customize the created Axis.</li><li><code>plotkwargs = NamedTuple()</code>: Keywords to customize the styling of the resulting <a href="https://makie.juliaplots.org/dev/examples/plotting_functions/scatterlines/index.html"><code>scatterlines</code></a> plots.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L166-L195">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.abmvideo" href="#Agents.abmvideo"><code>Agents.abmvideo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">abmvideo(file, model; kwargs...)</code></pre><p>This function exports the animated time evolution of an agent based model into a video saved at given path <code>file</code>, by recording the behavior of the interactive version of <a href="#Agents.abmplot"><code>abmplot</code></a> (without sliders). The plotting is identical as in <a href="#Agents.abmplot"><code>abmplot</code></a> and applicable keywords are propagated.</p><p><strong>Keywords</strong></p><ul><li><code>spf = 1</code>: Steps-per-frame, i.e. how many times to step the model before recording a new frame.</li><li><code>framerate = 30</code>: The frame rate of the exported video.</li><li><code>frames = 300</code>: How many frames to record in total, including the starting frame.</li><li><code>title = &quot;&quot;</code>: The title of the figure.</li><li><code>showstep = true</code>: If current step should be shown in title.</li><li><code>figure = NamedTuple()</code>: Figure related keywords (e.g. resolution, backgroundcolor).</li><li><code>axis = NamedTuple()</code>: Axis related keywords (e.g. aspect).</li><li><code>recordkwargs = NamedTuple()</code>: Keyword arguments given to <code>Makie.record</code>. You can use <code>(compression = 1, profile = &quot;high&quot;)</code> for a higher quality output, and prefer the <code>CairoMakie</code> backend. (compression 0 results in videos that are not playable by some software)</li><li><code>kwargs...</code>: All other keywords are propagated to <a href="#Agents.abmplot"><code>abmplot</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L199-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.ABMObservable" href="#Agents.ABMObservable"><code>Agents.ABMObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ABMObservable(model; adata, mdata, when) → abmobs</code></pre><p><code>abmobs</code> contains all information necessary to step an agent based model interactively. It is also returned by <a href="#Agents.abmplot"><code>abmplot</code></a>.</p><p>Calling <code>Agents.step!(abmobs, n)</code> will step the model for <code>n</code> using the provided <code>agent_step!, model_step!</code> cotained in the model as in <a href="@ref"><code>Agents.step!</code></a>.</p><p>The fields <code>abmobs.model, abmobs.adf, abmobs.mdf</code> are <em>observables</em> that contain the <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, and the agent and model dataframes with collected data. Data are collected as described in <a href="#Agents.run!"><code>Agents.run!</code></a> using the <code>adata, mdata, when</code> keywords. All three observables are updated on stepping (when it makes sense). The field <code>abmobs.s</code> is also an observable containing the current step number.</p><p>All plotting and interactivity should be defined by <code>lift</code>ing these observables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L136-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.add_interaction!" href="#Agents.add_interaction!"><code>Agents.add_interaction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_interaction!(ax)
add_interaction!(ax, p::_ABMPlot)</code></pre><p>Adds model control buttons and parameter sliders according to the plotting parameters  <code>add_controls</code> (if true) and <code>params</code> (if not empty). Buttons and sliders are placed next to each other in a new layout position below the  position of <code>ax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.translate_polygon" href="#Agents.translate_polygon"><code>Agents.translate_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate_polygon(p::Polygon, point)</code></pre><p>Translate given polygon by given <code>point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L247-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.scale_polygon" href="#Agents.scale_polygon"><code>Agents.scale_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">scale_polygon(p::Polygon, s)</code></pre><p>Scale given polygon by <code>s</code>, assuming polygon&#39;s center of reference is the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L257-L260">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Agents.rotate_polygon" href="#Agents.rotate_polygon"><code>Agents.rotate_polygon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rotate_polygon(p::Polygon, θ)</code></pre><p>Rotate given polygon counter-clockwise by <code>θ</code> (in radians).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/6ea4453f771df0a95f876deec2281891ffd58672/src/visualizations.jl#L252-L255">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« More Examples for Agents.jl</a><a class="docs-footer-nextpage" href="../examples/agents_visualizations/">Plotting and Interactivity »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 8 March 2024 12:37">Friday 8 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
