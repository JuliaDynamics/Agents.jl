<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plotting and Interactivity · Agents.jl</title><meta name="title" content="Plotting and Interactivity · Agents.jl"/><meta property="og:title" content="Plotting and Interactivity · Agents.jl"/><meta property="twitter:title" content="Plotting and Interactivity · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../flock/">Flocking model</a></li><li><a class="tocitem" href="../zombies/">Zombie Outbreak in an Open Street Map City</a></li><li><a class="tocitem" href="../predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../event_rock_paper_scissors/">Spatial rock-paper-scissors (event based)</a></li><li><a class="tocitem" href="../rl_boltzmann/">Boltzmann Wealth Model with Reinforcement Learning</a></li><li><a class="tocitem" href="../">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li class="is-active"><a class="tocitem" href>Plotting and Interactivity</a><ul class="internal"><li><a class="tocitem" href="#Static-plotting-of-ABMs"><span>Static plotting of ABMs</span></a></li><li><a class="tocitem" href="#Interactive-ABM-Applications"><span>Interactive ABM Applications</span></a></li><li><a class="tocitem" href="#ABM-Videos"><span>ABM Videos</span></a></li><li><a class="tocitem" href="#Creating-custom-ABM-plots"><span>Creating custom ABM plots</span></a></li></ul></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../celllistmap/">CellListMap.jl</a></li><li><a class="tocitem" href="../delaunay/">DelaunayTriangulation.jl</a></li><li><a class="tocitem" href="../measurements/">Uncertanty Propagation</a></li></ul></li><li><a class="tocitem" href="../../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Plotting and Interactivity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plotting and Interactivity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/agents_visualizations.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="vis_tutorial"><a class="docs-heading-anchor" href="#vis_tutorial">Visualizations and Animations for Agent Based Models</a><a id="vis_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#vis_tutorial" title="Permalink"></a></h1><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><p>This page describes functions that can be used with the <a href="https://docs.makie.org/stable/">Makie</a> plotting ecosystem to animate and interact with agent based models. All the functionality described here uses Julia&#39;s package extensions and therefore comes into scope once <code>Makie</code> (or any of its backends such as <code>CairoMakie</code>) gets loaded.</p><p>The animation at the start of the page is created using the code of this page, see below.</p><p>The docs are built using versions:</p><pre><code class="language-julia hljs">import Pkg
Pkg.status(
    [&quot;Agents&quot;, &quot;CairoMakie&quot;];
    mode = Pkg.PKGMODE_MANIFEST, io = stdout
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr32"><span class="sgr1">Status</span></span> `~/work/Agents.jl/Agents.jl/docs/Manifest.toml`
  <span class="sgr90">[46ada45e] </span>Agents v7.0.0 `~/work/Agents.jl/Agents.jl`
<span class="sgr32">⌃</span> <span class="sgr90">[13f3f980] </span>CairoMakie v0.13.10
<span class="sgr36"><span class="sgr1">Info</span></span> Packages marked with <span class="sgr32">⌃</span> have new versions available and may be upgradable.</code></pre><h2 id="Static-plotting-of-ABMs"><a class="docs-heading-anchor" href="#Static-plotting-of-ABMs">Static plotting of ABMs</a><a id="Static-plotting-of-ABMs-1"></a><a class="docs-heading-anchor-permalink" href="#Static-plotting-of-ABMs" title="Permalink"></a></h2><p>Static plotting, which is also the basis for creating custom plots that include an ABM plot, is done using the <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> function. Its usage is exceptionally straight-forward, and in principle one simply defines functions for how the agents should be plotted. Here we will use a pre-defined model, the Daisyworld as an example throughout this docpage. To learn about this model you can visit the <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/daisyworld/">example hosted at AgentsExampleZoo </a>,</p><pre><code class="language-julia hljs">using Agents, CairoMakie
using AgentsExampleZoo

model = AgentsExampleZoo.daisyworld(;
    solar_luminosity = 1.0, solar_change = 0.0, scenario = :change
)
model</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 360 agents of type Daisy
 agents container: Dict
 space: GridSpaceSingle with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, ratio, solar_change, tick, scenario</code></pre><p>Now, to plot daisyworld we provide a function for the color for the agents that depend on the agent properties, and a size and marker style that are constants,</p><pre><code class="language-julia hljs">daisycolor(a) = a.breed
agent_size = 20
agent_marker = &#39;✿&#39;
agentsplotkwargs = (strokewidth = 1.0, strokecolor = :black)
fig, ax, abmobs = abmplot(
    model;
    agent_color = daisycolor, agent_size, agent_marker, agentsplotkwargs
)
fig # returning the figure displays it</code></pre><img src="f092f6b9.png" alt="Example block output"/><div class="admonition is-info" id="Supported-keyword-arguments-81f26691bd6e987a"><header class="admonition-header">Supported keyword arguments<a class="admonition-anchor" href="#Supported-keyword-arguments-81f26691bd6e987a" title="Permalink"></a></header><div class="admonition-body"><p>We do not check internally, if the keyword arguments passed to <code>abmplot</code> are supported. Please make sure that there are no typos and that the used kwargs are supported by the <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> function. Otherwise they will be ignored. This is an unfortunate consequence of how Makie.jl recipes work, and we believe that in the future this problem will be addressed in Makie.jl.</p></div></div><p>Besides agents, we can also plot spatial properties as a heatmap. Here we plot the temperature of the planet by providing the name of the property as the &quot;heat array&quot;:</p><pre><code class="language-julia hljs">heatarray = :temperature
heatkwargs = (colorrange = (-20, 60), colormap = :thermal)
plotkwargs = (;
    agent_color = daisycolor, agent_size, agent_marker,
    agentsplotkwargs = (strokewidth = 1.0,),
    heatarray, heatkwargs, colorbar_label = &quot;temperature&quot;,
)

fig, ax, abmobs = abmplot(model; plotkwargs...)
fig</code></pre><img src="d5879523.png" alt="Example block output"/><article><details class="docstring" open="true"><summary id="Agents.abmplot-examples-agents_visualizations"><a class="docstring-binding" href="#Agents.abmplot-examples-agents_visualizations"><code>Agents.abmplot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">abmplot(model::ABM; kwargs...) → fig, ax, abmobs
abmplot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmobs</code></pre><p>Plot an agent based model by plotting each individual agent as a marker and using the agent&#39;s position field as its location on the plot. <code>abmplot</code> is also used to launch interactive GUIs for evolving agent based models, see &quot;Interactivity&quot; below.</p><p>See also <a href="../../api/#Agents.abmvideo"><code>abmvideo</code></a> and <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a>.</p><p><code>abmplot</code> returns an instance of <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a> that can be used to manually animate the model evolution, or make custom composite plots and videos. See the online documentation for examples on using this. Instead of <code>model::ABM</code>, an instance of <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a> can also be given to <code>abmplot</code> directly.</p><p><strong>Keyword arguments</strong></p><p><strong>Agent related</strong></p><ul><li><p><code>agent_color, agent_size, agent_marker</code> : These three keywords decide the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a <em>function</em>, which takes as an input a single agent and outputs the corresponding value. If the model uses a <code>GraphSpace</code>, <code>agent_color, agent_size, agent_marker</code> functions instead take an <em>iterable of agents</em> in each position (i.e. node of the graph).</p><p>Example using constants: <code>agent_color = &quot;#338c54&quot;, agent_size = 15, agent_marker = :diamond</code></p><p>Example using functions:</p><pre><code class="language-julia hljs">agent_color(a) = a.status == :S ? &quot;#2b2b33&quot; : a.status == :I ? &quot;#bf2642&quot; : &quot;#338c54&quot;
agent_size(a) = 10rand()
agent_marker(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect</code></pre><p>For 2D models, <code>agent_marker</code> can be/return a <code>Makie.Polygon</code> instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent&#39;s position when creating the polygon. In this case, the keyword <code>agent_size</code> is ignored, as each polygon has its own size. Use the functions <code>scale, rotate_polygon</code> to transform this polygon.</p><p>3D models currently do not support having different markers. As a result, <code>agent_marker</code> cannot be a function. It should be a <code>Mesh</code> or 3D primitive (such as <code>Sphere</code> or <code>Rect3D</code>).</p></li><li><p><code>offset = nothing</code> : If not <code>nothing</code>, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent&#39;s position (which matters only if there is overlap).</p></li><li><p><code>agentsplotkwargs = NamedTuple()</code> : Additional keyword arguments propagated to the function that plots the agents (typically <code>scatter!</code>).</p></li></ul><p><strong>Extra plots related</strong></p><ul><li><code>heatarray = nothing</code> : A keyword that plots a model property (that is a matrix) as a heatmap over the space. Its values can be standard data accessors given to functions like <code>run!</code>, i.e. either a symbol (directly obtain model property) or a function of the model. If the space is <code>AbstractGridSpace</code> then matrix must be the same size as the underlying space. For <code>ContinuousSpace</code> any size works and will be plotted over the space extent. For example <code>heatarray = :temperature</code> is used in the Daisyworld example. But you could also define <code>f(model) = create_matrix_from_model...</code> and set <code>heatarray = f</code>. The heatmap will be updated automatically during model evolution in videos and interactive applications.</li><li><code>heatkwargs = NamedTuple()</code> : Keywords given to <code>Makie.heatmap</code> function if <code>heatarray</code> is not nothing.</li><li><code>add_colorbar = true</code> : Whether or not a Colorbar should be added to the right side of the heatmap if <code>heatarray</code> is not nothing. It is strongly recommended to use <code>abmplot</code> instead of the <code>abmplot!</code> method if you use <code>heatarray</code>, so that a colorbar can be placed naturally.</li><li><code>colorbar_label = &quot;&quot;</code> : Label to add to the colorbar, if any.</li><li><code>preplot!</code> : A function <code>f(ax, abmobs)</code> that plots something after the heatmap, and after space-specific plotting, but before the agents.</li><li><code>spaceplotkwargs = NamedTuple()</code>: keywords utilized when plotting the space, if the space extends the <code>spaceplot!</code> function (currently only <code>OpenStreetMapSpace</code>).</li><li><code>adjust_aspect = true</code>: Adjust axis aspect ratio to be the model&#39;s space data aspect ratio.</li></ul><p>The stand-alone function <code>abmplot</code> also takes two optional <code>NamedTuple</code>s named <code>figure</code> and <code>axis</code> which can be used to change the automatically created <code>Figure</code> and <code>Axis</code> objects.</p><p><strong>Interactivity</strong></p><p><strong>Evolution related</strong></p><ul><li><code>add_controls::Bool</code>: If <code>true</code>, <code>abmplot</code> switches to &quot;interactive application GUI&quot; mode where the model evolves interactively using <code>Agents.step!</code>. <code>add_controls</code> is by default <code>false</code> unless <code>params</code> (see below) is not empty. <code>add_controls</code> is also always <code>true</code> in <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a>. The application has the following interactive elements:<ol><li>&quot;step&quot;: advances the simulation once for <code>dt</code> time.</li><li>&quot;run&quot;: starts/stops the continuous evolution of the model.</li><li>&quot;reset model&quot;: resets the model to its initial state from right after starting the interactive application.</li><li>Two sliders control the animation speed: &quot;dt&quot; decides how much time to evolve the model before the plot is updated, and &quot;sleep&quot; the <code>sleep()</code> time between updates.</li></ol></li><li><code>enable_inspection = add_controls</code>: If <code>true</code>, enables agent inspection on mouse hover.</li><li><code>dt = 1:50</code>: The values of the &quot;dt&quot; slider which is the time to step the model forwards in each frame update, which calls <code>step!(model, dt)</code>. This defaults to <code>1:50</code> for discrete time models and to <code>0.1:0.1:10.0</code> for continuous time ones.</li><li><code>params = Dict()</code> : This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of <code>params</code> is a pair of <code>Symbol</code> to an <code>AbstractVector</code>, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only propagated to the actual model after a press of the &quot;update&quot; button.</li></ul><p><strong>Data collection related</strong></p><ul><li><code>adata, mdata, when</code>: Same as the keyword arguments of <code>Agents.run!</code>. If either or both <code>adata, mdata</code> are given, data are collected and stored in the <code>abmobs</code>, see <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a>. The same keywords provide the data plots of <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a>. This also adds the button &quot;clear data&quot; which deletes previously collected agent and model data by emptying the underlying <code>DataFrames</code> <code>adf</code>/<code>mdf</code>. Reset model and clear data are independent processes.</li></ul><p>See the documentation string of <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a> for custom interactive plots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/24915560b1e751d2f5317c491fdf8e43bd78bac9/src/visualizations.jl#L3-L114">source</a></section></details></article><h2 id="Interactive-ABM-Applications"><a class="docs-heading-anchor" href="#Interactive-ABM-Applications">Interactive ABM Applications</a><a id="Interactive-ABM-Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-ABM-Applications" title="Permalink"></a></h2><p>Continuing from the Daisyworld plots above, we can turn them into interactive applications straightforwardly, simply by setting the keyword <code>add_controls = true</code> as discussed in the documentation of <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>. Note that <a href="https://makie.juliaplots.org/v0.15/documentation/backends_and_output/"><code>GLMakie</code></a> should be used instead of <code>CairoMakie</code> when wanting to use the interactive aspects of the plots!</p><pre><code class="language-julia hljs">using GLMakie</code></pre><pre><code class="language-julia hljs">fig, ax, abmobs = abmplot(model; add_controls = true, plotkwargs...)
fig</code></pre><img src="2a6775db.png" alt="Example block output"/><p>One could click the run button and see the model evolve. Furthermore, one can add more sliders that allow changing the model parameters. This is done by providing a dictionary mapping parameter keys to range of values. When such a dictionary is provided, <code>abmplot</code> goes into interactive mode by default.</p><pre><code class="language-julia hljs">params = Dict(
    :surface_albedo =&gt; 0:0.01:1,
    :solar_change =&gt; -0.1:0.01:0.1,
)
fig, ax, abmobs = abmplot(model; params, plotkwargs...)
fig</code></pre><img src="3996cd37.png" alt="Example block output"/><p>One can furthermore collect data while the model evolves and visualize them using the convenience function <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a></p><pre><code class="language-julia hljs">using Statistics: mean
black(a) = a.breed == :black
white(a) = a.breed == :white
adata = [(black, count), (white, count)]
temperature(model) = mean(model.temperature)
mdata = [temperature, :solar_luminosity]
fig, abmobs = abmexploration(
    model;
    params, plotkwargs..., adata, alabels = [&quot;Black daisys&quot;, &quot;White daisys&quot;],
    mdata, mlabels = [&quot;T&quot;, &quot;L&quot;]
)</code></pre><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><article><details class="docstring" open="true"><summary id="Agents.abmexploration-examples-agents_visualizations"><a class="docstring-binding" href="#Agents.abmexploration-examples-agents_visualizations"><code>Agents.abmexploration</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">abmexploration(model::ABM; alabels, mlabels, kwargs...)</code></pre><p>Open an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires <code>Agents</code>.</p><p>The application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>, and the <code>model</code> argument as well as splatted <code>kwargs</code> are propagated there as-is. This convencience function <em>only works for aggregated agent data</em>.</p><p>Calling <code>abmexploration</code> returns: <code>fig::Figure, abmobs::ABMObservable</code>. So you can save and/or further modify the figure and it is also possible to access the collected data (if any) via the <code>ABMObservable</code>.</p><p>Clicking the &quot;reset&quot; button will add a red vertical line to the data plots for visual guidance.</p><p><strong>Keywords arguments (in addition to those in <code>abmplot</code>)</strong></p><ul><li><code>alabels, mlabels</code>: If data are collected from agents or the model with <code>adata, mdata</code>, the corresponding plots&#39; y-labels are automatically named after the collected data. It is also possible to provide <code>alabels, mlabels</code> (vectors of strings with exactly same length as <code>adata, mdata</code>), and these labels will be used instead.</li><li><code>figure = NamedTuple()</code>: Keywords to customize the created Figure.</li><li><code>axis = NamedTuple()</code>: Keywords to customize the created Axis.</li><li><code>plotkwargs = NamedTuple()</code>: Keywords to customize the styling of the resulting <a href="https://makie.juliaplots.org/dev/examples/plotting_functions/scatterlines/index.html"><code>scatterlines</code></a> plots.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/24915560b1e751d2f5317c491fdf8e43bd78bac9/src/visualizations.jl#L153-L182">source</a></section></details></article><h2 id="ABM-Videos"><a class="docs-heading-anchor" href="#ABM-Videos">ABM Videos</a><a id="ABM-Videos-1"></a><a class="docs-heading-anchor-permalink" href="#ABM-Videos" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Agents.abmvideo-examples-agents_visualizations"><a class="docstring-binding" href="#Agents.abmvideo-examples-agents_visualizations"><code>Agents.abmvideo</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">abmvideo(file, model; kwargs...)</code></pre><p>This function exports the animated time evolution of an agent based model into a video saved at given path <code>file</code>, by recording the behavior of the interactive version of <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> (without sliders). The plotting is identical as in <a href="../../api/#Agents.abmplot"><code>abmplot</code></a> and applicable keywords are propagated.</p><p><strong>Keywords</strong></p><ul><li><code>dt = 1</code>: Time to evolve between each recorded frame. For <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a> this must be an integer and it is identical to how many steps to take per frame.</li><li><code>framerate = 30</code>: The frame rate of the exported video.</li><li><code>frames = 300</code>: How many frames to record in total, including the starting frame.</li><li><code>title = &quot;&quot;</code>: The title of the figure.</li><li><code>showstep = true</code>: If current step should be shown in title.</li><li><code>figure = NamedTuple()</code>: Figure related keywords (e.g. resolution, backgroundcolor).</li><li><code>axis = NamedTuple()</code>: Axis related keywords (e.g. aspect).</li><li><code>recordkwargs = NamedTuple()</code>: Keyword arguments given to <code>Makie.record</code>. You can use <code>(compression = 1, profile = &quot;high&quot;)</code> for a higher quality output, and prefer the <code>CairoMakie</code> backend. (compression 0 results in videos that are not playable by some software)</li><li><code>kwargs...</code>: All other keywords are propagated to <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/24915560b1e751d2f5317c491fdf8e43bd78bac9/src/visualizations.jl#L186-L208">source</a></section></details></article><p>E.g., continuing from above,</p><pre><code class="language-julia hljs">model = AgentsExampleZoo.daisyworld()
abmvideo(&quot;daisyworld.mp4&quot;, model; title = &quot;Daisy World&quot;, frames = 150, plotkwargs...)</code></pre><video width="auto" controls autoplay loop>
<source src="../daisyworld.mp4" type="video/mp4">
</video><p>You could of course also explicitly use <code>abmplot</code> in a <code>record</code> loop for finer control over additional plot elements.</p><h2 id="Creating-custom-ABM-plots"><a class="docs-heading-anchor" href="#Creating-custom-ABM-plots">Creating custom ABM plots</a><a id="Creating-custom-ABM-plots-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-custom-ABM-plots" title="Permalink"></a></h2><p>The existing convenience function <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a> will always display aggregated collected data as scatterpoints connected with lines. In cases where more granular control over the displayed plots is needed, we need to take a few extra steps and utilize the <a href="../../api/#Agents.ABMObservable"><code>ABMObservable</code></a> returned by <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>. The same steps are necessary when we want to create custom plots that compose animations of the model space and other aspects.</p><article><details class="docstring" open="true"><summary id="Agents.ABMObservable-examples-agents_visualizations"><a class="docstring-binding" href="#Agents.ABMObservable-examples-agents_visualizations"><code>Agents.ABMObservable</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ABMObservable(model; adata, mdata, when = true) → abmobs</code></pre><p><code>abmobs</code> contains all information necessary to step an agent based model interactively, as well as collect data while stepping interactively. <code>ABMObservable</code> also returned by <a href="../../api/#Agents.abmplot"><code>abmplot</code></a>.</p><p>Calling <code>Agents.step!(abmobs, t)</code> will step the model for <code>t</code> time and collect data as in <a href="../../api/#Agents.run!"><code>Agents.run!</code></a>, using the <code>adata, mdata, when</code> keywords. The fields <code>abmobs.model, abmobs.adf, abmobs.mdf</code> are <em>observables</em> that contain the <a href="../../api/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, and the agent and model dataframes with collected data. These observables are updated (and <code>notify</code>) during <code>step!</code>.</p><p>All plotting and interactivity should be defined by <code>lift</code>-ing (or <code>map</code>-ing) these observables according to the Observables.jl interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/24915560b1e751d2f5317c491fdf8e43bd78bac9/src/visualizations.jl#L122-L137">source</a></section></details></article><p>To do custom animations you need to have a good idea of how Makie&#39;s animation system works. Have a look <a href="https://www.youtube.com/watch?v=L-gyDvhjzGQ">at this tutorial</a> if you are not familiar yet.</p><p>create a basic abmplot with controls and sliders</p><pre><code class="language-julia hljs">model = AgentsExampleZoo.daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)
fig, ax, abmobs = abmplot(
    model; params, plotkwargs...,
    adata, mdata, figure = (; size = (1600, 800))
)
fig</code></pre><img src="e69f23b4.png" alt="Example block output"/><pre><code class="language-julia hljs">abmobs</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ABMObservable with model:
StandardABM with 360 agents of type Daisy
 agents container: Dict
 space: GridSpaceSingle with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, ratio, solar_change, tick, scenario
and with data collection:
 adata: Tuple{Function, typeof(count)}[(Main.black, count), (Main.white, count)]
 mdata: Any[Main.temperature, :solar_luminosity]</code></pre><p>create a new layout to add new plots to the right of the abmplot</p><pre><code class="language-julia hljs">plot_layout = fig[:, end + 1] = GridLayout()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridLayout[1:1, 1:1] with 0 children
</code></pre><p>create a sublayout on its first row and column</p><pre><code class="language-julia hljs">count_layout = plot_layout[1, 1] = GridLayout()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridLayout[1:1, 1:1] with 0 children
</code></pre><p>collect tuples with x and y values for black and white daisys</p><pre><code class="language-julia hljs">blacks = @lift(Point2f.($(abmobs.adf).time, $(abmobs.adf).count_black))
whites = @lift(Point2f.($(abmobs.adf).time, $(abmobs.adf).count_white))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Observable(Point{2, Float32}[[0.0, 180.0]])
</code></pre><p>create an axis to plot into and style it to our liking</p><pre><code class="language-julia hljs">ax_counts = Axis(
    count_layout[1, 1];
    backgroundcolor = :lightgrey, ylabel = &quot;Number of daisies by color&quot;
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Axis with 0 plots:
</code></pre><p>plot the data as scatterlines and color them accordingly</p><pre><code class="language-julia hljs">scatterlines!(ax_counts, blacks; color = :black, label = &quot;black&quot;)
scatterlines!(ax_counts, whites; color = :white, label = &quot;white&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Plot{Makie.scatterlines, Tuple{Vector{Point{2, Float32}}}}</code></pre><p>add a legend to the right side of the plot</p><pre><code class="language-julia hljs">Legend(count_layout[1, 2], ax_counts; bgcolor = :lightgrey)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Legend()</code></pre><p>and another plot, written in a more condensed format</p><pre><code class="language-julia hljs">ax_hist = Axis(
    plot_layout[2, 1];
    ylabel = &quot;Distribution of mean temperatures\nacross all time steps&quot;
)
hist!(
    ax_hist, @lift($(abmobs.mdf).temperature);
    bins = 50, color = :red,
    strokewidth = 2, strokecolor = (:black, 0.5),
)

fig</code></pre><img src="ee357e52.png" alt="Example block output"/><p>Now, once we step the <code>abmobs::ABMObservable</code>, the whole plot will be updated</p><pre><code class="language-julia hljs">Agents.step!(abmobs, 1)
Agents.step!(abmobs, 1)
fig</code></pre><img src="88fecd1a.png" alt="Example block output"/><p>Of course, you need to actually adjust axis limits given that the plot is interactive</p><pre><code class="language-julia hljs">autolimits!(ax_counts)
autolimits!(ax_hist)</code></pre><p>Or, simply trigger them on any update to the model observable:</p><pre><code class="language-julia hljs">on(abmobs.model) do m
    autolimits!(ax_counts)
    autolimits!(ax_hist)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ObserverFunction defined at agents_visualizations.md:281 operating on Observable(StandardABM with 783 agents of type Daisy
 agents container: Dict
 space: GridSpaceSingle with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, ratio, solar_change, tick, scenario)</code></pre><p>and then marvel at everything being auto-updated by calling <code>step!</code> :)</p><pre><code class="language-julia hljs">for i in 1:100
    step!(abmobs, 1)
end
fig</code></pre><img src="e0a7e1de.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../api/">« API</a><a class="docs-footer-nextpage" href="../optim/">BlackBoxOptim.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Friday 27 February 2026 19:43">Friday 27 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
