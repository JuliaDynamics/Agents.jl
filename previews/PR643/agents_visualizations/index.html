<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plotting and Interactivity · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak</a></li><li><a class="tocitem" href="../examples/rabbit_fox_hawk/">Rabbit, Fox, Hawk</a></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li><a class="tocitem" href="../examples/">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li class="is-active"><a class="tocitem" href>Plotting and Interactivity</a><ul class="internal"><li><a class="tocitem" href="#Static-plotting-of-ABMs-1"><span>Static plotting of ABMs</span></a></li><li><a class="tocitem" href="#Interactive-ABM-Applications-1"><span>Interactive ABM Applications</span></a></li><li><a class="tocitem" href="#ABM-Videos-1"><span>ABM Videos</span></a></li><li><a class="tocitem" href="#Agent-inspection-1"><span>Agent inspection</span></a></li><li><a class="tocitem" href="#Creating-custom-ABM-plots-1"><span>Creating custom ABM plots</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Plotting and Interactivity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plotting and Interactivity</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/../../../.julia/packages/InteractiveDynamics/wWR1V/docs/src/agents.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Visualizations-and-Animations-for-Agent-Based-Models-1"><a class="docs-heading-anchor" href="#Visualizations-and-Animations-for-Agent-Based-Models-1">Visualizations and Animations for Agent Based Models</a><a class="docs-heading-anchor-permalink" href="#Visualizations-and-Animations-for-Agent-Based-Models-1" title="Permalink"></a></h1><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><p>This page describes functions that can be used in conjunction with <a href="https://juliadynamics.github.io/Agents.jl/dev/">Agents.jl</a> to animate and interact  with agent based models.</p><p>The animation at the start of the page is created using the code of this page, see below.</p><p>The docs are built using versions:</p><pre><code class="language-julia">using Pkg
Pkg.status([&quot;Agents&quot;, &quot;InteractiveDynamics&quot;];
    mode = PKGMODE_MANIFEST, io=stdout
)</code></pre><pre><code class="language-none">      Status `~/work/Agents.jl/Agents.jl/docs/Manifest.toml`
  [46ada45e] Agents v5.4.0 `~/work/Agents.jl/Agents.jl`
  [ec714cd0] InteractiveDynamics v0.21.4</code></pre><h2 id="Static-plotting-of-ABMs-1"><a class="docs-heading-anchor" href="#Static-plotting-of-ABMs-1">Static plotting of ABMs</a><a class="docs-heading-anchor-permalink" href="#Static-plotting-of-ABMs-1" title="Permalink"></a></h2><p>Static plotting, which is also the basis for creating custom plots that include an abm plot, is done using the <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a> function. Its usage is exceptionally straight-forward, and in principle one simply defines functions for how the agents should be plotted. Here we will use a pre-defined model, the Daisyworld as an example throughout this docpage. To learn about this model you can visit the <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/daisyworld/">full example</a>,</p><pre><code class="language-julia">using InteractiveDynamics, Agents
using CairoMakie
daisypath = joinpath(dirname(pathof(InteractiveDynamics)), &quot;agents&quot;, &quot;daisyworld_def.jl&quot;)
include(daisypath)
model, daisy_step!, daisyworld_step! = daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)
model</code></pre><pre><code class="language-none">AgentBasedModel with 360 agents of type Daisy
 space: GridSpace with size (30, 30), metric=chebyshev, periodic=true
 scheduler: fastest
 properties: temperature, solar_luminosity, max_age, surface_albedo, solar_change, tick, scenario</code></pre><p>Now, to plot daisyworld is as simple as</p><pre><code class="language-">daisycolor(a::Daisy) = a.breed # color of agents
as = 14 # size of agents
am = &#39;♠&#39; # marker of agents
scatterkwargs = (strokewidth = 1.0,) # add stroke around each agent
fig, ax, abmobs = abmplot(model; ac = daisycolor, as, am, scatterkwargs)
fig</code></pre><p>To this, we can also plot the temperature of the planet by providing the access field as a heat array:</p><pre><code class="language-">heatarray = :temperature
heatkwargs = (colorrange = (-20, 60), colormap = :thermal)
plotkwargs = (;
    ac = daisycolor, as, am,
    scatterkwargs = (strokewidth = 1.0,),
    heatarray, heatkwargs
)

fig, ax, abmobs = abmplot(model; plotkwargs...)
fig</code></pre><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abmplot" href="#InteractiveDynamics.abmplot"><code>InteractiveDynamics.abmplot</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abmplot(model::ABM; kwargs...) → fig, ax, abmobs
abmplot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmobs</code></pre><p>Plot an agent based model by plotting each individual agent as a marker and using the agent&#39;s position field as its location on the plot. The same function is used to make custom composite plots and interactive applications for the model evolution using the returned <code>abmobs</code>. <code>abmplot</code> is also used to launch interactive GUIs for evolving agent based models, see &quot;Interactivity&quot; below.</p><p>Requires <code>Agents</code>. See also <a href="#InteractiveDynamics.abmvideo"><code>abmvideo</code></a> and <a href="#InteractiveDynamics.abmexploration"><code>abmexploration</code></a>.</p><p><strong>Keyword arguments</strong></p><p><strong>Agent related</strong></p><ul><li><p><code>ac, as, am</code> : These three keywords decide the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a <em>function</em>, which takes as an input a single agent and outputs the corresponding value.</p><p>Using constants: <code>ac = &quot;#338c54&quot;, as = 10, am = :diamond</code></p><p>Using functions:</p><pre><code class="language-julia">ac(a) = a.status == :S ? &quot;#2b2b33&quot; : a.status == :I ? &quot;#bf2642&quot; : &quot;#338c54&quot;
as(a) = 10rand()
am(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect</code></pre><p>Notice that for 2D models, <code>am</code> can be/return a <code>Polygon</code> instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent&#39;s position when creating the polygon. In this case, the keyword <code>as</code> is meaningless, as each polygon has its own size. Use the functions <code>scale, rotate2D</code> to transform this polygon.</p><p>3D models currently do not support having different markers. As a result, <code>am</code> cannot be a function. It should be a <code>Mesh</code> or 3D primitive (such as <code>Sphere</code> or <code>Rect3D</code>).</p></li><li><p><code>offset = nothing</code> : If not <code>nothing</code>, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent&#39;s position (which matters only if there is overlap).</p></li><li><p><code>scatterkwargs = ()</code> : Additional keyword arguments propagated to the <code>scatter!</code> call.</p></li></ul><p><strong>Preplot related</strong></p><ul><li><p><code>heatarray = nothing</code> : A keyword that plots a heatmap over the space. Its values can be standard data accessors given to functions like <code>run!</code>, i.e. either a symbol (directly obtain model property) or a function of the model. The returned data must be a matrix of the same size as the underlying space. For example <code>heatarray = :temperature</code> is used in the Daisyworld example. But you could also define <code>f(model) = create_matrix_from_model...</code> and set <code>heatarray = f</code>. The heatmap will be updated automatically during model evolution in videos and interactive applications.</p><p>It is strongly recommended to use <code>abmplot</code> instead of the <code>abmplot!</code> method if you use <code>heatarray</code>, so that a colorbar can be placed naturally.</p></li><li><p><code>heatkwargs = NamedTuple()</code> : Keywords given to <code>Makie.heatmap</code> function if <code>heatarray</code> is not nothing.</p></li><li><p><code>add_colorbar = true</code> : Whether or not a Colorbar should be added to the right side of the heatmap if <code>heatarray</code> is not nothing.</p></li><li><p><code>static_preplot!</code> : A function <code>f(ax, model)</code> that plots something after the heatmap but before the agents. Notice that you can still make objects of this plot be visible above the agents using a translation in the third dimension like below:</p><pre><code class="language-julia">function static_preplot!(ax, model)
    obj = scatter!(ax, [50 50]; color = :red) # Show position of teacher
    hidedecorations!(ax) # hide tick labels etc.
    translate!(obj, 0, 0, 5) # be sure that the teacher will be above students
end</code></pre></li><li><p><code>osmkwargs = NamedTuple()</code> : keywords directly passed to <code>osmplot!</code> from OSMMakie.jl if model space is <code>OpenStreetMapSpace</code>.</p></li></ul><p>The stand-alone function <code>abmplot</code> also takes two optional <code>NamedTuple</code>s named <code>figure</code> and <code>axis</code> which can be used to change the automatically created <code>Figure</code> and <code>Axis</code> objects.</p><p><strong>Interactivity</strong></p><p><strong>Evolution related</strong></p><ul><li><code>agent_step!, model_step! = Agents.dummystep</code>: Stepping functions to pass to <a href="#InteractiveDynamics.ABMObservable"><code>ABMObservable</code></a> which itself passes to <code>Agents.step!</code>.</li><li><code>add_controls::Bool</code>: If <code>true</code>, <code>abmplot</code> switches to &quot;interactive application&quot; mode. This is by default <code>true</code> if either <code>agent_step!</code> or <code>model_step!</code> keywords are provided. These stepping functions are used to evolve the model interactively using <code>Agents.step!</code>. The application has the following interactive elements:<ol><li>&quot;step&quot;: advances the simulation once for <code>spu</code> steps.</li><li>&quot;run&quot;: starts/stops the continuous evolution of the model.</li><li>&quot;reset model&quot;: resets the model to its initial state from right after starting the interactive application.</li><li>Two sliders control the animation speed: &quot;spu&quot; decides how many model steps should be done before the plot is updated, and &quot;sleep&quot; the <code>sleep()</code> time between updates.</li></ol></li><li><code>enable_inspection = add_controls</code>: If <code>true</code>, enables agent inspection on mouse hover.</li><li><code>spu = 1:50</code>: The values of the &quot;spu&quot; slider.</li><li><code>params = Dict()</code> : This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of <code>params</code> is a pair of <code>Symbol</code> to an <code>AbstractVector</code>, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only propagated to the actual model after a press of the &quot;update&quot; button.</li></ul><p><strong>Data collection related</strong></p><ul><li><code>adata, mdata, when</code>: Same as the keyword arguments of <code>Agents.run!</code>. If either or both <code>adata, mdata</code> are given, data are collected and stored in the <code>abmobs</code>, see <a href="#InteractiveDynamics.ABMObservable"><code>ABMObservable</code></a>. The same keywords provide the data plots of <a href="#InteractiveDynamics.abmexploration"><code>abmexploration</code></a>. This also adds the button &quot;clear data&quot; which deletes previously collected agent and model data by emptying the underlying <code>DataFrames</code> <code>adf</code>/<code>mdf</code>. Reset model and clear data are independent processes.</li></ul><p>See the documentation string of <a href="#InteractiveDynamics.ABMObservable"><code>ABMObservable</code></a> for custom interactive plots.</p></div></section></article><h2 id="Interactive-ABM-Applications-1"><a class="docs-heading-anchor" href="#Interactive-ABM-Applications-1">Interactive ABM Applications</a><a class="docs-heading-anchor-permalink" href="#Interactive-ABM-Applications-1" title="Permalink"></a></h2><p>Continuing from the Daisyworld plots above, we can turn them into interactive applications straightforwardly, simply by providing the stepping functions as illustrated in the documentation of <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a>. Note that <a href="https://makie.juliaplots.org/v0.15/documentation/backends_and_output/"><code>GLMakie</code></a> should be used instead of <code>CairoMakie</code> when wanting to use the interactive aspects of the plots.</p><pre><code class="language-">fig, ax, abmobs = abmplot(model; agent_step! = daisy_step!, model_step! = daisyworld_step!,
    plotkwargs...)
fig</code></pre><p>One could click the run button and see the model evolve. Furthermore, one can add more sliders that allow changing the model parameters.</p><pre><code class="language-">params = Dict(
    :surface_albedo =&gt; 0:0.01:1,
    :solar_change =&gt; -0.1:0.01:0.1,
)
fig, ax, abmobs = abmplot(model; agent_step! = daisy_step!, model_step! = daisyworld_step!,
    params, plotkwargs...)
fig</code></pre><p>One can furthermore collect data while the model evolves and visualize them using the convenience function <a href="#InteractiveDynamics.abmexploration"><code>abmexploration</code></a></p><pre><code class="language-">black(a) = a.breed == :black
white(a) = a.breed == :white
adata = [(black, count), (white, count)]
temperature(model) = mean(model.temperature)
mdata = [temperature, :solar_luminosity]
fig, p = abmexploration(model;
    agent_step! = daisy_step!, model_step! = daisyworld_step!, params, plotkwargs...,
    adata, alabels = [&quot;Black daisys&quot;, &quot;White daisys&quot;], mdata, mlabels = [&quot;T&quot;, &quot;L&quot;]
)
nothing # hide</code></pre><video width="100%" height="auto" controls autoplay loop>
<source src="https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true" type="video/mp4">
</video><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abmexploration" href="#InteractiveDynamics.abmexploration"><code>InteractiveDynamics.abmexploration</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abmexploration(model::ABM; alabels, mlabels, kwargs...)</code></pre><p>Open an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires <code>Agents</code>.</p><p>The application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a>, and the <code>model</code> argument as well as splatted <code>kwargs</code> are propagated there as-is. This convencience function <em>only works for aggregated agent data</em>.</p><p>Calling <code>abmexploration</code> returns: <code>fig::Figure, p::_ABMPlot</code>. So you can save and/or further modify the figure. But it is also possible to access the collected data (if any) via the plot object, just like in the case of using <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a> directly.</p><p>Clicking the &quot;reset&quot; button will add a red vertical line to the data plots for visual guidance.</p><p><strong>Keywords arguments (in addition to those in <code>abmplot</code>)</strong></p><ul><li><code>alabels, mlabels</code>: If data are collected from agents or the model with <code>adata, mdata</code>, the corresponding plots&#39; y-labels are automatically named after the collected data. It is also possible to provide <code>alabels, mlabels</code> (vectors of strings with exactly same length as <code>adata, mdata</code>), and these labels will be used instead.</li><li><code>figure = NamedTuple()</code>: Keywords to customize the created Figure.</li><li><code>axis = NamedTuple()</code>: Keywords to customize the created Axis.</li><li><code>plotkwargs = NamedTuple()</code>: Keywords to customize the styling of the resulting <a href="https://makie.juliaplots.org/dev/examples/plotting_functions/scatterlines/index.html"><code>scatterlines</code></a> plots.</li></ul></div></section></article><h2 id="ABM-Videos-1"><a class="docs-heading-anchor" href="#ABM-Videos-1">ABM Videos</a><a class="docs-heading-anchor-permalink" href="#ABM-Videos-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.abmvideo" href="#InteractiveDynamics.abmvideo"><code>InteractiveDynamics.abmvideo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">abmvideo(file, model, agent_step! [, model_step!]; kwargs...)</code></pre><p>This function exports the animated time evolution of an agent based model into a video saved at given path <code>file</code>, by recording the behavior of the interactive version of <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a> (without sliders). The plotting is identical as in <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a> and applicable keywords are propagated.</p><p><strong>Keywords</strong></p><ul><li><code>spf = 1</code>: Steps-per-frame, i.e. how many times to step the model before recording a new frame.</li><li><code>framerate = 30</code>: The frame rate of the exported video.</li><li><code>frames = 300</code>: How many frames to record in total, including the starting frame.</li><li><code>title = &quot;&quot;</code>: The title of the figure.</li><li><code>showstep = true</code>: If current step should be shown in title.</li><li><code>figure = NamedTuple()</code>: Figure related keywords (e.g. resolution, backgroundcolor).</li><li><code>axis = NamedTuple()</code>: Axis related keywords (e.g. aspect).</li><li><code>kwargs...</code>: All other keywords are propagated to <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a>.</li></ul></div></section></article><p>E.g., continuing from above,</p><pre><code class="language-">model, daisy_step!, daisyworld_step! = daisyworld()
abmvideo(
    &quot;daisyworld.mp4&quot;,
    model,  daisy_step!, daisyworld_step!;
    title = &quot;Daisy World&quot;, frames = 150,
    plotkwargs...
)</code></pre><video width="auto" controls autoplay loop>
<source src="../daisyworld.mp4" type="video/mp4">
</video><h2 id="Agent-inspection-1"><a class="docs-heading-anchor" href="#Agent-inspection-1">Agent inspection</a><a class="docs-heading-anchor-permalink" href="#Agent-inspection-1" title="Permalink"></a></h2><p>It is possible to inspect agents at a given position by hovering the mouse cursor over the scatter points in the agent plot. Inspection is automatically enabled for interactive applications (i.e. when either agent or model stepping functions are provided). To manually enable this functionality, simply add <code>enable_inspection = true</code> as an additional keyword argument to the <code>abmplot</code>/<code>abmplot!</code> call. A tooltip will appear which by default provides the name of the agent type, its <code>id</code>, <code>pos</code>, and all other fieldnames together with their current values. This is especially useful for interactive exploration of micro data on the agent level.</p><p><img src="https://github.com/JuliaDynamics/JuliaDynamics/tree/master/videos/agents/RabbitFoxHawk_inspection.png" alt="RabbitFoxHawk inspection example"/></p><p>The tooltip can be customized by extending <code>InteractiveDynamics.agent2string</code>.</p><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.agent2string" href="#InteractiveDynamics.agent2string"><code>InteractiveDynamics.agent2string</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">agent2string(agent::A)</code></pre><p>Convert agent data into a string which is used to display all agent variables and their values in the tooltip on mouse hover. Concatenates strings if there are multiple agents at one position. Custom tooltips for agents can be implemented by adding a specialised method for <code>agent2string</code>. Example:</p><pre><code class="language-julia">import InteractiveDynamics.agent2string
function agent2string(agent::SpecialAgent)
    &quot;&quot;&quot;
    ✨ SpecialAgent ✨
    ID = $(agent.id)
    Main weapon = $(agent.charisma)
    Side weapon = $(agent.pistol)
    &quot;&quot;&quot;
end</code></pre></div></section></article><h2 id="Creating-custom-ABM-plots-1"><a class="docs-heading-anchor" href="#Creating-custom-ABM-plots-1">Creating custom ABM plots</a><a class="docs-heading-anchor-permalink" href="#Creating-custom-ABM-plots-1" title="Permalink"></a></h2><p>The existing convenience function <a href="#InteractiveDynamics.abmexploration"><code>abmexploration</code></a> will always display aggregated collected data as scatterpoints connected with lines. In cases where more granular control over the displayed plots is needed, we need to take a few extra steps and utilize the <a href="#InteractiveDynamics.ABMObservable"><code>ABMObservable</code></a> returned by <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="InteractiveDynamics.ABMObservable" href="#InteractiveDynamics.ABMObservable"><code>InteractiveDynamics.ABMObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ABMObservable(model; agent_step!, model_step!, adata, mdata, when) → abombs</code></pre><p><code>abmobs</code> contains all information necessary to step an agent based model interactively. It is also returned by <a href="#InteractiveDynamics.abmplot"><code>abmplot</code></a>.</p><p>Calling <code>Agents.step!(abmobs, n)</code> will step the model for <code>n</code> using the provided <code>agent_step!, model_step!, n</code> as in <a href="../tutorial/#Agents.step!"><code>Agents.step!</code></a>.</p><p>The fields <code>abmobs.model, abmobs.adf, abmobs.mdf</code> are <em>observables</em> that contain the <a href="@ref"><code>AgentBasedModel</code></a>, and the agent and model dataframes with collected data. Data are collected as described in <a href="../tutorial/#Agents.run!"><code>Agents.run!</code></a> using the <code>adata, mdata, when</code> keywords. All three observables are updated on stepping (when it makes sense). The field <code>abmobs.s</code> is also an observable containing the current step number.</p><p>All plotting and interactivity should be defined by <code>lift</code>ing these observables.</p></div></section></article><p>To do custom animations you need to have a good idea of how Makie&#39;s animation system works. Have a look <a href="https://www.youtube.com/watch?v=L-gyDvhjzGQ">at this tutorial</a> if you are not familiar yet.</p><p>create a basic abmplot with controls and sliders</p><pre><code class="language-">model, = daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)
fig, ax, p = abmplot(model;
    agent_step! = daisy_step!, model_step! = daisyworld_step!, params, plotkwargs...,
    adata, mdata, figure = (; resolution = (1600,800))
)
fig</code></pre><pre><code class="language-">p</code></pre><pre><code class="language-"># create a new layout to add new plots to to the right of the abmplot
plot_layout = fig[:,end+1] = GridLayout()

# create a sublayout on its first row and column
count_layout = plot_layout[1,1] = GridLayout()

# collect tuples with x and y values for black and white daisys
blacks = @lift(Point2f.($(p.adf).step, $(p.adf).count_black))
whites = @lift(Point2f.($(p.adf).step, $(p.adf).count_white))

# create an axis to plot into and style it to our liking
ax_counts = Axis(count_layout[1,1];
    backgroundcolor = :lightgrey, ylabel = &quot;Number of daisies by color&quot;)

# plot the data as scatterlines and color them accordingly
scatterlines!(ax_counts, blacks; color = :black, label = &quot;black&quot;)
scatterlines!(ax_counts, whites; color = :white, label = &quot;white&quot;)

# add a legend to the right side of the plot
Legend(count_layout[1,2], ax_counts; bgcolor = :lightgrey)

# and another plot, written in a more condensed format
ax_hist = Axis(plot_layout[2,1];
    ylabel = &quot;Distribution of mean temperatures\nacross all time steps&quot;)
hist!(ax_hist, @lift($(p.mdf).temperature);
    bins = 50, color = :red,
    strokewidth = 2, strokecolor = (:black, 0.5),
)

fig</code></pre><p>Now, once we step the <code>p::ABMObservable</code>, the whole plot will be updated</p><pre><code class="language-">Agents.step!(p, 1)
Agents.step!(p, 1)
fig</code></pre><p>Of course, you need to actually adjust axis limits given that the plot is interactive</p><pre><code class="language-">autolimits!(ax_counts)
autolimits!(ax_hist)</code></pre><p>Or, simply trigger them on any update to the model observable:</p><pre><code class="language-">on(p.model) do m
    autolimits!(ax_counts)
    autolimits!(ax_hist)
end

for i in 1:100; step!(p, 1); end
fig</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api/">« API</a><a class="docs-footer-nextpage" href="../examples/optim/">BlackBoxOptim.jl »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 3 July 2022 17:49">Sunday 3 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
