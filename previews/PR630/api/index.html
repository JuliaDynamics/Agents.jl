<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak</a></li><li><a class="tocitem" href="../examples/rabbit_fox_hawk/">Rabbit, Fox, Hawk</a></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li><a class="tocitem" href="../examples/">More Examples for Agents.jl</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#@agent-macro-1"><span><code>@agent</code> macro</span></a></li><li><a class="tocitem" href="#Agent/model-retrieval-and-access-1"><span>Agent/model retrieval and access</span></a></li><li><a class="tocitem" href="#Available-spaces-1"><span>Available spaces</span></a></li><li><a class="tocitem" href="#Adding-agents-1"><span>Adding agents</span></a></li><li><a class="tocitem" href="#Moving-agents-1"><span>Moving agents</span></a></li><li><a class="tocitem" href="#Removing-agents-1"><span>Removing agents</span></a></li><li><a class="tocitem" href="#Discrete-space-exclusives-1"><span>Discrete space exclusives</span></a></li><li><a class="tocitem" href="#Continuous-space-exclusives-1"><span>Continuous space exclusives</span></a></li><li><a class="tocitem" href="#Graph-space-exclusives-1"><span>Graph space exclusives</span></a></li><li><a class="tocitem" href="#OpenStreetMap-space-exclusives-1"><span>OpenStreetMap space exclusives</span></a></li><li><a class="tocitem" href="#Nearby-Agents-1"><span>Nearby Agents</span></a></li><li><a class="tocitem" href="#A-note-on-iteration-1"><span>A note on iteration</span></a></li><li><a class="tocitem" href="#Higher-order-interactions-1"><span>Higher-order interactions</span></a></li><li><a class="tocitem" href="#Parameter-scanning-1"><span>Parameter scanning</span></a></li><li><a class="tocitem" href="#Data-collection-1"><span>Data collection</span></a></li><li><a class="tocitem" href="#Schedulers-1"><span>Schedulers</span></a></li><li><a class="tocitem" href="#Ensemble-runs-and-Parallelization-1"><span>Ensemble runs and Parallelization</span></a></li><li><a class="tocitem" href="#Path-finding-1"><span>Path-finding</span></a></li><li><a class="tocitem" href="#Save,-Load,-Checkpoints-1"><span>Save, Load, Checkpoints</span></a></li></ul></li><li><a class="tocitem" href="../agents_visualizations/">Plotting and Interactivity</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-1"><a class="docs-heading-anchor" href="#API-1">API</a><a class="docs-heading-anchor-permalink" href="#API-1" title="Permalink"></a></h1><p>The API of Agents.jl is defined on top of the fundamental structures <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, <a href="../tutorial/#Space-1">Space</a>, <a href="../tutorial/#Agents.AbstractAgent"><code>AbstractAgent</code></a> which are described in the <a href="../tutorial/#Tutorial-1">Tutorial</a> page. In this page we list the remaining API functions, which constitute the bulk of Agents.jl functionality.</p><h2 id="@agent-macro-1"><a class="docs-heading-anchor" href="#@agent-macro-1"><code>@agent</code> macro</a><a class="docs-heading-anchor-permalink" href="#@agent-macro-1" title="Permalink"></a></h2><p>The <a href="#Agents.@agent"><code>@agent</code></a> macro makes defining agent types within Agents.jl simple.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.@agent" href="#Agents.@agent"><code>Agents.@agent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@agent YourAgentType{X, Y} AgentSupertype begin
    some_property::X
    other_extra_property::Y
    # etc...
end</code></pre><p>Create a struct for your agents which includes the mandatory fields required to operate in a particular space. Depending on the space of your model, the <code>AgentSupertype</code> is chosen appropriately from <a href="#Agents.GraphAgent"><code>GraphAgent</code></a>, <a href="#Agents.GridAgent"><code>GridAgent</code></a>, <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a>, <a href="#Agents.OSMAgent"><code>OSMAgent</code></a>.</p><p><strong>Example</strong></p><p>Using</p><pre><code class="language-julia">@agent Person{T} GridAgent{2} begin
    age::Int
    moneyz::T
end</code></pre><p>will in fact create an agent appropriate for using with 2-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a></p><pre><code class="language-julia">mutable struct Person{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    age::Int
    moneyz::T
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/agents.jl#L31-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphAgent" href="#Agents.GraphAgent"><code>Agents.GraphAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphAgent</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>. It attributes the fields <code>id::Int, pos::Int</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/agents.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridAgent" href="#Agents.GridAgent"><code>Agents.GridAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridAgent{D}</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <code>D</code>-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a>. It attributes the fields <code>id::Int, pos::NTuple{D,Int}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/agents.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousAgent" href="#Agents.ContinuousAgent"><code>Agents.ContinuousAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousAgent{D}</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <code>D</code>-dimensional <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. It attributes the fields <code>id::Int, pos::NTuple{D,Float64}, vel::NTuple{D,Float64}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/agents.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSMAgent" href="#Agents.OSMAgent"><code>Agents.OSMAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OSMAgent</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>. It attributes the fields <code>id::Int, pos::Tuple{Int,Int,Float64}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/agents.jl#L106-L112">source</a></section></article><h2 id="Agent/model-retrieval-and-access-1"><a class="docs-heading-anchor" href="#Agent/model-retrieval-and-access-1">Agent/model retrieval and access</a><a class="docs-heading-anchor-permalink" href="#Agent/model-retrieval-and-access-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AgentBasedModel, Integer}" href="#Base.getindex-Tuple{AgentBasedModel, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model[id]
getindex(model::ABM, id::Integer)</code></pre><p>Return an agent given its ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{AgentBasedModel, Symbol}" href="#Base.getproperty-Tuple{AgentBasedModel, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model.prop
getproperty(model::ABM, :prop)</code></pre><p>Return a property with name <code>:prop</code> from the current <code>model</code>, assuming the model <code>properties</code> are either a dictionary with key type <code>Symbol</code> or a Julia struct. For example, if a model has the set of properties <code>Dict(:weight =&gt; 5, :current =&gt; false)</code>, retrieving these values can be obtained via <code>model.weight</code>.</p><p>The property names <code>:agents, :space, :scheduler, :properties, :maxid</code> are internals and <strong>should not be accessed by the user</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L133-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.seed!" href="#Agents.seed!"><code>Agents.seed!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seed!(model [, seed])</code></pre><p>Reseed the random number pool of the model with the given seed or a random one, when using a pseudo-random number generator like <code>MersenneTwister</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_agent" href="#Agents.random_agent"><code>Agents.random_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_agent(model) → agent</code></pre><p>Return a random agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L189-L192">source</a></section><section><div><pre><code class="language-none">random_agent(model, condition) → agent</code></pre><p>Return a random agent from the model that satisfies <code>condition(agent) == true</code>. The function generates a random permutation of agent IDs and iterates through them. If no agent satisfies the condition, <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L195-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nagents" href="#Agents.nagents"><code>Agents.nagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nagents(model::ABM)</code></pre><p>Return the number of agents in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L213-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allagents" href="#Agents.allagents"><code>Agents.allagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allagents(model)</code></pre><p>Return an iterator over all agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L219-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allids" href="#Agents.allids"><code>Agents.allids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allids(model)</code></pre><p>Return an iterator over all agent IDs of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L225-L228">source</a></section></article><h2 id="Available-spaces-1"><a class="docs-heading-anchor" href="#Available-spaces-1">Available spaces</a><a class="docs-heading-anchor-permalink" href="#Available-spaces-1" title="Permalink"></a></h2><p>Here we list the spaces that are available &quot;out of the box&quot; from Agents.jl. To create your own, see <a href="../devdocs/#Creating-a-new-space-type-1">Creating a new space type</a>.</p><h3 id="Discrete-spaces-1"><a class="docs-heading-anchor" href="#Discrete-spaces-1">Discrete spaces</a><a class="docs-heading-anchor-permalink" href="#Discrete-spaces-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphSpace" href="#Agents.GraphSpace"><code>Agents.GraphSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphSpace(graph::AbstractGraph)</code></pre><p>Create a <code>GraphSpace</code> instance that is underlined by an arbitrary graph from <a href="https://github.com/JuliaGraphs/Graphs.jl">Graphs.jl</a>. The position type for this space is <code>Int</code>, use <a href="#Agents.GraphAgent"><code>GraphAgent</code></a> for convenience. The underlying graph can be altered using <a href="#Agents.add_node!"><code>add_node!</code></a> and <a href="#Agents.rem_node!"><code>rem_node!</code></a>.</p><p><code>GraphSpace</code> represents a space where each node (i.e. position) of a graph can hold an arbitrary amount of agents, and each agent can move between the nodes of the graph. An example of its usage can be found in <a href="../examples/sir/#SIR-model-for-the-spread-of-COVID-19-1">SIR model for the spread of COVID-19</a>.</p><p>If you want to model social networks, where each agent is equivalent with a node of a graph, you&#39;re better of using <code>nothing</code> (or other spaces) as the model space, and using a graph from Graphs.jl directly in the model parameters, as shown in the <a href="../examples/schoolyard/#Social-networks-with-Graphs.jl-1">Social networks with Graphs.jl</a> integration example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/graph.jl#L11-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridSpace" href="#Agents.GridSpace"><code>Agents.GridSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridSpace(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)</code></pre><p>Create a <code>GridSpace</code> that has size given by the tuple <code>d</code>, having <code>D ≥ 1</code> dimensions. Optionally decide whether the space will be periodic and what will be the distance metric used, which decides the behavior of e.g. <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>. The position type for this space is <code>NTuple{D, Int}</code>, use <a href="#Agents.GridAgent"><code>GridAgent</code></a> for convenience. In our examples we typically use <code>Dims{D}</code> instead of <code>NTuple{D, Int}</code> (they are equivalent). Valid positions have indices in the range <code>1:d[i]</code> for the <code>i</code>th dimension.</p><p><code>:chebyshev</code> metric means that the <code>r</code>-neighborhood of a position are all positions within the hypercube having side length of <code>2*floor(r)</code> and being centered in the origin position.</p><p><code>:euclidean</code> metric means that the <code>r</code>-neighborhood of a position are all positions whose cartesian indices have Euclidean distance <code>≤ r</code> from the cartesian index of the given position.</p><p>An example using <code>GridSpace</code> is <a href="../examples/schelling/#Schelling&#39;s-segregation-model-1">Schelling&#39;s segregation model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/grid.jl#L27-L45">source</a></section></article><h3 id="Continuous-spaces-1"><a class="docs-heading-anchor" href="#Continuous-spaces-1">Continuous spaces</a><a class="docs-heading-anchor-permalink" href="#Continuous-spaces-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousSpace" href="#Agents.ContinuousSpace"><code>Agents.ContinuousSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousSpace(extent::NTuple{D, &lt;:Real}; kwargs...)</code></pre><p>Create a <code>D</code>-dimensional <code>ContinuousSpace</code> in range 0 to (but not including) <code>extent</code>. Your agent positions (field <code>pos</code>) must be of type <code>NTuple{D, &lt;:Real}</code>, and it is strongly recommend that agents also have a field <code>vel::NTuple{D, &lt;:Real}</code> to use in conjunction with <a href="#Agents.move_agent!"><code>move_agent!</code></a>. Use <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a> for convenience.</p><p><code>ContinuousSpace</code> is a <em>true</em> representation of agent dynamics on a continuous medium where agent position, orientation, and speed, are true floats. In addition, strong support is provided for representing spatial properties in a model that contains a <code>ContinuousSpace</code>. Spatial properties (which typically are contained in  the model properties) can either be functions of the position vector, <code>f(pos) = value</code>, or <code>AbstractArrays</code>, representing discretizations of  spatial data that may not be available in analytic form. In the latter case, the position is automatically mapped into the discretization represented by the array. Use <a href="#Agents.get_spatial_property"><code>get_spatial_property</code></a> to access spatial properties in conjuction with <code>ContinuousSpace</code>.</p><p>See also <a href="#Continuous-space-exclusives-1">Continuous space exclusives</a> on the online docs for more functionality. An example using continuous space is the <a href="../examples/flock/#Flocking-model-1">Flocking model</a>.</p><p><strong>Keywords</strong></p><ul><li><code>periodic = true</code>: Whether the space is periodic or not. If set to <code>false</code> an error will occur if an agent&#39;s position exceeds the boundary.</li><li><code>spacing = min(extent...)/10</code>: Configures an internal compartment spacing that is used to accelerate nearest neighbor searches like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>. All dimensions in <code>extent</code> must be completely divisible by <code>spacing</code>. There is no &quot;best&quot; choice for the value of <code>spacing</code> and if you need optimal performance it&#39;s advised to set up a benchmark over a range of choices.</li><li><code>update_vel!</code>: A <strong>function</strong>, <code>update_vel!(agent, model)</code> that updates the agent&#39;s velocity <strong>before</strong> the agent has been moved, see <a href="#Agents.move_agent!"><code>move_agent!</code></a>. You can of course change the agents&#39; velocities during the agent interaction, the <code>update_vel!</code> functionality targets spatial force fields acting on the agents individually (e.g. some magnetic field). If you use <code>update_vel!</code>, the agent type must have a field <code>vel::NTuple{D, &lt;:Real}</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L13-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OpenStreetMapSpace" href="#Agents.OpenStreetMapSpace"><code>Agents.OpenStreetMapSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OpenStreetMapSpace(path::AbstractString; kwargs...)</code></pre><p>Create a space residing on the Open Street Map (OSM) file provided via <code>path</code>. A sample file is provided using <a href="#Agents.OSM.test_map"><code>OSM.test_map</code></a>. Additional maps can be downloaded using the <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/download_network/">functions provided by LightOSM.jl</a>. The functionality related to Open Street Map spaces is in the submodule <code>OSM</code>. Agents.jl also re-exports <a href="#LightOSM.download_osm_network"><code>OSM.download_osm_network</code></a>. An example usage to download the map of London to &quot;london.json&quot;:</p><pre><code class="language-julia">OSM.download_osm_network(
    :place_name;
    place_name = &quot;London&quot;,
    save_to_file_location = &quot;london.json&quot;
)</code></pre><p>This space represents the underlying map as a <em>continuous</em> entity choosing accuracy over performance. The map is represented as a graph, consisting of nodes connected by edges. Nodes are not necessarily intersections, and there may be multiple nodes on a road joining two intersections. Agents move along the available roads of the map using routing, see below.</p><p>The length of an edge between two nodes is specified in the units of the map&#39;s <code>weight_type</code> as listed in the documentation for <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/types/#LightOSM.OSMGraph"><code>LightOSM.OSMGraph</code></a>. The possible <code>weight_type</code>s are:</p><ul><li><code>:distance</code>: The distance in kilometers of an edge</li><li><code>:time</code>: The time in hours to travel along an edge at the maximum speed allowed on that road</li><li><code>:lane_efficiency</code>: Time scaled by number of lanes</li></ul><p>The default <code>weight_type</code> used is <code>:distance</code>.</p><p>An example of its usage can be found in <a href="../examples/zombies/#Zombie-Outbreak-1">Zombie Outbreak</a>.</p><p>All <code>kwargs</code> are propagated to <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/create_graph/#LightOSM.graph_from_file"><code>LightOSM.graph_from_file</code></a>.</p><p><strong>The <code>OSMAgent</code></strong></p><p>The base properties for an agent residing on an <code>OSMSpace</code> are as follows:</p><pre><code class="language-julia">mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int,Int,Float64}
end</code></pre><p>Current <code>pos</code>ition tuple is represented as <code>(first intersection index, second intersection index, distance travelled)</code>. The distance travelled is in the units of <code>weight_type</code>. This ensures that the map is a <em>continuous</em> kind of space, as an agent can truly be at any possible point on an existing road.</p><p>Use <a href="#Agents.OSMAgent"><code>OSMAgent</code></a> for convenience.</p><p><strong>Routing</strong></p><p>There are two ways to generate a route, depending on the situation.</p><ol><li>Use <a href="#Agents.plan_route!"><code>plan_route!</code></a> to plan a route from an agent&#39;s current position to a target destination. This also has the option of planning a return trip.</li><li><a href="#Agents.OSM.plan_random_route!"><code>plan_random_route!</code></a>, choses a new random destination and plans a path to it.</li></ol><p>Both of these functions override any pre-existing route that may exist for an agent. To actually move along a planned route use <a href="#Agents.move_along_route!"><code>move_along_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L42-L106">source</a></section></article><h2 id="Adding-agents-1"><a class="docs-heading-anchor" href="#Adding-agents-1">Adding agents</a><a class="docs-heading-anchor-permalink" href="#Adding-agents-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent!" href="#Agents.add_agent!"><code>Agents.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent!(agent::AbstractAgent [, pos], model::ABM) → agent</code></pre><p>Add the <code>agent</code> to the model in the given position. If <code>pos</code> is not given, the <code>agent</code> is added to a random position. The <code>agent</code>&#39;s position is always updated to match <code>position</code>, and therefore for <code>add_agent!</code> the position of the <code>agent</code> is meaningless. Use <a href="#Agents.add_agent_pos!"><code>add_agent_pos!</code></a> to use the <code>agent</code>&#39;s position.</p><p>The type of <code>pos</code> must match the underlying space position type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L241-L250">source</a></section><section><div><pre><code class="language-none">add_agent!([pos,] model::ABM, args...; kwargs...) → newagent</code></pre><p>Create and add a new agent to the model using the constructor of the agent type of the model. Optionally provide a position to add the agent to as <em>first argument</em>, which must match the space position type.</p><p>This function takes care of setting the agent&#39;s id <em>and</em> position. The extra provided <code>args...</code> and <code>kwargs...</code> are propagated to other fields of the agent constructor (see example below).</p><pre><code class="language-none">add_agent!([pos,] A::Type, model::ABM, args...; kwargs...) → newagent</code></pre><p>Use this version for mixed agent models, with <code>A</code> the agent type you wish to create (to be called as <code>A(id, pos, args...; kwargs...)</code>), because it is otherwise not possible to deduce a constructor for <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::Int
    w::Float64
    k::Bool
end
Agent(id, pos; w=0.5, k=false) = Agent(id, pos, w, k) # keyword constructor
model = ABM(Agent, GraphSpace(complete_digraph(5)))

add_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally
add_agent!(model, 0.5, true) # correct: w becomes 0.5
add_agent!(5, model, 0.5, true) # add at position 5, w becomes 0.5
add_agent!(model; w = 0.5) # use keywords: w becomes 0.5, k becomes false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L261-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_pos!" href="#Agents.add_agent_pos!"><code>Agents.add_agent_pos!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_pos!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Add the agent to the <code>model</code> at the agent&#39;s own position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L230-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nextid" href="#Agents.nextid"><code>Agents.nextid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextid(model::ABM) → id</code></pre><p>Return a valid <code>id</code> for creating a new agent with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L127-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_position" href="#Agents.random_position"><code>Agents.random_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_position(model) → pos</code></pre><p>Return a random position in the model&#39;s space (always with appropriate Type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L38-L41">source</a></section></article><h2 id="Moving-agents-1"><a class="docs-heading-anchor" href="#Moving-agents-1">Moving agents</a><a class="docs-heading-anchor-permalink" href="#Moving-agents-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent!" href="#Agents.move_agent!"><code>Agents.move_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent!(agent [, pos], model::ABM) → agent</code></pre><p>Move agent to the given position, or to a random one if a position is not given. <code>pos</code> must have the appropriate position type depending on the space type.</p><p>The agent&#39;s position is updated to match <code>pos</code> after the move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L151-L158">source</a></section><section><div><pre><code class="language-none">move_agent!(agent::A, model::ABM{&lt;:ContinuousSpace,A}, dt::Real = 1.0)</code></pre><p>Propagate the agent forwards one step according to its velocity, <em>after</em> updating the agent&#39;s velocity (if configured, see <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>). Also take care of periodic boundary conditions.</p><p>For this continuous space version of <code>move_agent!</code>, the &quot;evolution algorithm&quot; is a trivial Euler scheme with <code>dt</code> the step size, i.e. the agent position is updated as <code>agent.pos += agent.vel * dt</code>. If you want to move the agent to a specified position, do <code>move_agent!(agent, pos, model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L105-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.walk!" href="#Agents.walk!"><code>Agents.walk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">walk!(agent, direction::NTuple, model; ifempty = false)</code></pre><p>Move agent in the given <code>direction</code> respecting periodic boundary conditions. If <code>periodic = false</code>, agents will walk to, but not exceed the boundary value. Possible on both <code>GridSpace</code> and <code>ContinuousSpace</code>s.</p><p>The dimensionality of <code>direction</code> must be the same as the space. <code>GridSpace</code> asks for <code>Int</code>, and <code>ContinuousSpace</code> for <code>Float64</code> vectors, describing the walk distance in each direction. <code>direction = (2, -3)</code> is an example of a valid direction on a <code>GridSpace</code>, which moves the agent to the right 2 positions and down 3 positions. Velocity is ignored for this operation in <code>ContinuousSpace</code>.</p><p><strong>Keywords</strong></p><ul><li><code>ifempty</code> will check that the target position is unnocupied and only move if that&#39;s true. Available only on <code>GridSpace</code>.</li></ul><p>Example usage in <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/battle/">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/utilities.jl#L119-L136">source</a></section><section><div><pre><code class="language-none">walk!(agent, rand, model)</code></pre><p>Invoke a random walk by providing the <code>rand</code> function in place of <code>distance</code>. For <code>GridSpace</code>, the walk will cover ±1 positions in all directions, <code>ContinuousSpace</code> will reside within [-1, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/utilities.jl#L185-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.get_direction" href="#Agents.get_direction"><code>Agents.get_direction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_direction(from, to, model::ABM)</code></pre><p>Return the direction vector from the position <code>from</code> to position <code>to</code> taking into account periodicity of the space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/utilities.jl#L57-L61">source</a></section></article><h3 id="Movement-with-paths-1"><a class="docs-heading-anchor" href="#Movement-with-paths-1">Movement with paths</a><a class="docs-heading-anchor-permalink" href="#Movement-with-paths-1" title="Permalink"></a></h3><p>For <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>, and <a href="#Agents.GridSpace"><code>GridSpace</code></a>/<a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> using <a href="@ref"><code>Pathfinding.Pathfinder</code></a>, a special movement method is available.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.plan_route!" href="#Agents.plan_route!"><code>Agents.plan_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_route!(agent, dest, model::ABM{&lt;:OpenStreetMapSpace};
               return_trip = false, kwargs...)</code></pre><p>Plan a route from the current position of <code>agent</code> to the location specified in <code>dest</code>, which can be an intersection or a point on a road.</p><p>If <code>return_trip = true</code>, a route will be planned from start ⟶ finish ⟶ start. All other keywords are passed to <a href="https://deloittedigitalapac.github.io/LightOSM.jl/docs/shortest_path/#LightOSM.shortest_path"><code>LightOSM.shortest_path</code></a>.</p><p>Returns <code>true</code> if a path to <code>dest</code> exists, and <code>false</code> if it doesn&#39;t. Specifying <code>return_trip = true</code> also requires the existence of a return path for a route to be planned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L195-L209">source</a></section><section><div><pre><code class="language-none">plan_route!(agent, dest, pathfinder::AStar{D})</code></pre><p>Calculate and store the shortest path to move the agent from its current position to <code>dest</code> (a position e.g. <code>(1, 5)</code> or <code>(1.3, 5.2)</code>) using the provided <code>pathfinder</code>.</p><p>Use this method in conjuction with <a href="#Agents.move_along_route!"><code>move_along_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_grid.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.plan_best_route!" href="#Agents.plan_best_route!"><code>Agents.plan_best_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plan_best_route!(agent, dests, pathfinder::AStar{D}; kwargs...)</code></pre><p>Calculate, store, and return the best path to move the agent from its current position to a chosen destination taken from <code>dests</code> using <code>pathfinder</code>.</p><p>The <code>condition = :shortest</code> keyword retuns the shortest path which is shortest out of the possible destinations. Alternatively, the <code>:longest</code> path may also be requested.</p><p>Return the position of the chosen destination. Return <code>nothing</code> if none of the supplied destinations are reachable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_grid.jl#L18-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_along_route!" href="#Agents.move_along_route!"><code>Agents.move_along_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_along_route!(agent, model::ABM{&lt;:OpenStreetMapSpace}, distance::Real) → remaining</code></pre><p>Move an agent by <code>distance</code> along its planned route. Units of distance are as specified by the underlying graph&#39;s weight<em>type. If the provided <code>distance</code> is greater than the distance to the end of the route, return the remaining distance. Otherwise, return <code>0</code>. <code>0</code> is also returned if `is</em>stationary(agent, model)`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L737-L744">source</a></section><section><div><pre><code class="language-none">move_along_route!(agent, model::ABM{&lt;:GridSpace{D}}, pathfinder::AStar{D})</code></pre><p>Move <code>agent</code> for one step along the route toward its target set by <a href="#Agents.plan_route!"><code>plan_route!</code></a></p><p>For pathfinding in models with <a href="#Agents.GridSpace"><code>GridSpace</code></a>.</p><p>If the agent does not have a precalculated path or the path is empty, it remains stationary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_grid.jl#L53-L60">source</a></section><section><div><pre><code class="language-none">move_along_route!(agent, model::ABM{&lt;:ContinuousSpace{D}}, pathfinder::AStar{D}, speed, dt = 1.0)</code></pre><p>Move <code>agent</code> for one step along the route toward its target set by <a href="#Agents.plan_route!"><code>plan_route!</code></a> at the given <code>speed</code> and timestep <code>dt</code>.</p><p>For pathfinding in models with <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a></p><p>If the agent does not have a precalculated path or the path is empty, it remains stationary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_continuous.jl#L91-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.is_stationary" href="#Agents.is_stationary"><code>Agents.is_stationary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_stationary(agent, model)</code></pre><p>Return <code>true</code> if agent has reached the end of its route, or no route has been set for it. Used in setups where using <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L141-L145">source</a></section></article><h2 id="Removing-agents-1"><a class="docs-heading-anchor" href="#Removing-agents-1">Removing agents</a><a class="docs-heading-anchor-permalink" href="#Removing-agents-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.kill_agent!" href="#Agents.kill_agent!"><code>Agents.kill_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kill_agent!(agent::AbstractAgent, model::ABM)
kill_agent!(id::Int, model::ABM)</code></pre><p>Remove an agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L166-L171">source</a></section><section><div><pre><code class="language-none">Pathfinding.kill_agent!(agent, model, pathfinder)</code></pre><p>The same as <code>kill_agent!(agent, model)</code>, but also removes the agent&#39;s path data from <code>pathfinder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar.jl#L223-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.genocide!" href="#Agents.genocide!"><code>Agents.genocide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genocide!(model::ABM)</code></pre><p>Kill all the agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L179-L182">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, n::Int)</code></pre><p>Kill the agents whose IDs are larger than n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L190-L193">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, IDs)</code></pre><p>Kill the agents with the given IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L201-L204">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, f::Function)</code></pre><p>Kill all agents where the function <code>f(agent)</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L211-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.sample!" href="#Agents.sample!"><code>Agents.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample!(model::ABM, n [, weight]; kwargs...)</code></pre><p>Replace the agents of the <code>model</code> with a random sample of the current agents with size <code>n</code>.</p><p>Optionally, provide a <code>weight</code>: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the <code>weight</code> of the agent, the higher the probability that this agent will be chosen in the new sampling.</p><p><strong>Keywords</strong></p><ul><li><code>replace = true</code> : whether sampling is performed with replacement, i.e. all agents can</li></ul><p>be chosen more than once.</p><p>Example usage in <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/wright-fisher/">Wright-Fisher model of evolution</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/sample.jl#L4-L20">source</a></section></article><h2 id="Discrete-space-exclusives-1"><a class="docs-heading-anchor" href="#Discrete-space-exclusives-1">Discrete space exclusives</a><a class="docs-heading-anchor-permalink" href="#Discrete-space-exclusives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.positions" href="#Agents.positions"><code>Agents.positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">positions(model::ABM{&lt;:DiscreteSpace}) → ns</code></pre><p>Return an iterator over all positions of a model with a discrete space.</p><pre><code class="language-none">positions(model::ABM{&lt;:DiscreteSpace}, by::Symbol) → ns</code></pre><p>Return all positions of a model with a discrete space, sorting them using the argument <code>by</code> which can be:</p><ul><li><code>:random</code> - randomly sorted</li><li><code>:population</code> - positions are sorted depending on how many agents they accommodate. The more populated positions are first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.ids_in_position" href="#Agents.ids_in_position"><code>Agents.ids_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ids_in_position(position, model::ABM{&lt;:DiscreteSpace})
ids_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the ids of agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.agents_in_position" href="#Agents.agents_in_position"><code>Agents.agents_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">agents_in_position(position, model::ABM{&lt;:DiscreteSpace})
agents_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.fill_space!" href="#Agents.fill_space!"><code>Agents.fill_space!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, args...; kwargs...)
fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, f::Function; kwargs...)</code></pre><p>Add one agent to each position in the model&#39;s space. Similarly with <a href="#Agents.add_agent!"><code>add_agent!</code></a>, the function creates the necessary agents and the <code>args...; kwargs...</code> are propagated into agent creation. If instead of <code>args...</code> a function <code>f</code> is provided, then <code>args = f(pos)</code> is the result of applying <code>f</code> where <code>pos</code> is each position (tuple for grid, integer index for graph).</p><p>An optional first argument is an agent <strong>type</strong> to be created, and targets mixed agent models where the agent constructor cannot be deduced (since it is a union).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L139-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.has_empty_positions" href="#Agents.has_empty_positions"><code>Agents.has_empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_empty_positions(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are any positions in the model without agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.empty_positions" href="#Agents.empty_positions"><code>Agents.empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty_positions(model)</code></pre><p>Return a list of positions that currently have no agents on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_empty" href="#Agents.random_empty"><code>Agents.random_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_empty(model::ABM{&lt;:DiscreteSpace}, cutoff = 0.998)</code></pre><p>Return a random position without any agents, or <code>nothing</code> if no such positions exist. <code>cutoff</code> switches the search algorithm from probabalistic to a filter.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_single!" href="#Agents.add_agent_single!"><code>Agents.add_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agent</code></pre><p>Add the <code>agent</code> to a random position in the space while respecting a maximum of one agent per position, updating the agent&#39;s position to the new one.</p><p>This function does nothing if there aren&#39;t any empty positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L111-L118">source</a></section><section><div><pre><code class="language-none">add_agent_single!(model::ABM{&lt;:DiscreteSpace}, properties...; kwargs...)</code></pre><p>Same as <code>add_agent!(model, properties...; kwargs...)</code> but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent_single!" href="#Agents.move_agent_single!"><code>Agents.move_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agent</code></pre><p>Move agent to a random position while respecting a maximum of one agent per position. If there are no empty positions, the agent won&#39;t move.</p><p>The keyword <code>cutoff = 0.998</code> is sent to <a href="#Agents.random_empty"><code>random_empty</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L181-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Integer, AgentBasedModel}" href="#Base.isempty-Tuple{Integer, AgentBasedModel}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(position, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are no agents in <code>position</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/discrete.jl#L66-L69">source</a></section></article><h2 id="Continuous-space-exclusives-1"><a class="docs-heading-anchor" href="#Continuous-space-exclusives-1">Continuous space exclusives</a><a class="docs-heading-anchor-permalink" href="#Continuous-space-exclusives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.get_spatial_property" href="#Agents.get_spatial_property"><code>Agents.get_spatial_property</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_spatial_property(pos::NTuple{D, Float64}, property::AbstractArray, model::ABM)</code></pre><p>Convert the continuous agent position into an appropriate <code>index</code> of <code>property</code>, which represents some discretization of a spatial field over a <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. Then, return <code>property[index]</code>. To get the <code>index</code> directly, for e.g. mutating the <code>property</code> in-place, use <a href="#Agents.get_spatial_index"><code>get_spatial_index</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L430-L436">source</a></section><section><div><pre><code class="language-none">get_spatial_property(pos::NTuple{D, Float64}, property, model::ABM)</code></pre><p>Literally equivalent with <code>property(pos, model)</code>, useful when <code>property</code> is a function, or a function-like object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L461-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.get_spatial_index" href="#Agents.get_spatial_index"><code>Agents.get_spatial_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_spatial_index(pos, property::AbstractArray, model::ABM)</code></pre><p>Convert the continuous agent position into an appropriate <code>index</code> of <code>property</code>, which represents some discretization of a spatial field over a <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>.</p><p>The dimensionality of <code>property</code> and the continuous space do not have to match. If <code>property</code> has lower dimensionalty than the space (e.g. representing some surface  property in 3D space) then the necessary starting dimensions of <code>pos</code> will be used to index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L442-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.interacting_pairs" href="#Agents.interacting_pairs"><code>Agents.interacting_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interacting_pairs(model, r, method; scheduler = model.scheduler)</code></pre><p>Return an iterator that yields unique pairs of agents <code>(a1, a2)</code> that are close neighbors to each other, within some interaction radius <code>r</code>.</p><p>This function is usefully combined with <code>model_step!</code>, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with <code>a1</code> and with <code>a2</code>, which is unavoidable when using <code>agent_step!</code>).</p><p>The argument <code>method</code> provides three pairing scenarios</p><ul><li><code>:all</code>: return every pair of agents that are within radius <code>r</code> of each other, not only the nearest ones.</li><li><code>:nearest</code>: agents are only paired with their true nearest neighbor (existing within radius <code>r</code>). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by distance, then by next id in <code>scheduler</code>) will be paired.</li><li><code>:types</code>: For mixed agent models only. Return every pair of agents within radius <code>r</code> (similar to <code>:all</code>), only capturing pairs of differing types. For example, a model of <code>Union{Sheep,Wolf}</code> will only return pairs of <code>(Sheep, Wolf)</code>. In the case of multiple agent types, <em>e.g.</em> <code>Union{Sheep, Wolf, Grass}</code>, skipping pairings that involve <code>Grass</code>, can be achived by a <a href="#Schedulers-1"><code>scheduler</code></a> that doesn&#39;t schedule <code>Grass</code> types, <em>i.e.</em>: <code>scheduler(model) = (a.id for a in allagents(model) if !(a isa Grass))</code>.</li></ul><p>Example usage in <a href="@ref">https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/growing_bacteria/</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L286-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearest_neighbor" href="#Agents.nearest_neighbor"><code>Agents.nearest_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearest_neighbor(agent, model::ABM{&lt;:ContinuousSpace}, r) → nearest</code></pre><p>Return the agent that has the closest distance to given <code>agent</code>. Return <code>nothing</code> if no agent is within distance <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L207-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.elastic_collision!" href="#Agents.elastic_collision!"><code>Agents.elastic_collision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elastic_collision!(a, b, f = nothing)</code></pre><p>Resolve a (hypothetical) elastic collision between the two agents <code>a, b</code>. They are assumed to be disks of equal size touching tangentially. Their velocities (field <code>vel</code>) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.</p><p>If <code>f</code> is a <code>Symbol</code>, then the agent property <code>f</code>, e.g. <code>:mass</code>, is taken as a mass to weight the two agents for the collision. By default no weighting happens.</p><p>One of the two agents can have infinite &quot;mass&quot;, and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.</p><p>Example usage in <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/social_distancing/">Continuous space social distancing</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/continuous.jl#L232-L249">source</a></section></article><h2 id="Graph-space-exclusives-1"><a class="docs-heading-anchor" href="#Graph-space-exclusives-1">Graph space exclusives</a><a class="docs-heading-anchor-permalink" href="#Graph-space-exclusives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Graphs.SimpleGraphs.add_edge!" href="#Graphs.SimpleGraphs.add_edge!"><code>Graphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_edge!(model::ABM{&lt;: GraphSpace}, n::Int, m::Int)</code></pre><p>Add a new edge (relationship between two positions) to the graph. Returns a boolean, true if the operation was succesful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/graph.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_node!" href="#Agents.add_node!"><code>Agents.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_node!(model::ABM{&lt;: GraphSpace})</code></pre><p>Add a new node (i.e. possible position) to the model&#39;s graph and return it. You can connect this new node with existing ones using <a href="#Graphs.SimpleGraphs.add_edge!"><code>add_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/graph.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.rem_node!" href="#Agents.rem_node!"><code>Agents.rem_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rem_node!(model::ABM{&lt;: GraphSpace}, n::Int)</code></pre><p>Remove node (i.e. position) <code>n</code> from the model&#39;s graph. All agents in that node are killed.</p><p><strong>Warning:</strong> Graphs.jl (and thus Agents.jl) swaps the index of the last node with that of the one to be removed, while every other node remains as is. This means that when doing <code>rem_node!(n, model)</code> the last node becomes the <code>n</code>-th node while the previous <code>n</code>-th node (and all its edges and agents) are deleted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/graph.jl#L102-L110">source</a></section></article><h2 id="OpenStreetMap-space-exclusives-1"><a class="docs-heading-anchor" href="#OpenStreetMap-space-exclusives-1">OpenStreetMap space exclusives</a><a class="docs-heading-anchor-permalink" href="#OpenStreetMap-space-exclusives-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM" href="#Agents.OSM"><code>Agents.OSM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">OSM</code></pre><p>Submodule for functionality related to <code>OpenStreetMapSpace</code>. See the docstring of the space for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.lonlat" href="#Agents.OSM.lonlat"><code>Agents.OSM.lonlat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.lonlat(pos, model)
OSM.lonlat(agent, model)</code></pre><p>Return <code>(longitude, latitude)</code> of current road or intersection position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L477-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.nearest_node" href="#Agents.OSM.nearest_node"><code>Agents.OSM.nearest_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.nearest_node(lonlat::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return the nearest intersection position to <strong>(longitude, latitude)</strong>. Quicker, but less precise than <a href="#Agents.OSM.nearest_road"><code>OSM.nearest_road</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L512-L517">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.nearest_road" href="#Agents.OSM.nearest_road"><code>Agents.OSM.nearest_road</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.nearest_road(lonlat::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return a location on a road nearest to <strong>(longitude, latitude)</strong>. Significantly slower, but more precise than <a href="#Agents.OSM.nearest_node"><code>OSM.nearest_node</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L526-L531">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.random_road_position" href="#Agents.OSM.random_road_position"><code>Agents.OSM.random_road_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.random_road_position(model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Similar to <a href="#Agents.random_position"><code>random_position</code></a>, but rather than providing only intersections, this method returns a location somewhere on a road heading in a random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.plan_random_route!" href="#Agents.OSM.plan_random_route!"><code>Agents.OSM.plan_random_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.plan_random_route!(agent, model::ABM{&lt;:OpenStreetMapSpace}; kwargs...) → success</code></pre><p>Plan a new random route for the agent, by selecting a random destination and planning a route from the agent&#39;s current position. Overwrite any existing route.</p><p>The keyword <code>limit = 10</code> specifies the limit on the number of attempts at planning a random route, as no connection may be possible given the random start and end. Return <code>true</code> if a route was successfully planned, <code>false</code> otherwise. All other keywords are passed to <a href="#Agents.plan_route!"><code>plan_route!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L163-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.road_length" href="#Agents.OSM.road_length"><code>Agents.OSM.road_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.road_length(start::Int, finish::Int, model)
OSM.road_length(pos::Tuple{Int,Int,Float64}, model)</code></pre><p>Return the road length between two intersections. This takes into account the direction of the road, so <code>OSM.road_length(pos_1, pos_2, model)</code> may not be the same as <code>OSM.road_length(pos_2, pos_1, mode)</code>. Units of the returned quantity are as specified by the underlying graph&#39;s <code>weight_type</code>. If <code>start</code> and <code>finish</code> are the same or <code>pos[1]</code> and <code>pos[2]</code> are the same, then return 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L572-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.same_position" href="#Agents.OSM.same_position"><code>Agents.OSM.same_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.same_position(a::Tuple{Int,Int,Float64}, b::Tuple{Int,Int,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return <code>true</code> if the given positions <code>a</code> and <code>b</code> are (approximately) identical</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L614-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.same_road" href="#Agents.OSM.same_road"><code>Agents.OSM.same_road</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.same_road(a::Tuple{Int,Int,Float64}, b::Tuple{Int,Int,Float64})</code></pre><p>Return <code>true</code> if both points lie on the same road of the graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L675-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.test_map" href="#Agents.OSM.test_map"><code>Agents.OSM.test_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.test_map()</code></pre><p>Download a small test map of <a href="https://www.openstreetmap.org/export#map=16/51.5333/9.9363">Göttingen</a> as an artifact. Return a path to the downloaded file.</p><p>Using this map requires <code>network_type = :none</code> to be passed as a keyword to <a href="@ref"><code>OSMSpace</code></a>. The unit of distance used for this map is <code>:time</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/openstreetmap.jl#L130-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightOSM.download_osm_network" href="#LightOSM.download_osm_network"><code>LightOSM.download_osm_network</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">download_osm_network(download_method::Symbol;
                     network_type::Symbol=:drive,
                     metadata::Bool=false,
                     download_format::Symbol=:json,
                     save_to_file_location::Union{String,Nothing}=nothing,
                     download_kwargs...
                     )::Union{XMLDocument,Dict{String,Any}}</code></pre><p>Downloads an OpenStreetMap network by querying with a place name, bounding box, or centroid point.</p><p><strong>Arguments</strong></p><ul><li><code>download_method::Symbol</code>: Download method, choose from <code>:place_name</code>, <code>:bbox</code> or <code>:point</code>.</li><li><code>network_type::Symbol=:drive</code>: Network type filter, pick from <code>:drive</code>, <code>:drive_service</code>, <code>:walk</code>, <code>:bike</code>, <code>:all</code>, <code>:all_private</code>, <code>:none</code>, <code>:rail</code></li><li><code>metadata::Bool=false</code>: Set true to return metadata.</li><li><code>download_format::Symbol=:json</code>: Download format, either <code>:osm</code>, <code>:xml</code> or <code>json</code>.</li><li><code>save_to_file_location::Union{String,Nothing}=nothing</code>: Specify a file location to save downloaded data to disk.</li></ul><p><strong>Required Kwargs for each Download Method</strong></p><p><em><code>download_method=:place_name</code></em></p><ul><li><code>place_name::String</code>: Any place name string used as a search argument to the Nominatim API.</li></ul><p><em><code>download_method=:bbox</code></em></p><ul><li><code>minlat::AbstractFloat</code>: Bottom left bounding box latitude coordinate.</li><li><code>minlon::AbstractFloat</code>: Bottom left bounding box longitude coordinate.</li><li><code>maxlat::AbstractFloat</code>: Top right bounding box latitude coordinate.</li><li><code>maxlon::AbstractFloat</code>: Top right bounding box longitude coordinate.</li></ul><p><em><code>download_method=:point</code></em></p><ul><li><code>point::GeoLocation</code>: Centroid point to draw the bounding box around.</li><li><code>radius::Number</code>: Distance (km) from centroid point to each bounding box corner.</li></ul><p><em><code>download_method=:polygon</code></em></p><ul><li><code>polygon::AbstractVector</code>: Vector of longitude-latitude pairs.</li></ul><p><strong>Network Types</strong></p><ul><li><code>:drive</code>: Motorways excluding private and service ways.</li><li><code>:drive_service</code>: Motorways including private and service ways.</li><li><code>:walk</code>: Walkways only.</li><li><code>:bike</code>: Cycleways only.</li><li><code>:all</code>: All motorways, walkways and cycleways excluding private ways.</li><li><code>:all_private</code>: All motorways, walkways and cycleways including private ways.</li><li><code>:none</code>: No network filters.</li><li><code>:rail</code>: Railways excluding proposed and platform.</li></ul><p><strong>Return</strong></p><ul><li><code>Union{XMLDocument,Dict{String,Any}}</code>: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.</li></ul></div></section></article><h2 id="Nearby-Agents-1"><a class="docs-heading-anchor" href="#Nearby-Agents-1">Nearby Agents</a><a class="docs-heading-anchor-permalink" href="#Nearby-Agents-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_ids" href="#Agents.nearby_ids"><code>Agents.nearby_ids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_ids(position, model::ABM, r; kwargs...) → ids</code></pre><p>Return an iterable of the ids of the agents within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which must match type with the spatial structure of the <code>model</code>)</p><p>What the &quot;radius&quot; means depends on the space type:</p><ul><li><code>GraphSpace</code>: the degree of neighbors in the graph (thus <code>r</code> is always an integer), always including ids of the same node as <code>position</code>. For example, for <code>r=2</code> include first and second degree neighbors. If <code>r=0</code>, only ids in the same node as <code>position</code> are returned.</li><li><code>GridSpace</code>: Either Chebyshev (also called Moore) or Euclidean distance, in the space of cartesian indices.</li><li><code>GridSpace</code> can also take a tuple argument, e.g. <code>r = (5, 2)</code> for a 2D space, which extends 5 positions in the x direction and 2 in the y. Only possible with Chebyshev spaces. This can be useful when different coordinates in the space need to be searched with different ranges, e.g., if the space corresponds to a full building, with the third dimension the floor number. See also the  <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/battle/">Battle Royale</a> for advanced usage where one dimension is used as a categorical one.</li><li><code>ContinuousSpace</code>: Standard distance according to the space metric.</li><li><code>OpenStreetMapSpace</code>: <code>r</code> is equivalent with distance (in the <code>weight_type</code> of the space) needed to be travelled according to existing roads in order to reach given <code>position</code>.</li></ul><p><strong>Keywords</strong></p><p>Keyword arguments are space-specific. For <code>GraphSpace</code> the keyword <code>neighbor_type=:default</code> can be used to select differing neighbors depending on the underlying graph directionality type.</p><ul><li><code>:default</code> returns neighbors of a vertex (position). If graph is directed, this is equivalent to <code>:out</code>. For undirected graphs, all options are equivalent to <code>:out</code>.</li><li><code>:all</code> returns both <code>:in</code> and <code>:out</code> neighbors.</li><li><code>:in</code> returns incoming vertex neighbors.</li><li><code>:out</code> returns outgoing vertex neighbors.</li></ul><p>For <code>ContinuousSpace</code>, the keyword <code>exact=false</code> controls whether the found neighbors are exactly accurate or approximate (with approximate always being a strict over-estimation), see <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>.</p><p>In periodic discrete or continuous spaces, when used with a radius larger than half of the entire space, this function may find the same agent(s) more than once. See Issue #566 online for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L63-L104">source</a></section><section><div><pre><code class="language-none">nearby_ids(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_ids(agent.pos, model, r)</code> but the iterable <em>excludes</em> the given <code>agent</code>&#39;s id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L328-L333">source</a></section><section><div><pre><code class="language-none">nearby_ids(pos, model::ABM{&lt;:GridSpace}, r::Vector{Tuple{Int,UnitRange{Int}}})</code></pre><p>Return an iterable of ids over specified dimensions of <code>space</code> with fine grained control of distances from <code>pos</code> using each value of <code>r</code> via the (dimension, range) pattern.</p><p><strong>Note:</strong> Only available for use with non-periodic chebyshev grids.</p><p>Example, with a <code>GridSpace((100, 100, 10))</code>: <code>r = [(1, -1:1), (3, 1:2)]</code> searches dimension 1 one step either side of the current position (as well as the current position) and the third dimension searches two positions above current.</p><p>For a complete tutorial on how to use this advanced method, see <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/battle/">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/grid.jl#L218-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_agents" href="#Agents.nearby_agents"><code>Agents.nearby_agents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_agents(agent, model::ABM, r = 1; kwargs...) -&gt; agent</code></pre><p>Return an iterable of the agents near the position of the given <code>agent</code>.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L358-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_positions" href="#Agents.nearby_positions"><code>Agents.nearby_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_positions(position, model::ABM, r=1; kwargs...) → positions</code></pre><p>Return an iterable of all positions within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which excludes given <code>position</code>). The <code>position</code> must match type with the spatial structure of the <code>model</code>.</p><p>The value of <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p><p>This function only makes sense for discrete spaces with a finite amount of positions.</p><pre><code class="language-none">nearby_positions(position, model::ABM{&lt;:OpenStreetMapSpace}; kwargs...) → positions</code></pre><p>For <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a> this means &quot;nearby intersections&quot; and operates directly on the underlying graph of the OSM, providing the intersection nodes nearest to the given position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L107-L123">source</a></section><section><div><pre><code class="language-none">nearby_positions(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_positions(agent.pos, model, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_nearby_id" href="#Agents.random_nearby_id"><code>Agents.random_nearby_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_nearby_id(agent, model::ABM, r = 1; kwargs...) → id</code></pre><p>Return the <code>id</code> of a random agent near the position of the given <code>agent</code> using an optimized algorithm from <a href="https://en.wikipedia.org/wiki/Reservoir_sampling#An_optimal_algorithm">Reservoir sampling</a>. Return <code>nothing</code> if no agents are nearby.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L368-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_nearby_agent" href="#Agents.random_nearby_agent"><code>Agents.random_nearby_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_nearby_agent(agent, model::ABM, r = 1; kwargs...) → agent</code></pre><p>Return the a random agent near the position of the given <code>agent</code>. Return <code>nothing</code> if no agent is nearby.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/space_interaction_API.jl#L405-L412">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.edistance" href="#Agents.edistance"><code>Agents.edistance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edistance(a, b, model::ABM)</code></pre><p>Return the euclidean distance between <code>a</code> and <code>b</code> (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently <code>GridSpace</code> and <code>ContinuousSpace</code>.</p><p>Example usage in the <a href="../examples/flock/#Flocking-model-1">Flocking model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/spaces/utilities.jl#L6-L14">source</a></section></article><h2 id="A-note-on-iteration-1"><a class="docs-heading-anchor" href="#A-note-on-iteration-1">A note on iteration</a><a class="docs-heading-anchor-permalink" href="#A-note-on-iteration-1" title="Permalink"></a></h2><p>Most iteration in Agents.jl is <strong>dynamic</strong> and <strong>lazy</strong>, when possible, for performance reasons.</p><p><strong>Dynamic</strong> means that when iterating over the result of e.g. the <a href="#Agents.ids_in_position"><code>ids_in_position</code></a> function, the iterator will be affected by actions that would alter its contents. Specifically, imagine the scenario</p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::NTuple{4, Int}
end

model = ABM(Agent, GridSpace((5, 5, 5, 5)))
add_agent!((1, 1, 1, 1), model)
add_agent!((1, 1, 1, 1), model)
add_agent!((2, 1, 1, 1), model)
for id in ids_in_position((1, 1, 1, 1), model)
    kill_agent!(id, model)
end
collect(allids(model))</code></pre><pre><code class="language-none">2-element Vector{Int64}:
 2
 3</code></pre><p>You will notice that only 1 agent got killed. This is simply because the final state of the iteration of <code>ids_in_position</code> was reached unnaturally, because the length of its output was reduced by 1 <em>during</em> iteration. To avoid problems like these, you need to <code>collect</code> the iterator to have a non dynamic version.</p><p><strong>Lazy</strong> means that when possible the outputs of the iteration are not collected and instead are generated on the fly. A good example to illustrate this is <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>, where doing something like</p><pre><code class="language-julia">a = random_agent(model)
sort!(nearby_ids(random_agent(model), model))</code></pre><p>leads to error, since you cannot <code>sort!</code> the returned iterator. This can be easily solved by adding a <code>collect</code> in between:</p><pre><code class="language-julia">a = random_agent(model)
sort!(collect(nearby_agents(a, model)))</code></pre><pre><code class="language-none">1-element Vector{Main.ex-docs.Agent}:
 Main.ex-docs.Agent(2, (1, 1, 1, 1))</code></pre><h2 id="Higher-order-interactions-1"><a class="docs-heading-anchor" href="#Higher-order-interactions-1">Higher-order interactions</a><a class="docs-heading-anchor-permalink" href="#Higher-order-interactions-1" title="Permalink"></a></h2><p>There may be times when pair-wise, triplet-wise or higher interactions need to be accounted for across most or all of the model&#39;s agent population. The following methods provide an interface for such calculation.</p><p>These methods follow the conventions outlined above in <a href="#A-note-on-iteration-1">A note on iteration</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.iter_agent_groups" href="#Agents.iter_agent_groups"><code>Agents.iter_agent_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iter_agent_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)</code></pre><p>Return an iterator over all agents of the model, grouped by order. When <code>order = 2</code>, the iterator returns agent pairs, e.g <code>(agent1, agent2)</code> and when <code>order = 3</code>: agent triples, e.g. <code>(agent1, agent7, agent8)</code>. <code>order</code> must be larger than <code>1</code> but has no upper bound.</p><p>Index order is provided by the <a href="@ref"><code>Schedulers.by_id</code></a> scheduler by default, but can be altered with the <code>scheduler</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L236-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.map_agent_groups" href="#Agents.map_agent_groups"><code>Agents.map_agent_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_agent_groups(order::Int, f::Function, model::ABM; kwargs...)
map_agent_groups(order::Int, f::Function, model::ABM, filter::Function; kwargs...)</code></pre><p>Applies function <code>f</code> to all grouped agents of an <a href="#Agents.iter_agent_groups"><code>iter_agent_groups</code></a> iterator. <code>kwargs</code> are passed to the iterator method. <code>f</code> must take the form <code>f(NTuple{O,AgentType})</code>, where the dimension <code>O</code> is equal to <code>order</code>.</p><p>Optionally, a <code>filter</code> function that accepts an iterable and returns a <code>Bool</code> can be applied to remove unwanted matches from the results. <strong>Note:</strong> This option cannot keep matrix order, so should be used in conjuction with <a href="#Agents.index_mapped_groups"><code>index_mapped_groups</code></a> to associate agent ids with the resultant data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L249-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.index_mapped_groups" href="#Agents.index_mapped_groups"><code>Agents.index_mapped_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index_mapped_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)
index_mapped_groups(order::Int, model::ABM, filter::Function; scheduler = Schedulers.by_id)</code></pre><p>Return an iterable of agent ids in the model, meeting the <code>filter</code> criteria if used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/core/model.jl#L268-L272">source</a></section></article><h2 id="Parameter-scanning-1"><a class="docs-heading-anchor" href="#Parameter-scanning-1">Parameter scanning</a><a class="docs-heading-anchor-permalink" href="#Parameter-scanning-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.paramscan" href="#Agents.paramscan"><code>Agents.paramscan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">paramscan(parameters, initialize; kwargs...) → adf, mdf</code></pre><p>Perform a parameter scan of a ABM simulation output by collecting data from all parameter combinations into dataframes (one for agent data, one for model data). The dataframes columns are both the collected data (as in <a href="../tutorial/#Agents.run!"><code>run!</code></a>) but also the input parameter values used.</p><p><code>parameters</code> is a dictionary with key type <code>Symbol</code> which contains various parameters that will be scanned over (as well as other parameters that remain constant). This function uses <code>DrWatson</code>&#39;s <a href="https://juliadynamics.github.io/DrWatson.jl/dev/run&amp;list/#DrWatson.dict_list"><code>dict_list</code></a> convention. This means that every entry of <code>parameters</code> that is a <code>Vector</code> contains many parameters and thus is scanned. All other entries of <code>parameters</code> that are not <code>Vector</code>s are not expanded in the scan.</p><p>The second argument <code>initialize</code> is a function that creates an ABM and returns it. It must accept keyword arguments which are the <em>keys</em> of the <code>parameters</code> dictionary. Since the user decides how to use input arguments to make an ABM, <code>parameters</code> can be used to affect model properties, space type and creation as well as agent properties, see the example below.</p><p><strong>Keywords</strong></p><p>The following keywords modify the <code>paramscan</code> function:</p><ul><li><code>include_constants::Bool = false</code>: by default, only the varying parameters (Vector in <code>parameters</code>) will be included in the output <code>DataFrame</code>. If <code>true</code>, constant parameters (non-Vector in <code>parameteres</code>) will also be included.</li><li><code>parallel::Bool = false</code> whether <code>Distributed.pmap</code> is invoked to run simulations in parallel. This must be used in conjunction with <code>@everywhere</code> (see <a href="../performance_tips/#Performance-Tips-1">Performance Tips</a>).</li></ul><p>All other keywords are propagated into <a href="../tutorial/#Agents.run!"><code>run!</code></a>. Furthermore, <code>agent_step!, model_step!, n</code> are also keywords here, that are given to <a href="../tutorial/#Agents.run!"><code>run!</code></a> as arguments. Naturally, <code>agent_step!, model_step!, n</code> and at least one of <code>adata, mdata</code> are mandatory. The <code>adata, mdata</code> lists shouldn&#39;t contain the parameters that are already in the <code>parameters</code> dictionary to avoid duplication.</p><p><strong>Example</strong></p><p>A runnable example that uses <code>paramscan</code> is shown in <a href="../examples/schelling/#Schelling&#39;s-segregation-model-1">Schelling&#39;s segregation model</a>. There, we define</p><pre><code class="language-julia">function initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)
    space = GridSpace(griddims, moore = true)
    properties = Dict(:min_to_be_happy =&gt; min_to_be_happy)
    model = ABM(SchellingAgent, space;
                properties = properties, scheduler = Schedulers.randomly)
    for n in 1:numagents
        agent = SchellingAgent(n, (1, 1), false, n &lt; numagents / 2 ? 1 : 2)
        add_agent_single!(agent, model)
    end
    return model
end</code></pre><p>and do a parameter scan by doing:</p><pre><code class="language-julia">happyperc(moods) = count(moods) / length(moods)
adata = [(:mood, happyperc)]

parameters = Dict(
    :min_to_be_happy =&gt; collect(2:5), # expanded
    :numagents =&gt; [200, 300],         # expanded
    :griddims =&gt; (20, 20),            # not Vector = not expanded
)

adf, _ = paramscan(parameters, initialize; adata, agent_step!, n = 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/paramscan.jl#L3-L70">source</a></section></article><h2 id="Data-collection-1"><a class="docs-heading-anchor" href="#Data-collection-1">Data collection</a><a class="docs-heading-anchor-permalink" href="#Data-collection-1" title="Permalink"></a></h2><p>The central simulation function is <a href="../tutorial/#Agents.run!"><code>run!</code></a>, which is mentioned in our <a href="../tutorial/#Tutorial-1">Tutorial</a>. But there are other functions that are related to simulations listed here. Specifically, these functions aid in making custom data collection loops, instead of using the <code>run!</code> function.</p><p>For example, the core loop of <code>run!</code> is just</p><pre><code class="language-julia">df_agent = init_agent_dataframe(model, adata)
df_model = init_model_dataframe(model, mdata)

s = 0
while until(s, n, model)
  if should_we_collect(s, model, when)
      collect_agent_data!(df_agent, model, adata, s)
  end
  if should_we_collect(s, model, when_model)
      collect_model_data!(df_model, model, mdata, s)
  end
  step!(model, agent_step!, model_step!, 1)
  s += 1
end
return df_agent, df_model</code></pre><p>(here <code>until</code> and <code>should_we_collect</code> are internal functions)</p><p><code>run!</code> uses the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.init_agent_dataframe" href="#Agents.init_agent_dataframe"><code>Agents.init_agent_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_agent_dataframe(model, adata) → agent_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/collect.jl#L221-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_agent_data!" href="#Agents.collect_agent_data!"><code>Agents.collect_agent_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_agent_data!(df, model, properties, step = 0; obtainer = identity)</code></pre><p>Collect and add agent data into <code>df</code> (see <a href="../tutorial/#Agents.run!"><code>run!</code></a> for the dispatch rules of <code>properties</code> and <code>obtainer</code>). <code>step</code> is given because the step number information is not known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/collect.jl#L227-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.init_model_dataframe" href="#Agents.init_model_dataframe"><code>Agents.init_model_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_model_dataframe(model, mdata) → model_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_model_data!"><code>collect_model_data!</code></a>. <code>mdata</code> can be a <code>Vector</code> or generator <code>Function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/collect.jl#L505-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_model_data!" href="#Agents.collect_model_data!"><code>Agents.collect_model_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_model_data!(df, model, properties, step = 0, obtainer = identity)</code></pre><p>Same as <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a> but for model data instead. <code>properties</code> can be a <code>Vector</code> or generator <code>Function</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/collect.jl#L545-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.dataname" href="#Agents.dataname"><code>Agents.dataname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dataname(k) → name</code></pre><p>Return the name of the column of the <code>i</code>-th collected data where <code>k = adata[i]</code> (or <code>mdata[i]</code>). <code>dataname</code> also accepts tuples with aggregate and conditional values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/collect.jl#L445-L451">source</a></section></article><h2 id="Schedulers-1"><a class="docs-heading-anchor" href="#Schedulers-1">Schedulers</a><a class="docs-heading-anchor-permalink" href="#Schedulers-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers" href="#Agents.Schedulers"><code>Agents.Schedulers</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Schedulers</code></pre><p>Submodule containing all predefined schedulers of Agents.jl and the scheduling API. Schedulers have a very simple interface. They are functions that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a &quot;true&quot; iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. You can also use the function <code>schedule(model)</code> to obtain the scheduled ID list, if you prefer to write your own <code>step!</code>-like loop.</p><p>See also <a href="#Advanced-scheduling-1">Advanced scheduling</a> for making more advanced schedulers.</p><p>Notice that schedulers can be given directly to model creation, and thus become the &quot;default&quot; scheduler a model uses, but they can just as easily be incorporated in a <code>model_step!</code> function as shown in <a href="../tutorial/#Advanced-stepping-1">Advanced stepping</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L11-L26">source</a></section></article><h3 id="Predefined-schedulers-1"><a class="docs-heading-anchor" href="#Predefined-schedulers-1">Predefined schedulers</a><a class="docs-heading-anchor-permalink" href="#Predefined-schedulers-1" title="Permalink"></a></h3><p>Some useful schedulers are available below as part of the Agents.jl API:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.fastest" href="#Agents.Schedulers.fastest"><code>Agents.Schedulers.fastest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.fastest</code></pre><p>A scheduler that activates all agents once per step in the order dictated by the agent&#39;s container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.ByID" href="#Agents.Schedulers.ByID"><code>Agents.Schedulers.ByID</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Schedulers.ByID()</code></pre><p>A non-allocating scheduler that activates all agents agents at each step according to their id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.Randomly" href="#Agents.Schedulers.Randomly"><code>Agents.Schedulers.Randomly</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Schedulers.Randomly()</code></pre><p>A non-allocating scheduler that activates all agents once per step in a random order. Different random ordering is used at each different step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.Partially" href="#Agents.Schedulers.Partially"><code>Agents.Schedulers.Partially</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Schedulers.Partially(p)</code></pre><p>A non-allocating scheduler that at each step activates only <code>p</code> percentage of randomly chosen agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.ByProperty" href="#Agents.Schedulers.ByProperty"><code>Agents.Schedulers.ByProperty</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Schedulers.ByProperty(property)</code></pre><p>A non-allocating scheduler that at each step activates the agents in an order dictated by their <code>property</code>, with agents with greater <code>property</code> acting first. <code>property</code> can be a <code>Symbol</code>, which just dictates which field of the agents to compare, or a function which inputs an agent and outputs a real number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.ByType" href="#Agents.Schedulers.ByType"><code>Agents.Schedulers.ByType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Schedulers.ByType(shuffle_types::Bool, shuffle_agents::Bool, agent_union)</code></pre><p>A non-allocating scheduler useful only for mixed agent models using <code>Union</code> types.</p><ul><li>Setting <code>shuffle_types = true</code> groups by agent type, but randomizes the type order.</li></ul><p>Otherwise returns agents grouped in order of appearance in the <code>Union</code>.</p><ul><li><code>shuffle_agents = true</code> randomizes the order of agents within each group, <code>false</code> returns</li></ul><p>the default order of the container (equivalent to <a href="#Agents.Schedulers.fastest"><code>Schedulers.fastest</code></a>).</p><ul><li><code>agent_union</code> is a <code>Union</code> of all valid agent types (as passed to <a href="@ref"><code>ABM</code></a>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L239-L247">source</a></section><section><div><pre><code class="language-none">Schedulers.ByType((C, B, A), shuffle_agents::Bool)</code></pre><p>A non-allocating scheduler that activates agents by type in specified order (since <code>Union</code>s are not order preserving). <code>shuffle_agents = true</code> randomizes the order of agents within each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/schedulers.jl#L258-L263">source</a></section></article><h3 id="Advanced-scheduling-1"><a class="docs-heading-anchor" href="#Advanced-scheduling-1">Advanced scheduling</a><a class="docs-heading-anchor-permalink" href="#Advanced-scheduling-1" title="Permalink"></a></h3><p>You can use <a href="https://docs.julialang.org/en/v1/manual/methods/#Function-like-objects">Function-like objects</a> to make your scheduling possible of arbitrary events. For example, imagine that after the <code>n</code>-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define</p><pre><code class="language-julia">mutable struct MyScheduler
    n::Int # step number
    w::Float64
end</code></pre><p>and then define a calling method for it like so</p><pre><code class="language-julia">function (ms::MyScheduler)(model::ABM)
    ms.n += 1 # increment internal counter by 1 each time its called
              # be careful to use a *new* instance of this scheduler when plotting!
    if ms.n &lt; 10
        return allids(model) # order doesn&#39;t matter in this case
    else
        ids = collect(allids(model))
        # filter all ids whose agents have `w` less than some amount
        filter!(id -&gt; model[id].w &lt; ms.w, ids)
        return ids
    end
end</code></pre><p>and pass it to e.g. <code>step!</code> by initializing it</p><pre><code class="language-julia">ms = MyScheduler(100, 0.5)
step!(model, agentstep, modelstep, 100; scheduler = ms)</code></pre><h2 id="Ensemble-runs-and-Parallelization-1"><a class="docs-heading-anchor" href="#Ensemble-runs-and-Parallelization-1">Ensemble runs and Parallelization</a><a class="docs-heading-anchor-permalink" href="#Ensemble-runs-and-Parallelization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.ensemblerun!" href="#Agents.ensemblerun!"><code>Agents.ensemblerun!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ensemblerun!(models::Vector, agent_step!, model_step!, n; kwargs...)</code></pre><p>Perform an ensemble simulation of <a href="../tutorial/#Agents.run!"><code>run!</code></a> for all <code>model ∈ models</code>. Each <code>model</code> should be a (different) instance of an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> but probably initialized with a different random seed or different initial agent distribution. All models obey the same rules <code>agent_step!, model_step!</code> and are evolved for <code>n</code>.</p><p>Similarly to <a href="../tutorial/#Agents.run!"><code>run!</code></a> this function will collect data. It will furthermore add one additional column to the dataframe called <code>:ensemble</code>, which has an integer value counting the ensemble member. The function returns <code>agent_df, model_df, models</code>.</p><p>The keyword <code>parallel = false</code>, when <code>true</code>, will run the simulations in parallel using Julia&#39;s <code>Distributed.pmap</code> (you need to have loaded <code>Agents</code> with <code>@everywhere</code>, see docs online).</p><p>All other keywords are propagated to <a href="../tutorial/#Agents.run!"><code>run!</code></a> as-is.</p><p>Example usage in <a href="../examples/schelling/#Schelling&#39;s-segregation-model-1">Schelling&#39;s segregation model</a>.</p><p>If you want to scan parameters and at the same time run multiple simulations at each parameter combination, simply use <code>seed</code> as a parameter, and use that parameter to tune the model&#39;s initial random seed and agent distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/ensemblerun.jl#L4-L26">source</a></section><section><div><pre><code class="language-none">ensemblerun!(generator, agent_step!, model_step!, n; kwargs...)</code></pre><p>Generate many <code>ABM</code>s and propagate them into <code>ensemblerun!(models, ...)</code> using the provided <code>generator</code> which is a one-argument function whose input is a seed.</p><p>This method has additional keywords <code>ensemble = 5, seeds = rand(UInt32, ensemble)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/simulations/ensemblerun.jl#L42-L48">source</a></section></article><h3 id="How-to-use-Distributed-1"><a class="docs-heading-anchor" href="#How-to-use-Distributed-1">How to use <code>Distributed</code></a><a class="docs-heading-anchor-permalink" href="#How-to-use-Distributed-1" title="Permalink"></a></h3><p>To use the <code>parallel=true</code> option of <a href="#Agents.ensemblerun!"><code>ensemblerun!</code></a> you need to load <code>Agents</code> and define your fundamental types at all processors. How to do this is shown in <a href="../examples/schelling/#Ensembles-and-distributed-computing-1">Ensembles and distributed computing</a> section of Schelling&#39;s Segregation Model example. See also the <a href="../performance_tips/#Performance-Tips-1">Performance Tips</a> page for parallelization.</p><h2 id="Path-finding-1"><a class="docs-heading-anchor" href="#Path-finding-1">Path-finding</a><a class="docs-heading-anchor-permalink" href="#Path-finding-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding" href="#Agents.Pathfinding"><code>Agents.Pathfinding</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Pathfinding</code></pre><p>Submodule containing functionality for path-finding based on the A* algorithm. Currently available for <a href="#Agents.GridSpace"><code>GridSpace</code></a> and <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. Discretization of <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> is taken care of internally.</p><p>You can enable path-finding and set its options by creating an instance of a <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a> struct. This must be passed to the relevant pathfinding functions during the simulation. Call <a href="#Agents.plan_route!"><code>plan_route!</code></a> to set the destination for an agent. This triggers the algorithm to calculate a path from the agent&#39;s current position to the one specified. You can alternatively use <a href="#Agents.plan_best_route!"><code>plan_best_route!</code></a> to choose the best target from a list. Once a target has been set, you can move an agent one step along its precalculated path using the <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> function.</p><p>Refer to the <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/maze/">Maze Solver</a>, <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/runners/">Mountain Runners</a> and <a href="../examples/rabbit_fox_hawk/#Rabbit,-Fox,-Hawk-1">Rabbit, Fox, Hawk</a> examples using path-finding and see the available functions below as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/Pathfinding.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.AStar" href="#Agents.Pathfinding.AStar"><code>Agents.Pathfinding.AStar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.AStar(space; kwargs...)</code></pre><p>Enables pathfinding for agents in the provided <code>space</code> (which can be a <a href="#Agents.GridSpace"><code>GridSpace</code></a> or <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>) using the A* algorithm. This struct must be passed into any pathfinding functions.</p><p>For <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>, a walkmap or instance of <a href="#Agents.Pathfinding.PenaltyMap"><code>PenaltyMap</code></a> must be provided to specify the level of discretisation of the space.</p><p><strong>Keywords</strong></p><ul><li><code>diagonal_movement = true</code> specifies if movement can be to diagonal neighbors of a tile, or only orthogonal neighbors. Only available for <a href="#Agents.GridSpace"><code>GridSpace</code></a></li><li><code>admissibility = 0.0</code> allows the algorithm to aprroximate paths to speed up pathfinding. A value of <code>admissibility</code> allows paths with at most <code>(1+admissibility)</code> times the optimal length.</li><li><code>walkmap = trues(size(space))</code> specifies the (un)walkable positions of the space. If specified, it should be a <code>BitArray</code> of the same size as the corresponding <code>GridSpace</code>. By default, agents can walk anywhere in the space.</li><li><code>cost_metric = DirectDistance{D}()</code> is an instance of a cost metric and specifies the metric used to approximate the distance between any two points.</li></ul><p>Utilization of all features of <code>AStar</code> occurs in the <a href="../examples/rabbit_fox_hawk/#Rabbit,-Fox,-Hawk-1">Rabbit, Fox, Hawk</a> example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar.jl#L40-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.penaltymap" href="#Agents.Pathfinding.penaltymap"><code>Agents.Pathfinding.penaltymap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.penaltymap(pathfinder)</code></pre><p>Return the penalty map of a <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a> if the <a href="#Agents.Pathfinding.PenaltyMap"><code>Pathfinding.PenaltyMap</code></a> metric is in use, <code>nothing</code> otherwise.</p><p>It is possible to mutate the map directly, for example <code>Pathfinding.penaltymap(pathfinder)[15, 40] = 115</code> or <code>Pathfinding.penaltymap(pathfinder) .= rand(50, 50)</code>. If this is mutated, a new path needs to be planned using <a href="#Agents.plan_route!"><code>plan_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar.jl#L205-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.nearby_walkable" href="#Agents.Pathfinding.nearby_walkable"><code>Agents.Pathfinding.nearby_walkable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.nearby_walkable(position, model::ABM{&lt;:GridSpace{D}}, pathfinder::AStar{D}, r = 1)</code></pre><p>Return an iterator over all <a href="#Agents.nearby_positions"><code>nearby_positions</code></a> within &quot;radius&quot; <code>r</code> of the given <code>position</code> (excluding <code>position</code>), which are walkable as specified by the given <code>pathfinder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_grid.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.random_walkable" href="#Agents.Pathfinding.random_walkable"><code>Agents.Pathfinding.random_walkable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.random_walkable(model, pathfinder::AStar{D})</code></pre><p>Return a random position in the given <code>model</code> that is walkable as specified by the given <code>pathfinder</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_grid.jl#L81-L85">source</a></section><section><div><pre><code class="language-none">Pathfinding.random_walkable(pos, model::ABM{&lt;:ContinuousSpace{D}}, pathfinder::AStar{D}, r = 1.0)</code></pre><p>Return a random position within radius <code>r</code> of <code>pos</code> which is walkable, as specified by <code>pathfinder</code>. Return <code>pos</code> if no such position exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/astar_continuous.jl#L179-L183">source</a></section></article><h3 id="Pathfinding-Metrics-1"><a class="docs-heading-anchor" href="#Pathfinding-Metrics-1">Pathfinding Metrics</a><a class="docs-heading-anchor-permalink" href="#Pathfinding-Metrics-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.DirectDistance" href="#Agents.Pathfinding.DirectDistance"><code>Agents.Pathfinding.DirectDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.DirectDistance{D}([direction_costs::Vector{Int}]) &lt;: CostMetric{D}</code></pre><p>Distance is approximated as the shortest path between the two points, provided the <code>walkable</code> property of <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a> allows. Optionally provide a <code>Vector{Int}</code> that represents the cost of going from a tile to the neighboring tile on the <code>i</code> dimensional diagonal (default is <code>10√i</code>).</p><p>If <code>diagonal_movement=false</code> in <a href="#Agents.Pathfinding.AStar"><code>Pathfinding.AStar</code></a>, neighbors in diagonal positions will be excluded. Cost defaults to the first value of the provided vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/metrics.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.MaxDistance" href="#Agents.Pathfinding.MaxDistance"><code>Agents.Pathfinding.MaxDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.MaxDistance{D}() &lt;: CostMetric{D}</code></pre><p>Distance between two tiles is approximated as the maximum of absolute difference in coordinates between them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/metrics.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.PenaltyMap" href="#Agents.Pathfinding.PenaltyMap"><code>Agents.Pathfinding.PenaltyMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.PenaltyMap(pmap::Array{Int,D} [, base_metric::CostMetric]) &lt;: CostMetric{D}</code></pre><p>Distance between two positions is the sum of the shortest distance between them and the absolute difference in penalty.</p><p>A penalty map (<code>pmap</code>) is required. For pathfinding in <a href="#Agents.GridSpace"><code>GridSpace</code></a>, this should be the same dimensions as the space. For pathfinding in <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>, the size of this map determines the granularity of the underlying grid, and should agree with the size of the <code>walkable</code> map.</p><p>Distance is calculated using <a href="#Agents.Pathfinding.DirectDistance"><code>Pathfinding.DirectDistance</code></a> by default, and can be changed by specifying <code>base_metric</code>.</p><p>An example usage can be found in <a href="https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/runners/">Mountain Runners</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/pathfinding/metrics.jl#L41-L55">source</a></section></article><p>Building a custom metric is straightforward, if the provided ones do not suit your purpose. See the <a href="../devdocs/#Developer-Docs-1">Developer Docs</a> for details.</p><h2 id="Save,-Load,-Checkpoints-1"><a class="docs-heading-anchor" href="#Save,-Load,-Checkpoints-1">Save, Load, Checkpoints</a><a class="docs-heading-anchor-permalink" href="#Save,-Load,-Checkpoints-1" title="Permalink"></a></h2><p>There may be scenarios where interacting with data in the form of files is necessary. The following functions provide an interface to save/load data to/from files.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentsIO.save_checkpoint" href="#Agents.AgentsIO.save_checkpoint"><code>Agents.AgentsIO.save_checkpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AgentsIO.save_checkpoint(filename, model::ABM)</code></pre><p>Write the entire <code>model</code> to file specified by <code>filename</code>. The following points should be considered before using this functionality:</p><ul><li>OpenStreetMap data is not saved. The path to the map should be specified when loading the model using the <code>map</code> keyword of <a href="#Agents.AgentsIO.load_checkpoint"><code>AgentsIO.load_checkpoint</code></a>.</li><li>Functions are not saved, including stepping functions, schedulers, and <code>update_vel!</code>. The last two can be provided to <a href="#Agents.AgentsIO.load_checkpoint"><code>AgentsIO.load_checkpoint</code></a> using the appropriate keyword arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/io/jld2_integration.jl#L180-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentsIO.load_checkpoint" href="#Agents.AgentsIO.load_checkpoint"><code>Agents.AgentsIO.load_checkpoint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AgentsIO.load_checkpoint(filename; kwargs...)</code></pre><p>Load the model saved to the file specified by <code>filename</code>.</p><p><strong>Keywords</strong></p><ul><li><code>scheduler = Schedulers.fastest</code> specifies what scheduler should be used for the model.</li><li><code>warn = true</code> can be used to disable warnings from type checks on the   agent type.</li></ul><p><a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> specific:</p><ul><li><code>update_vel!</code> specifies a function that should be used to update each agent&#39;s velocity before it is moved. Refer to <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> for details.</li></ul><p><a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a> specific:</p><ul><li><code>map</code> is a path to the OpenStreetMap to be used for the space. This is a required parameter if the space is <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>.</li><li><code>use_cache = false</code>, <code>trim_to_connected_graph = true</code> refer to <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/io/jld2_integration.jl#L197-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentsIO.populate_from_csv!" href="#Agents.AgentsIO.populate_from_csv!"><code>Agents.AgentsIO.populate_from_csv!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AgentsIO.populate_from_csv!(model, filename [, agent_type, col_map]; row_number_is_id, kwargs...)</code></pre><p>Populate the given <code>model</code> using CSV data contained in <code>filename</code>. Use <code>agent_type</code> to specify the type of agent to create (In the case of multi-agent models) or a function that returns an agent to add to the model. The CSV row is splatted into the <code>agent_type</code> constructor/function.</p><p><code>col_map</code> is a <code>Dict{Symbol,Int}</code> specifying a mapping of keyword-arguments to row number. If <code>col_map</code> is specified, the specified data is splatted as keyword arguments.</p><p>The keyword <code>row_number_is_id = false</code> specifies whether the row number will be passed as the first argument (or as <code>id</code> keyword) to <code>agent_type</code>.</p><p>Any other keyword arguments are forwarded to <code>CSV.Rows</code>. If the <code>types</code> keyword is not specified and <code>agent_type</code> is a struct, then the mapping from struct field to type will be used. <code>Tuple{...}</code> fields will be suffixed with <code>_1</code>, <code>_2</code>, ... similarly to <a href="#Agents.AgentsIO.dump_to_csv"><code>AgentsIO.dump_to_csv</code></a></p><p>For example,</p><pre><code class="language-none">struct Foo &lt;: AbstractAgent
    id::Int
    pos::NTuple{2,Int}
    foo::Tuple{Int,String}
end

model = ABM(Foo, ...)
AgentsIO.populate_from_csv!(model, &quot;test.csv&quot;)</code></pre><p>Here, <code>types</code> will be inferred to be</p><pre><code class="language-none">Dict(
    :id =&gt; Int,
    :pos_1 =&gt; Int,
    :pos_2 =&gt; Int,
    :foo_1 =&gt; Int,
    :foo_2 =&gt; String,
)</code></pre><p>It is not necessary for all these fields to be present as columns in the CSV. Any column names that match will be converted to the appropriate type. There should exist a constructor for <code>Foo</code> taking the appropriate combination of fields as parameters.</p><p>If <code>&quot;test.csv&quot;</code> contains the following columns: <code>pos_1, pos_2, foo_1, foo_2</code>, then <code>model</code> can be populated as <code>AgentsIO.populate_from_csv!(model, &quot;test.csv&quot;; row_number_is_id = true)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/io/csv_integration.jl#L4-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentsIO.dump_to_csv" href="#Agents.AgentsIO.dump_to_csv"><code>Agents.AgentsIO.dump_to_csv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">AgentsIO.dump_to_csv(filename, agents [, fields]; kwargs...)</code></pre><p>Dump <code>agents</code> to the CSV file specified by <code>filename</code>. <code>agents</code> is any iterable sequence of types, such as from <a href="#Agents.allagents"><code>allagents</code></a>. <code>fields</code> is an iterable sequence of <code>Symbol</code>s specifying which fields of each agent are dumped. If not explicitly specified, it is automatically inferred using <code>eltype(agents)</code>. All <code>kwargs...</code> are forwarded to <code>CSV.write</code>.</p><p>All <code>Tuple{...}</code> fields are flattened to multiple columns suffixed by <code>_1</code>, <code>_2</code>... similarly to <a href="#Agents.AgentsIO.populate_from_csv!"><code>AgentsIO.populate_from_csv!</code></a></p><p>For example,</p><pre><code class="language-none">struct Foo &lt;: AbstractAgent
    id::Int
    pos::NTuple{2,Int}
    foo::Tuple{Int,String}
end

model = ABM(Foo, ...)
...
AgentsIO.dump_to_csv(&quot;test.csv&quot;, allagents(model))</code></pre><p>The resultant <code>&quot;test.csv&quot;</code> file will contain the following columns: <code>id</code>, <code>pos_1</code>, <code>pos_2</code>, <code>foo_1</code>, <code>foo_2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/720ac5080c91f13dc0bc426657c4e30dd1db065a/src/submodules/io/csv_integration.jl#L102-L128">source</a></section></article><p>In case you require custom serialization for model properties, refer to the <a href="../devdocs/#Developer-Docs-1">Developer Docs</a> for details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« More Examples for Agents.jl</a><a class="docs-footer-nextpage" href="../agents_visualizations/">Plotting and Interactivity »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 June 2022 02:46">Wednesday 8 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
