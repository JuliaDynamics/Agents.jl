<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Agents.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Space"><span>1. The space</span></a></li><li><a class="tocitem" href="#.-The-agent-type(s)"><span>2. The agent type(s)</span></a></li><li><a class="tocitem" href="#.1-The-evolution-rule-basics"><span>3.1 The evolution rule - basics</span></a></li><li><a class="tocitem" href="#.2-The-evolution-rule-agent-stepping-function"><span>3.2 The evolution rule - agent stepping function</span></a></li><li><a class="tocitem" href="#manual_scheduling"><span>3.3 The evolution rule - advanced (manual scheduling)</span></a></li><li><a class="tocitem" href="#.-The-model"><span>4. The model</span></a></li><li><a class="tocitem" href="#.-Evolving-the-model"><span>5. Evolving the model</span></a></li><li><a class="tocitem" href="#.-Visualizations"><span>5. Visualizations</span></a></li><li><a class="tocitem" href="#.-Collecting-data"><span>6. Collecting data</span></a></li><li><a class="tocitem" href="#Seeding-and-Random-numbers"><span>Seeding and Random numbers</span></a></li><li><a class="tocitem" href="#An-educative-example"><span>An educative example</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/flock/">Flocking model</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../examples/rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../examples/">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../examples/agents_visualizations/">Plotting and Interactivity</a></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../examples/celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">YouTube video</header><div class="admonition-body"><ul><li>This Tutorial is also available as a YouTube video: <a href="https://youtu.be/fgwAfAa4kt0">https://youtu.be/fgwAfAa4kt0</a></li></ul></div></div><p>In Agents.jl a central abstract structure called <code>AgentBasedModel</code> contains all information necessary to run a simulation: the evolution rule (also called dynamic rule), the agents of the simulation, and other global properties relevant to the simulation. <code>AgentBasedModel</code>s map unique IDs (integers) to agent instances. During the simulation, the model evolves in discrete steps. During one step, the user decides which agents will act, how they will act, how many times, and whether any model-level properties will be adjusted. Once the time evolution is defined, collecting data during time evolution is straightforward by simply stating which data should be collected.</p><p>In the spirit of simple design, all of this is done by defining simple Julia data types, like basic functions, structs and dictionaries.</p><p>To set up an ABM simulation in Agents.jl, a user only needs to follow these steps:</p><ol><li>Choose what <strong>kind of space</strong> the agents will live in, for example a graph, a grid, etc. Several spaces are provided by Agents.jl and can be initialized immediately.</li><li>Define the <strong>agent type</strong> (or types, for mixed models) that will populate the ABM. Agent types are Julia <code>mutable struct</code>s that are created with <a href="#Agents.@agent"><code>@agent</code></a>. The types must contain some mandatory fields, which is ensured by using <a href="#Agents.@agent"><code>@agent</code></a>. The remaining fields of the agent type are up to the user&#39;s choice.</li><li>Define the <strong>evolution rule</strong>, i.e., how the model evolves in time. The evolution rule needs to be provided as at least one, or at most two functions: an agent stepping function, that acts on each agent one by one, and/or a model stepping function, that steps the entire model as a whole. These functions are standard Julia functions that take advantage of the Agents.jl <a href="../api/#API">API</a>.</li><li>Initialize an <strong>agent based model instance</strong> that contains created agent type, the chosen space, the evolution rule, other optional additional model-level properties, and other simulation tuning properties like schedulers or random number generators. The most common model type is <a href="#Agents.StandardABM"><code>StandardABM</code></a>, but more specialized model types are also available, see <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>.</li><li><em>(Trivial)</em> <strong>evolve the model</strong>.</li><li><em>(Optional)</em> <strong>Visualize the model</strong> and animate its time evolution. This can help checking that the model behaves as expected and there aren&#39;t any mistakes, or can be used in making figures for a paper/presentation.</li><li><strong>Collect data</strong>. To do this, specify which data should be collected, by providing one standard Julia <code>Vector</code> of data-to-collect for agents, for example <code>[:mood, :wealth]</code>, and another one for the model. The agent data names are given as the keyword <code>adata</code> and the model as keyword <code>mdata</code> to the function <a href="#Agents.run!"><code>run!</code></a>. This function outputs collected data in the form of a <code>DataFrame</code>.</li></ol><p>If you&#39;re planning of running massive simulations, it might be worth having a look at the <a href="../performance_tips/#Performance-Tips">Performance Tips</a> after familiarizing yourself with Agents.jl.</p><h2 id="Space"><a class="docs-heading-anchor" href="#Space">1. The space</a><a id="Space-1"></a><a class="docs-heading-anchor-permalink" href="#Space" title="Permalink"></a></h2><p>Agents.jl offers several possibilities for the space the agents live in. In addition, it is straightforward to implement a fundamentally new type of space, see <a href="../devdocs/#Creating-a-new-space-type">Creating a new space type</a>.</p><p>The available spaces are listed in the <a href="../api/#Available-spaces">Available spaces</a> part of the API. An example of a space is <a href="../api/#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>. It is based on Open Street Map, where agents are confined to move along streets of the map, using real-world values for the length of each street.</p><p>After deciding on the space, one simply initializes an instance of a space, e.g. with <code>grid = GridSpace((10, 10))</code> and passes that into <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. See each individual space for all its possible arguments.</p><h2 id=".-The-agent-type(s)"><a class="docs-heading-anchor" href="#.-The-agent-type(s)">2. The agent type(s)</a><a id=".-The-agent-type(s)-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-agent-type(s)" title="Permalink"></a></h2><p>Agents in Agents.jl are instances of user-defined types. While the majority of Agents.jl <a href="../api/#API">API</a> is based on a functional design, accessing agent properties is done with the simple field-access Julia syntax. For example, the (named) property <code>weight</code> of an agent can be obtained as <code>agent.weight</code>.</p><p>To create agent types, and define what properties they should have, the user needs to use the <a href="#Agents.@agent"><code>@agent</code></a> macro, which ensures that agents have the minimum amount of required necessary properties to function within a given space and model by inheriting pre-defined agent properties suited for each type of space. The macro usage may seem intimidating at first, but it is in truth very simple! For example,</p><pre><code class="language-julia hljs">@agent struct Person(GridAgent{2})
    age::Int
    money::Float64
end</code></pre><p>would make an agent type with named properties <code>age, money</code>, while also inheriting all named properties of the <code>GridAgent{2}</code> predefined type (which is necessary for simulating agents in a two-dimensional grid space).</p><article class="docstring"><header><a class="docstring-binding" id="Agents.@agent" href="#Agents.@agent"><code>Agents.@agent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@agent struct YourAgentType{X}(AnotherAgentType) [&lt;: OptionalSupertype]
    extra_property::X
    other_extra_property_with_default::Bool = true
    const other_extra_const_property::Int
    # etc...
end</code></pre><p>Define an agent struct which includes all fields that <code>AnotherAgentType</code> has, as well as any additional ones the user may provide. See below for examples.</p><p>Using <code>@agent</code> is the only supported way to create agent types for Agents.jl.</p><p>Structs created with <code>@agent</code> by default subtype <code>AbstractAgent</code>. They cannot subtype each other, as all structs created from <code>@agent</code> are concrete types and <code>AnotherAgentType</code> itself is also concrete (only concrete types have fields). If you want <code>YourAgentType</code> to subtype something other than <code>AbstractAgent</code>, use the optional argument <code>OptionalSupertype</code> (which itself must then subtype <code>AbstractAgent</code>).</p><p><strong>Usage</strong></p><p>The macro <code>@agent</code> has two primary uses:</p><ol><li>To include the mandatory fields for a particular space in your agent struct. In this case you would use one of the minimal agent types as <code>AnotherAgentType</code>.</li><li>A convenient way to include fields from another, already existing struct.</li></ol><p>The existing minimal agent types are:</p><ul><li><a href="../api/#Agents.NoSpaceAgent"><code>NoSpaceAgent</code></a></li><li><a href="../api/#Agents.GraphAgent"><code>GraphAgent</code></a></li><li><a href="../api/#Agents.GridAgent"><code>GridAgent</code></a></li><li><a href="../api/#Agents.ContinuousAgent"><code>ContinuousAgent</code></a></li><li><a href="../api/#Agents.OSMAgent"><code>OSMAgent</code></a></li></ul><p>All will attribute an <code>id::Int</code> field, and besides <code>NoSpaceAgent</code> will also attribute a <code>pos</code> field. You should <strong>never directly manipulate the mandatory fields <code>id, pos</code></strong> that the resulting new agent type will have. The <code>id</code> is an unchangeable field. Use functions like <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> etc., to change the position.</p><p><strong>Examples</strong></p><p><strong>Example without optional hierarchy</strong></p><p>Using</p><pre><code class="language-julia hljs">@agent struct Person{T}(GridAgent{2}) 
    age::Int
    moneyz::T
end</code></pre><p>will create an agent appropriate for using with 2-dimensional <a href="../api/#Agents.GridSpace"><code>GridSpace</code></a></p><pre><code class="language-julia hljs">mutable struct Person{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    const age::Int
    moneyz::T
end</code></pre><p>Notice that you can also use default values for some fields, in this case you  will need to specify the field names with the non-default values</p><pre><code class="language-julia hljs">@agent struct Person2{T}(GridAgent{2})
    age::Int = 30
    moneyz::T
end
# default age value
Person2(id = 1, pos = (1, 1), moneyz = 2000)
# new age value
Person2(1, (1, 1), 40, 2000)</code></pre><p><strong>Example with optional hierarchy</strong></p><p>An alternative way to make the above structs, that also establishes a user-specific subtyping hierarchy would be to do:</p><pre><code class="language-julia hljs">abstract type AbstractHuman &lt;: AbstractAgent end

@agent struct Worker(GridAgent{2}) &lt;: AbstractHuman
    age::Int
    moneyz::Float64
end

@agent struct Fisher(Worker) &lt;: AbstractHuman
    fish_per_day::Float64
end</code></pre><p>which would now make both <code>Fisher</code> and <code>Worker</code> subtypes of <code>AbstractHuman</code>.</p><pre><code class="language-julia hljs">julia&gt; supertypes(Fisher)
(Fisher, AbstractHuman, AbstractAgent, Any)

julia&gt; supertypes(Worker)
(Worker, AbstractHuman, AbstractAgent, Any)</code></pre><p>Note that <code>Fisher</code> will <em>not</em> be a subtype of <code>Worker</code> although <code>Fisher</code> has inherited the fields from <code>Worker</code>.</p><p><strong>Example highlighting problems with parametric types</strong></p><p>Notice that in Julia parametric types are union types. Hence, the following cannot be used:</p><pre><code class="language-julia hljs">@agent struct Dummy{T}(GridAgent{2})
    moneyz::T
end

@agent struct Fisherino{T}(Dummy{T})
    fish_per_day::T
end</code></pre><p>You will get an error in the definition of <code>Fisherino</code>, because the fields of <code>Dummy{T}</code> cannot be obtained, because it is a union type. Same with using <code>Dummy</code>. You can only use <code>Dummy{Float64}</code>.</p><p><strong>Example with common dispatch and no subtyping</strong></p><p>It may be that you do not even need to create a subtyping relation if you want to utilize multiple dispatch. Consider the example:</p><pre><code class="language-julia hljs">@agent struct CommonTraits(GridAgent{2})
    age::Int
    speed::Int
    energy::Int
end</code></pre><p>and then two more structs are made from these traits:</p><pre><code class="language-julia hljs">@agent struct Bird(CommonTraits)
    height::Float64
end

@agent struct Rabbit(CommonTraits)
    underground::Bool
end</code></pre><p>If you wanted a function that dispatches to both <code>Rabbit, Bird</code>, you only have to define:</p><pre><code class="language-julia hljs">Animal = Union{Bird, Rabbit}
f(x::Animal) = ... # uses `CommonTraits` fields</code></pre><p>However, it should also be said, that there is no real reason here to explicitly type-annotate <code>x::Animal</code> in <code>f</code>. Don&#39;t annotate any type. Annotating a type only becomes useful if there are at least two &quot;abstract&quot; groups, like <code>Animal, Person</code>. Then it would make sense to define</p><pre><code class="language-julia hljs">Person = Union{Fisher, Baker}
f(x::Animal) = ... # uses `CommonTraits` fields
f(x::Person) = ... # uses fields that all &quot;persons&quot; have</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/d06d0f40a719206b136efe59310bd52f7e6b431e/src/core/agents.jl#L20-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">YourAgentType &lt;: AbstractAgent</code></pre><p>Agents participating in Agents.jl simulations are instances of user-defined Types that are subtypes of <code>AbstractAgent</code>.</p><p>Your agent type(s) <strong>must have</strong> the <code>id::Int</code> field as first field. If any space is used (see <a href="../api/#Available-spaces">Available spaces</a>), a <code>pos</code> field of appropriate type is also mandatory. The core model structure, and each space, may also require additional fields that may, or may not, be communicated as part of the public API.</p><p>The <a href="#Agents.@agent"><code>@agent</code></a> macro ensures that all of these constrains are in place and hence it is the <strong>the only supported way to create agent types</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/d06d0f40a719206b136efe59310bd52f7e6b431e/src/core/agents.jl#L3-L17">source</a></section></article><h2 id=".1-The-evolution-rule-basics"><a class="docs-heading-anchor" href="#.1-The-evolution-rule-basics">3.1 The evolution rule - basics</a><a id=".1-The-evolution-rule-basics-1"></a><a class="docs-heading-anchor-permalink" href="#.1-The-evolution-rule-basics" title="Permalink"></a></h2><p>The evolution rule may always be provided as one standard Julia function that inputs the model and modifies it <em>in-place</em>, according to the rules of the simulation. Such a <strong>model stepping function</strong> will itself likely call functions from the Agents.jl <a href="../api/#API">API</a> and may look like</p><pre><code class="language-julia hljs">function model_step!(model)
    exchange = model.exchange # obtain the `exchange` model property
    agent = model[5] # obtain agent with ID = 5
    # Iterate over neighboring agents (within distance 1)
    for neighbor in nearby_agents(model, agent, 1)
        transfer = minimum(neighbor.money, exchange)
        agent.money += transfer
        neighbor.money -= transfer
    end
    return # function end. As it is in-place it `return`s nothing.
end</code></pre><p>This function will be called once per simulation step.</p><p>As you can see, the above defined model stepping function did not operate on all agents of the model, only on agent with ID 5 and its spatial neighbors. Typically you would want to operate on more agents. There is a simple automated way to do this (section 3.2), and a non-automated, but fully-configurable way to do this (section 3.3).</p><h2 id=".2-The-evolution-rule-agent-stepping-function"><a class="docs-heading-anchor" href="#.2-The-evolution-rule-agent-stepping-function">3.2 The evolution rule - agent stepping function</a><a id=".2-The-evolution-rule-agent-stepping-function-1"></a><a class="docs-heading-anchor-permalink" href="#.2-The-evolution-rule-agent-stepping-function" title="Permalink"></a></h2><p>In Agents.jl it is also possible to provide an <strong>agent stepping function</strong>. This feature enables scheduling agents automatically given some scheduling rule, skipping the agents that were scheduled to act but have been removed from the model (due to e.g., the actions of other agents), and also allows optimizations that are based on the specific type of <code>AgentBasedModel</code>.</p><p>An agent stepping function defines what happens to an agent when it activates. It inputs two arguments <code>agent, model</code> and operates in place on the <code>agent</code> and the <code>model</code>. This function will be applied to every <code>agent</code> that has been scheduled by the model&#39;s scheduler. A scheduler simply creates an iterator of agent IDs at each simulation step, possibly taking into account the current model state. Several schedulers are provided out-of-the-box by Agents.jl, see <a href="../api/#Schedulers">Schedulers</a>.</p><p>Given the example above, an agent stepping function that would perform a similar currency exchange between agents would look like</p><pre><code class="language-julia hljs">function agent_step!(agent, model)
    exchange = model.exchange # obtain the `exchange` model property
    # Iterate over neighboring agents (within distance 1)
    for neighbor in nearby_agents(model, agent, 1)
        transfer = minimum(neighbor.money, exchange)
        agent.money += transfer
        neighbor.money -= transfer
    end
    agent.age += 1
    # if too old, pass fortune onto heir and remove from model
    if agent.age &gt; 75
        heir = replicate!(agent, model)
        heir.age = 1
        remove_agent!(agent, modeL)
    end
    return # function end. As it is in-place it `return`s nothing.
end</code></pre><p>and to activate all agents randomly once per simulation step, one would use <code>Schedulers.Randomly()</code> as the model scheduler.</p><p>We stress that in contrast to the above <code>model_step!</code>, this function will be called for <em>every</em> scheduled agent, while <code>model_step!</code> will only be called <em>once</em> per simulation step. Naturally, you may define <strong>both</strong> an agent and a model stepping functions. In this case the model stepping function would perform model-wide actions that are not limited to a particular agent.</p><h2 id="manual_scheduling"><a class="docs-heading-anchor" href="#manual_scheduling">3.3 The evolution rule - advanced (manual scheduling)</a><a id="manual_scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#manual_scheduling" title="Permalink"></a></h2><p>Some advanced models may require special handling for scheduling, or may need to schedule agents several times and act on different subsets of agents with different functions during a single simulation step. In such a scenario, it is more sensible to provide only a model stepping function, where all the dynamics is contained within.</p><p>Here is an example:</p><pre><code class="language-julia hljs">function complex_step!(model)
    # tip: these schedulers should be defined as properties of the model
    scheduler1 = Schedulers.Randomly()
    scheduler2 = user_defined_function_with_model_as_arg
    for id in schedule(model, scheduler1)
        agent_step1!(model[id], model)
    end
    intermediate_model_action!(model)
    for id in schedule(model, scheduler2)
        agent_step2!(model[id], model)
    end
    if model.step_counter % 100 == 0
        model_action_every_100_steps!(model)
    end
    final_model_action!(model)
    return
end</code></pre><p>For defining your own schedulers, see <a href="../api/#Schedulers">Schedulers</a>.</p><div class="admonition is-info"><header class="admonition-header">Current step number</header><div class="admonition-body"><p>Notice that the current step number is not explicitly given to the model stepping function, nor is contained in the model type, because this is useful only for a subset of ABMs. If you need the step information, implement this by adding a counting parameter into the model <code>properties</code>, and incrementing it by 1 each time the model stepping function is called.</p></div></div><h2 id=".-The-model"><a class="docs-heading-anchor" href="#.-The-model">4. The model</a><a id=".-The-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-model" title="Permalink"></a></h2><p>The ABM is an instance of a subtype of <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, most typically simply a <a href="#Agents.StandardABM"><code>StandardABM</code></a>. A model is created by passing all inputs of steps 1-3 into the model constructor. Once the model is constructed, it can be populated by agents using the <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a> function, which we highlight in the educative example below.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AgentBasedModel</code></pre><p>An <code>AgentBasedModel</code> is the abstract supertype encompassing models in Agents.jl. All models are some concrete implementation of <code>AgentBasedModel</code> and follow its interface (see below). <code>ABM</code> is an alias to <code>AgentBasedModel</code>.</p><p>For backwards compatibility, the following function is valid:</p><pre><code class="language-julia hljs">AgentBasedModel(AgentType [, space]; properties, kwargs...) → model</code></pre><p>which dispatches to <a href="#Agents.StandardABM"><code>StandardABM</code></a>.</p><p><strong>Available concrete implementations</strong></p><ul><li><a href="#Agents.StandardABM"><code>StandardABM</code></a></li><li><a href="@ref"><code>UnkillableABM</code></a></li></ul><p><strong>Interface of <code>AgentBasedModel</code></strong></p><p>Here we the most important information on how to query an instance of <code>AgentBasedModel</code>:</p><ul><li><code>model[id]</code> gives the agent with given <code>id</code>.</li><li><code>abmproperties(model)</code> gives the <code>properties</code> container stored in the model.</li><li><code>model.property</code>:  If the model properties is a dictionary with key type <code>Symbol</code>, or if it is a composite type (<code>struct</code>), then the syntax <code>model.property</code> will return the model property with key <code>:property</code>.</li><li><code>abmrng(model)</code> will return the random number generator of the model. It is strongly recommended to use <code>abmrng(model)</code> to all calls to <code>rand</code> and similar functions, so that reproducibility can be established in your modelling workflow.</li></ul><p>Many more functions exist in the API page, such as <a href="../api/#Agents.allagents"><code>allagents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/d06d0f40a719206b136efe59310bd52f7e6b431e/src/core/model_abstract.jl#L31-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.StandardABM" href="#Agents.StandardABM"><code>Agents.StandardABM</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StandardABM &lt;: AgentBasedModel</code></pre><p>The most standard concrete implementation of an <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, as well as the default version of the generic <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> constructor. <code>StandardABM</code> stores agents in a dictionary mapping unique <code>Int</code> IDs to agents. See also <a href="../api/#Agents.UnremovableABM"><code>UnremovableABM</code></a> for better performance in case number of agents can only increase during the model evolution.</p><pre><code class="nohighlight hljs">StandardABM(AgentType [, space]; properties, kwargs...) → model</code></pre><p>Creates a model expecting agents of type <code>AgentType</code> living in the given <code>space</code>. It can support supports multiple agent types by passing a <code>Union</code> of agent types as <code>AgentType</code>. Have a look at <a href="../performance_tips/#Performance-Tips">Performance Tips</a> for potential drawbacks of this approach.</p><p><code>space</code> is a subtype of <code>AbstractSpace</code>, see <a href="#Space">Space</a> for all available spaces. If it is omitted then all agents are virtually in one position and there is no spatial structure. Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.</p><p>The evolution rules are functions given to the keywords <code>agent_step!</code>, <code>model_step!</code>, <code>schedule</code>. If <code>agent_step!</code> is not provided, the evolution rules is just the function given to <code>model_step!</code>. Each step of a simulation with <code>StandardABM</code> proceeds as follows: If <code>agent_step!</code> is not provided, then a simulation step is equivalent with calling <code>model_step!</code>. If <code>agent_step!</code> is provided, then a simulation step first schedules agents by calling the scheduler. Then, it applies the <code>agent_step!</code> function to all scheduled agents. Then, the <code>model_step!</code> function is called (optionally, the <code>model_step!</code> function may be called before activating the agents).</p><p><strong>Keywords</strong></p><ul><li><code>agent_step! = dummystep</code>: the optional stepping function for each agent contained in the model. For complicated models, it could be more suitable to use only <code>model_step!</code> to evolve the model.</li><li><code>model_step! = dummystep</code>: the optional stepping function for the model.</li><li><code>properties = nothing</code>: additional model-level properties that the user may decide upon and include in the model. <code>properties</code> can be an arbitrary container of data, however it is most typically a <code>Dict</code> with <code>Symbol</code> keys, or a composite type (<code>struct</code>).</li><li><code>scheduler = Schedulers.fastest</code>: is the scheduler that decides the (default) activation order of the agents. See the <a href="../api/#Schedulers">scheduler API</a> for more options.</li><li><code>rng = Random.default_rng()</code>: the random number generation stored and used by the model in all calls to random functions. Accepts any subtype of <code>AbstractRNG</code>.</li><li><code>agents_first::Bool = true</code>: whether to schedule and activate agents first and then call the <code>model_step!</code> function, or vice versa.</li><li><code>warn=true</code>: some type tests for <code>AgentType</code> are done, and by default warnings are thrown when appropriate.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/d06d0f40a719206b136efe59310bd52f7e6b431e/src/core/model_concrete.jl#L83-L130">source</a></section></article><h2 id=".-Evolving-the-model"><a class="docs-heading-anchor" href="#.-Evolving-the-model">5. Evolving the model</a><a id=".-Evolving-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-Evolving-the-model" title="Permalink"></a></h2><p>After you have created an instance of an <code>AgentBasedModel</code>, it is rather trivial to evolve it by simply calling <code>step!</code> on it</p><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.step!" href="#CommonSolve.step!"><code>CommonSolve.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">step!(model::ABM [, n::Int = 1])</code></pre><p>Evolve the model for <code>n</code> steps according to the evolution rule.</p><pre><code class="nohighlight hljs">step!(model, f::Function)</code></pre><p>In this version, <code>step!</code> runs the model until <code>f(model, s)</code> returns <code>true</code>, where <code>s</code> is the current amount of steps taken, starting from 0.</p><p>See also <a href="@ref">Advanced stepping</a> for stepping complex models where <code>agent_step!</code> might not be convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/d06d0f40a719206b136efe59310bd52f7e6b431e/src/simulations/step.jl#L5-L17">source</a></section></article><h2 id=".-Visualizations"><a class="docs-heading-anchor" href="#.-Visualizations">5. Visualizations</a><a id=".-Visualizations-1"></a><a class="docs-heading-anchor-permalink" href="#.-Visualizations" title="Permalink"></a></h2><p>Once you have defined a model and the stepping functions, you can visualize the model statically, or animate its time evolution straightforwardly in ~5 lines of code. This is discussed in a different page: <a href="../examples/agents_visualizations/#Visualizations-and-Animations-for-Agent-Based-Models">Visualizations and Animations for Agent Based Models</a>. Furthermore, all models in the Examples showcase plotting.</p><h2 id=".-Collecting-data"><a class="docs-heading-anchor" href="#.-Collecting-data">6. Collecting data</a><a id=".-Collecting-data-1"></a><a class="docs-heading-anchor-permalink" href="#.-Collecting-data" title="Permalink"></a></h2><p>Running the model and collecting data while the model runs is done with the <a href="#Agents.run!"><code>run!</code></a> function. Besides <code>run!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection while scanning ranges of the parameters of the model, and the <a href="../api/#Agents.ensemblerun!"><code>ensemblerun!</code></a> that performs ensemble simulations and data collection.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.run!" href="#Agents.run!"><code>Agents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">run!(model, n::Integer; kwargs...) → agent_df, model_df
run!(model, f::Function; kwargs...) → agent_df, model_df</code></pre><p>Run the model (step it with the input arguments propagated into <a href="#CommonSolve.step!"><code>step!</code></a>) and collect data specified by the keywords, explained one by one below. Return the data as two <code>DataFrame</code>s, one for agent-level data and one for model-level data.</p><p>See also <a href="../api/#Agents.offline_run!"><code>offline_run!</code></a> to write data to file while running the model.</p><p><strong>Data-deciding keywords</strong></p><ul><li><p><code>adata::Vector</code> means &quot;agent data to collect&quot;. If an entry is a <code>Symbol</code>, e.g. <code>:weight</code>, then the data for this entry is agent&#39;s field <code>weight</code>. If an entry is a <code>Function</code>, e.g. <code>f</code>, then the data for this entry is just <code>f(a)</code> for each agent <code>a</code>. The resulting dataframe columns are named with the input symbol (here <code>:weight, :f</code>).</p></li><li><p><code>adata::Vector{&lt;:Tuple}</code>: if <code>adata</code> is a vector of tuples instead, data aggregation is done over the agent properties.</p><p>For each 2-tuple, the first entry is the &quot;key&quot; (any entry like the ones mentioned above, e.g. <code>:weight, f</code>). The second entry is an aggregating function that aggregates the key, e.g. <code>mean, maximum</code>. So, continuing from the above example, we would have <code>adata = [(:weight, mean), (f, maximum)]</code>.</p><p>It&#39;s also possible to provide a 3-tuple, with the third entry being a conditional function (returning a <code>Bool</code>), which assesses if each agent should be included in the aggregate. For example: <code>x_pos(a) = a.pos[1]&gt;5</code> with <code>(:weight, mean, x_pos)</code> will result in the average weight of agents conditional on their x-position being greater than 5.</p><p>The resulting data name columns use the function <a href="../api/#Agents.dataname"><code>dataname</code></a>. They create something like <code>:mean_weight</code> or <code>:maximum_f_x_pos</code>. In addition, you can use anonymous functions in a list comprehension to assign elements of an array into different columns: <code>adata = [(a)-&gt;(a.interesting_array[i]) for i=1:N]</code>. Column names can also be renamed with <code>DataFrames.rename!</code> after data is collected.</p><p><strong>Notice:</strong> Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. <em>E.g.</em> instead of passing <code>mean</code>, pass <code>mymean(a) = isempty(a) ? 0.0 : mean(a)</code>.</p></li><li><p><code>mdata::Vector</code> means &quot;model data to collect&quot; and works exactly like <code>adata</code>. For the model, no aggregation is possible (nothing to aggregate over).</p><p>Alternatively, <code>mdata</code> can also be a function. This is a &quot;generator&quot; function, that accepts <code>model</code> as input and provides a <code>Vector</code> that represents <code>mdata</code>. Useful in combination with an <a href="../api/#Agents.ensemblerun!"><code>ensemblerun!</code></a> call that requires a generator function.</p></li></ul><p>By default both keywords are <code>nothing</code>, i.e. nothing is collected/aggregated.</p><p><strong>Mixed-Models</strong></p><p>For mixed-models, the <code>adata</code> keyword has some additional options &amp; properties. An additional column <code>agent_type</code> will be placed in the output dataframe.</p><p>In the case that data is needed for one agent type that does not exist in a second agent type, <code>missing</code> values will be added to the dataframe.</p><p><strong>Warning:</strong> Since this option is inherently type unstable, try to avoid this in a performance critical situation.</p><p>Aggregate functions will fail if <code>missing</code> values are not handled explicitly. If <code>a1.weight</code> but <code>a2</code> (type: Agent2) has no <code>weight</code>, use <code>a2(a) = a isa Agent2; adata = [(:weight, sum, a2)]</code> to filter out the missing results.</p><p><strong>Other keywords</strong></p><ul><li><code>when=true</code> : at which steps <code>s</code> to perform the data collection and processing. A lot of flexibility is offered based on the type of <code>when</code>. If <code>when::AbstractVector</code>, then data are collected if <code>s ∈ when</code>. Otherwise data are collected if <code>when(model, s)</code> returns <code>true</code>. By default data are collected in every step.</li><li><code>when_model = when</code> : same as <code>when</code> but for model data.</li><li><code>obtainer = identity</code> : method to transfer collected data to the <code>DataFrame</code>. Typically only change this to <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy"><code>copy</code></a> if some data are mutable containers (e.g. <code>Vector</code>) which change during evolution, or <a href="https://docs.julialang.org/en/v1/base/base/#Base.deepcopy"><code>deepcopy</code></a> if some data are nested mutable containers. Both of these options have performance penalties.</li><li><code>showprogress=false</code> : Whether to show progress</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/d06d0f40a719206b136efe59310bd52f7e6b431e/src/simulations/collect.jl#L30-L107">source</a></section></article><p>The <a href="#Agents.run!"><code>run!</code></a> function has been designed for maximum flexibility: nearly all scenarios of data collection are possible, whether you need agent data, model data, aggregated data, or arbitrary combinations.</p><p>Nevertheless, we also expose a simple data-collection API (see <a href="../api/#Data-collection">Data collection</a>), that gives users even more flexibility, allowing them to make their own &quot;data collection loops&quot; arbitrarily calling <code>step!</code> and collecting data as, and when, needed.</p><p>As your models become more complex, it may not be advantageous to use lots of helper functions in the global scope to assist with data collection. If this is the case in your model, here&#39;s a helpful tip to keep things clean: use a generator function to collect data as instructed in the documentation string of <a href="#Agents.run!"><code>run!</code></a>. For example:</p><pre><code class="language-julia hljs">function assets(model)
    total_savings(model) = model.bank_balance + sum(model.assets)
    function strategy(model)
        if model.year == 0
            return model.initial_strategy
        else
            return get_strategy(model)
        end
    end
    return [:age, :details, total_savings, strategy]
end
run!(model, agent_step!, model_step!, 10; mdata = assets)</code></pre><h2 id="Seeding-and-Random-numbers"><a class="docs-heading-anchor" href="#Seeding-and-Random-numbers">Seeding and Random numbers</a><a id="Seeding-and-Random-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Seeding-and-Random-numbers" title="Permalink"></a></h2><p>Each ABM in Agents.jl contains a random number generator (RNG) instance that can be obtained with <code>abmrng(model)</code>. A benefit of this approach is making models deterministic so that they can be run again and yield the same output. To do this, always pass a specifically seeded RNG to the model creation, e.g. <code>rng = Random.MersenneTwister(1234)</code> and then give this <code>rng</code> to the model creation.</p><p>For reproducibility and performance reasons, one should never use <code>rand()</code> without using the RNG, thus throughout our examples we use <code>rand(abmrng(model))</code> or <code>rand(abmrng(model), 1:10, 100)</code>, etc.</p><h2 id="An-educative-example"><a class="docs-heading-anchor" href="#An-educative-example">An educative example</a><a id="An-educative-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-educative-example" title="Permalink"></a></h2><p>A simple, education-oriented example of using the basic Agents.jl API is given in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/schelling/">Schelling&#39;s segregation model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 5 October 2023 20:58">Thursday 5 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
