<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spatial rock-paper-scissors (event based) · Agents.jl</title><meta name="title" content="Spatial rock-paper-scissors (event based) · Agents.jl"/><meta property="og:title" content="Spatial rock-paper-scissors (event based) · Agents.jl"/><meta property="twitter:title" content="Spatial rock-paper-scissors (event based) · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../flock/">Flocking model</a></li><li><a class="tocitem" href="../zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li class="is-active"><a class="tocitem" href>Spatial rock-paper-scissors (event based)</a><ul class="internal"><li><a class="tocitem" href="#Defining-the-event-functions"><span>Defining the event functions</span></a></li><li><a class="tocitem" href="#Creating-and-populating-the-EventQueueABM"><span>Creating and populating the <code>EventQueueABM</code></span></a></li><li><a class="tocitem" href="#Time-evolution"><span>Time evolution</span></a></li><li><a class="tocitem" href="#Data-collection"><span>Data collection</span></a></li><li><a class="tocitem" href="#Visualization"><span>Visualization</span></a></li></ul></li><li><a class="tocitem" href="../">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../agents_visualizations/">Plotting and Interactivity</a></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Spatial rock-paper-scissors (event based)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spatial rock-paper-scissors (event based)</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/event_rock_paper_scissors.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="eventbased_tutorial"><a class="docs-heading-anchor" href="#eventbased_tutorial">Spatial rock-paper-scissors (event based)</a><a id="eventbased_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#eventbased_tutorial" title="Permalink"></a></h1><video width="auto" controls autoplay loop>
<source src="../rps_eventqueue.mp4" type="video/mp4">
</video><p>This is an introductory example. Similarly to Schelling&#39;s segregation model of the main <a href="../../tutorial/#Tutorial">Tutorial</a>, its goal is to provide a tutorial for the <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a> instead of the <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>. It assumes that you have gone through the <a href="../../tutorial/#Tutorial">Tutorial</a> first.</p><p>The spatial rock-paper-scissors (RPS) is an ABM with the following rules:</p><ul><li>Agents can be any of three &quot;kinds&quot;: Rock, Paper, or Scissors.</li><li>Agents live in a 2D periodic grid space allowing only one agent per cell.</li><li>When an agent activates, it can do one of three actions:<ol><li>Attack: choose a random nearby agent and attack it. If the agent loses the RPS game it gets removed.</li><li>Move: choose a random nearby position. If it is empty move to it, otherwise swap positions with the agent there.</li><li>Reproduce: choose a random empty nearby position (if any exist). Generate there a new agent of the same type.</li></ol></li></ul><p>And that&#39;s it really! However, we want to model this ABM as an event-based model. This means that these three actions are independent events that will get added to a queue of events. We will address this in a moment. For now, let&#39;s just make functions that represent the actions of the events.</p><h2 id="Defining-the-event-functions"><a class="docs-heading-anchor" href="#Defining-the-event-functions">Defining the event functions</a><a id="Defining-the-event-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-the-event-functions" title="Permalink"></a></h2><p>We start by loading <code>Agents</code></p><pre><code class="language-julia hljs">using Agents</code></pre><p>and defining the three agent types using <a href="@ref"><code>multiagent</code></a> (see the main <a href="../../tutorial/#Tutorial">Tutorial</a> if you are unfamiliar with <a href="../../api/#Agents.@multiagent"><code>@multiagent</code></a>).</p><pre><code class="language-julia hljs">@multiagent struct RPS(GridAgent{2})
    @subagent struct Rock end
    @subagent struct Paper end
    @subagent struct Scissors end
end</code></pre><p>Actions of events are standard Julia functions that utilize Agents.jl <a href="../../api/#API">API</a>, exactly like those given as <code>agent_step!</code> in <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>. They act on an agent and take the model as the second input and end with an empty <code>return</code> statement (as their return value is not utilized by Agents.jl).</p><p>The first action is the attack:</p><pre><code class="language-julia hljs">function attack!(agent, model)
    # Randomly pick a nearby agent
    contender = random_nearby_agent(agent, model)
    # do nothing if there isn&#39;t anyone nearby
    isnothing(contender) &amp;&amp; return
    # else perform standard rock paper scissors logic
    # and remove the contender if you win.
    # Remember to compare agents with `kindof` instead of
    # `typeof` since we use `@multiagent` (see main Tutorial)
    kind = kindof(agent)
    kindc = kindof(contender)
    if kind === :Rock &amp;&amp; kindc === :Scissors
        remove_agent!(contender, model)
    elseif kind === :Scissors &amp;&amp; kindc === :Paper
        remove_agent!(contender, model)
    elseif kind === :Paper &amp;&amp; kindc === :Rock
        remove_agent!(contender, model)
    end
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">attack! (generic function with 1 method)</code></pre><p>The movement function is equally simple due to the many functions offered by Agents.jl <a href="../../api/#API">API</a>.</p><pre><code class="language-julia hljs">function move!(agent, model)
    rand_pos = random_nearby_position(agent.pos, model)
    if isempty(rand_pos, model)
        move_agent!(agent, rand_pos, model)
    else
        occupant_id = id_in_position(rand_pos, model)
        occupant = model[occupant_id]
        swap_agents!(agent, occupant, model)
    end
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">move! (generic function with 1 method)</code></pre><p>The reproduction function is the simplest one.</p><pre><code class="language-julia hljs">function reproduce!(agent, model)
    pos = random_nearby_position(agent, model, 1, pos -&gt; isempty(pos, model))
    isnothing(pos) &amp;&amp; return
    # pass target position as a keyword argument
    replicate!(agent, model; pos)
    return
end

# Defining the propensity and timing of the events</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reproduce! (generic function with 1 method)</code></pre><p>Besides the actual event action defined as the above functions, there are two more pieces of information necessary:</p><ol><li>how likely an event is to happen, and</li><li>how long after the previous event it will happen.</li></ol><p>Now, in the &quot;Gillespie&quot; type of simulations, these two things coincide: The probability for an event is its relative propensity (rate), and the time you have to wait for it to happen is inversely the propensity (rate). When creating an <code>AgentEvent</code> (see below), the user has the option to go along this &quot;Gillespie&quot; route, which is the default. However, the user can also have more control by explicitly providing a function that returns the time until an event triggers (by default this function becomes a random sample of an exponential distribution).</p><p>Let&#39;s make this concrete. For all events we need to define their propensities. Another way to think of propensities is the relative probability mass for an event to happen. The propensities may be constants or functions of the currently actived agent and the model.</p><p>Here, the propensities for moving and attacking will be constants,</p><pre><code class="language-julia hljs">attack_propensity = 1.0
movement_propensity = 0.5</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.5</code></pre><p>while the propensity for reproduction will be a function modelling &quot;seasonality&quot;, so that willingness to reproduce goes up and down periodically</p><pre><code class="language-julia hljs">function reproduction_propensity(agent, model)
    return cos(abmtime(model))^2
end

# Creating the `AgentEvent` structures</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">reproduction_propensity (generic function with 1 method)</code></pre><p>Events are registered as an <a href="@ref"><code>AgentEvent</code></a>, then are added into a container, and then given to the <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a>. The attack and reproduction events affect all agents, and hence we don&#39;t need to specify what agents they apply to.</p><pre><code class="language-julia hljs">attack_event = AgentEvent(action! = attack!, propensity = attack_propensity)

reproduction_event = AgentEvent(action! = reproduce!, propensity = reproduction_propensity)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), Nothing, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, nothing, Agents.exp_propensity)</code></pre><p>The movement event does not apply to rocks however, so we need to specify the agent &quot;kinds&quot; that it applies to, which is <code>(:Scissors, :Paper)</code>. Additionally, we would like to change how the timing of the movement events works. We want to change it from an exponential distribution sample to something else. This &quot;something else&quot; is once again an arbitrary Julia function, and for here we will make:</p><pre><code class="language-julia hljs">function movement_time(agent, model, propensity)
    # `agent` is the agent the event will be applied to,
    # which we do not use in this function!
    t = 0.1 * randn(abmrng(model)) + 1
    return clamp(t, 0, Inf)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">movement_time (generic function with 1 method)</code></pre><p>And with this we can now create</p><pre><code class="language-julia hljs">movement_event = AgentEvent(
    action! = move!, propensity = movement_propensity,
    kinds = (:Scissors, :Paper), timing = movement_time
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AgentEvent{typeof(Main.move!), Float64, Tuple{Symbol, Symbol}, typeof(Main.movement_time)}(Main.move!, 0.5, (:Scissors, :Paper), Main.movement_time)</code></pre><p>we wrap all events in a tuple and we are done with the setting up part!</p><pre><code class="language-julia hljs">events = (attack_event, reproduction_event, movement_event)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(AgentEvent{typeof(Main.attack!), Float64, Nothing, typeof(Agents.exp_propensity)}(Main.attack!, 1.0, nothing, Agents.exp_propensity), AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), Nothing, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, nothing, Agents.exp_propensity), AgentEvent{typeof(Main.move!), Float64, Tuple{Symbol, Symbol}, typeof(Main.movement_time)}(Main.move!, 0.5, (:Scissors, :Paper), Main.movement_time))</code></pre><h2 id="Creating-and-populating-the-EventQueueABM"><a class="docs-heading-anchor" href="#Creating-and-populating-the-EventQueueABM">Creating and populating the <code>EventQueueABM</code></a><a id="Creating-and-populating-the-EventQueueABM-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-and-populating-the-EventQueueABM" title="Permalink"></a></h2><p>This step is almost identical to making a <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a> in the main <a href="../../tutorial/#Tutorial">Tutorial</a>. We create an instance of <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a> by giving it the agent type it will have, the events, and a space (optionally, defaults to no space). Here we have</p><pre><code class="language-julia hljs">space = GridSpaceSingle((100, 100))

using Random: Xoshiro
rng = Xoshiro(42)

model = EventQueueABM(RPS, events, space; rng, warn = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EventQueueABM{GridSpaceSingle{2, true}, Main.RPS, Dict{Int64, Main.RPS}, Nothing, Tuple{AgentEvent{typeof(Main.attack!), Float64, Nothing, typeof(Agents.exp_propensity)}, AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), Nothing, typeof(Agents.exp_propensity)}, AgentEvent{typeof(Main.move!), Float64, Tuple{Symbol, Symbol}, typeof(Main.movement_time)}}, Random.Xoshiro, Vector{Vector{Int64}}, Vector{Vector{Float64}}, Vector{Vector{Int64}}, DataStructures.BinaryHeap{Pair{Tuple{Int64, Int64}, Float64}, Base.Order.By{typeof(last), Base.Order.ForwardOrdering}}}(Dict{Int64, Main.RPS}(), GridSpaceSingle with size (100, 100), metric=chebyshev, periodic=true, nothing, Random.Xoshiro(0xa379de7eeeb2a4e8, 0x953dccb6b532b3af, 0xf597b8ff8cfd652a, 0xccd7337c571680d1, 0xc90c4a0730db3f7e), Base.RefValue{Int64}(0), Base.RefValue{Float64}(0.0), (AgentEvent{typeof(Main.attack!), Float64, Nothing, typeof(Agents.exp_propensity)}(Main.attack!, 1.0, nothing, Agents.exp_propensity), AgentEvent{typeof(Main.reproduce!), typeof(Main.reproduction_propensity), Nothing, typeof(Agents.exp_propensity)}(Main.reproduce!, Main.reproduction_propensity, nothing, Agents.exp_propensity), AgentEvent{typeof(Main.move!), Float64, Tuple{Symbol, Symbol}, typeof(Main.movement_time)}(Main.move!, 0.5, (:Scissors, :Paper), Main.movement_time)), Dict(:Paper =&gt; 2, :Rock =&gt; 1, :Scissors =&gt; 3), [[1, 2], [1, 2, 3], [1, 2, 3]], [[1.0, 0.0], [1.0, 0.0, 0.5], [1.0, 0.0, 0.5]], [[2], [2], [2]], DataStructures.BinaryHeap{Pair{Tuple{Int64, Int64}, Float64}, Base.Order.By{typeof(last), Base.Order.ForwardOrdering}}(Base.Order.By{typeof(last), Base.Order.ForwardOrdering}(last, Base.Order.ForwardOrdering()), Pair{Tuple{Int64, Int64}, Float64}[]), true, true)</code></pre><p>populating the model with agents is the same as in the main <a href="../../tutorial/#Tutorial">Tutorial</a>, using the <a href="../../api/#Agents.add_agent!"><code>add_agent!</code></a> function. By default, when an agent is added to the model an event is also generated for it and added to the queue.</p><pre><code class="language-julia hljs">for p in positions(model)
    type = rand(abmrng(model), (Rock, Paper, Scissors))
    add_agent!(p, type, model)
end</code></pre><p>We can see the list of scheduled events via</p><pre><code class="language-julia hljs">abmqueue(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DataStructures.BinaryHeap{Pair{Tuple{Int64, Int64}, Float64}, Base.Order.By{typeof(last), Base.Order.ForwardOrdering}}(Base.Order.By{typeof(last), Base.Order.ForwardOrdering}(last, Base.Order.ForwardOrdering()), [(6080, 1) =&gt; 2.9790681020079457e-6, (3987, 1) =&gt; 0.0003364593569030146, (6221, 2) =&gt; 0.0004887948187761659, (8424, 1) =&gt; 0.0006778319693496694, (5035, 1) =&gt; 0.0012044922191219774, (7014, 2) =&gt; 0.0005771225059120387, (3301, 2) =&gt; 0.0011396494447446436, (2505, 1) =&gt; 0.0014309955844005063, (5041, 2) =&gt; 0.001449028423933035, (5539, 2) =&gt; 0.0024520873429744127  …  (9990, 1) =&gt; 1.0666363792018059, (9992, 2) =&gt; 0.7429399475482082, (9993, 1) =&gt; 1.9378465659189394, (4997, 1) =&gt; 1.7907183401427267, (2496, 1) =&gt; 0.5304394096759053, (2499, 1) =&gt; 2.7442278746073216, (4998, 3) =&gt; 1.0804360033507288, (4999, 1) =&gt; 5.80807081086072, (9998, 1) =&gt; 0.9433255253597445, (1250, 3) =&gt; 1.258669914970242])</code></pre><p>Here the queue maps pairs of (agent id, event index) to the time the events will trigger. There are currently as many scheduled events because as the amount of agents we added to the model. Note that the timing of the events has been rounded for display reasons!</p><p>Now, as per-usual in Agents.jl we are making a keyword-based function for constructing the model, so that it is easier to handle later.</p><pre><code class="language-julia hljs">function initialize_rps(; n = 100, nx = n, ny = n, seed = 42)
    space = GridSpaceSingle((nx, ny))
    rng = Xoshiro(seed)
    model = EventQueueABM(RPS, events, space; rng, warn = false)
    for p in positions(model)
        type = rand(abmrng(model), (Rock, Paper, Scissors))
        add_agent!(p, type, model)
    end
    return model
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initialize_rps (generic function with 1 method)</code></pre><h2 id="Time-evolution"><a class="docs-heading-anchor" href="#Time-evolution">Time evolution</a><a id="Time-evolution-1"></a><a class="docs-heading-anchor-permalink" href="#Time-evolution" title="Permalink"></a></h2><p>Time evolution for <a href="@ref"><code>EventBasedABM</code></a> is identical to that of <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>, but time is continuous. So, when calling <code>step!</code> we pass in a real time.</p><pre><code class="language-julia hljs">step!(model, 123.456)

nagents(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9760</code></pre><p>Alternatively we could give a function for when to terminate the time evolution. For example, we terminate if any of the three types of agents become less than a threshold</p><pre><code class="language-julia hljs">function terminate(model, t)
    kinds = allkinds(RPS)
    threshold = 1000
    # Alright, this code snippet loops over all kinds,
    # and for each it checks if it is less than the threshold.
    # if any is, it returns `true`, otherwise `false.`
    logic = any(kinds) do kind
        n = count(a -&gt; kindof(a) == kind, allagents(model))
        return n &lt; threshold
    end
    # For safety, in case this never happens, we also add a trigger
    # regarding the total evolution time
    return logic || (t &gt; 1000.0)
end

step!(model, terminate)

abmtime(model)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">139.84392719607195</code></pre><h2 id="Data-collection"><a class="docs-heading-anchor" href="#Data-collection">Data collection</a><a id="Data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection" title="Permalink"></a></h2><p>The entirety of the Agents.jl <a href="../../api/#API">API</a> is orthogonal/agnostic to what model we have. This means that whatever we do, plotting, data collection, etc., has identical syntax irrespectively of whether we have a <code>StandardABM</code> or <code>EventQueueABM</code>.</p><p>Hence, data collection also works almost identically to <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a>.</p><p>Here we will simply collect the number of each agent kind.</p><pre><code class="language-julia hljs">model = initialize_rps()

adata = [(a -&gt; kindof(a) === X, count) for X in allkinds(RPS)]

adf, mdf = run!(model, 100.0; adata, when = 0.5, dt = 0.01)

adf[1:10, :]</code></pre><div><div style = "float: left;"><span>10×4 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">time</th><th style = "text-align: left;">count_#25_X=Rock</th><th style = "text-align: left;">count_#25_X=Paper</th><th style = "text-align: left;">count_#25_X=Scissors</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Float64" style = "text-align: left;">Float64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">0.0</td><td style = "text-align: right;">3293</td><td style = "text-align: right;">3372</td><td style = "text-align: right;">3335</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">0.5</td><td style = "text-align: right;">3215</td><td style = "text-align: right;">3251</td><td style = "text-align: right;">3185</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">1.0</td><td style = "text-align: right;">3206</td><td style = "text-align: right;">3204</td><td style = "text-align: right;">3049</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">1.5</td><td style = "text-align: right;">3151</td><td style = "text-align: right;">3106</td><td style = "text-align: right;">2887</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">2.0</td><td style = "text-align: right;">3044</td><td style = "text-align: right;">2989</td><td style = "text-align: right;">2667</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">2.51</td><td style = "text-align: right;">2944</td><td style = "text-align: right;">2882</td><td style = "text-align: right;">2406</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: right;">3.02</td><td style = "text-align: right;">2942</td><td style = "text-align: right;">2887</td><td style = "text-align: right;">2319</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: right;">3.53</td><td style = "text-align: right;">3108</td><td style = "text-align: right;">2985</td><td style = "text-align: right;">2345</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: right;">4.04</td><td style = "text-align: right;">3240</td><td style = "text-align: right;">3106</td><td style = "text-align: right;">2360</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: right;">4.55</td><td style = "text-align: right;">3241</td><td style = "text-align: right;">3135</td><td style = "text-align: right;">2276</td></tr></tbody></table></div><p>Let&#39;s visualize the population sizes versus time:</p><pre><code class="language-julia hljs">using Agents.DataFrames
using CairoMakie

tvec = adf[!, :time]
populations = adf[:, Not(:time)]
alabels = [&quot;rocks&quot;, &quot;papers&quot;, &quot;scissors&quot;]

fig = Figure();
ax = Axis(fig[1,1]; xlabel = &quot;time&quot;, ylabel = &quot;population&quot;)
for (i, l) in enumerate(alabels)
    lines!(ax, tvec, populations[!, i]; label = l)
end
axislegend(ax)
fig</code></pre><img src="d6a285c8.png" alt="Example block output"/><h2 id="Visualization"><a class="docs-heading-anchor" href="#Visualization">Visualization</a><a id="Visualization-1"></a><a class="docs-heading-anchor-permalink" href="#Visualization" title="Permalink"></a></h2><p>Visualization for <a href="../../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a> is identical to that for <a href="../../api/#Agents.StandardABM"><code>StandardABM</code></a> that we learned in the <a href="../agents_visualizations/#vis_tutorial">visualization tutorial</a>. Naturally, for <code>EventQueueABM</code> the <code>dt</code> argument of <a href="../../api/#Agents.abmvideo"><code>abmvideo</code></a> corresponds to continuous time and does not have to be an integer.</p><pre><code class="language-julia hljs">const colormap = Dict(:Rock =&gt; &quot;black&quot;, :Scissors =&gt; &quot;gray&quot;, :Paper =&gt; &quot;orange&quot;)
agent_color(agent) = colormap[kindof(agent)]
plotkw = (agent_color, agent_marker = :rect, agent_size = 5)
fig, ax, abmobs = abmplot(model; plotkw...)

fig</code></pre><img src="fcf79f78.png" alt="Example block output"/><pre><code class="language-julia hljs">model = initialize_rps()
abmvideo(&quot;rps_eventqueue.mp4&quot;, model;
    dt = 0.5, frames = 300,
    title = &quot;Rock Paper Scissors (event based)&quot;, plotkw...,
)</code></pre><video width="auto" controls autoplay loop>
<source src="../rps_eventqueue.mp4" type="video/mp4">
</video><p>We see model dynamics similar to Schelling&#39;s segregation model: neighborhoods for same-type agents form! But they are not static, but rather expand and contract over time!</p><p>We could explore this interactively by launching the interactive GUI with the <a href="../../api/#Agents.abmexploration"><code>abmexploration</code></a> function!</p><p>Let&#39;s first define the data we want to visualize, which in this case is just the count of each agent kind</p><pre><code class="language-julia hljs">model = initialize_rps()
fig, abmobs = abmexploration(model; adata, alabels, when = 0.5, plotkw...)
fig</code></pre><img src="0eddb078.png" alt="Example block output"/><p>We can then step the observable and see the updates in the plot:</p><pre><code class="language-julia hljs">for _ in 1:100 # this loop simulates pressing the `run!` button
    step!(abmobs, 1.0)
end

fig</code></pre><img src="fb51c2f3.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rabbit_fox_hawk/">« 3D Mixed-Agent Ecosystem with Pathfinding</a><a class="docs-footer-nextpage" href="../">More Examples for Agents.jl »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 9 May 2024 08:24">Thursday 9 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
