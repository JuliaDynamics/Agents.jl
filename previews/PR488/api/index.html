<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Agents.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/">Overview</a></li><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sugarscape/">Sugarscape</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../examples/predator_prey_fast/">Predator-Prey</a></li><li><a class="tocitem" href="../examples/maze/">Maze Solver</a></li><li><a class="tocitem" href="../examples/runners/">Mountain Runners</a></li><li><a class="tocitem" href="../examples/growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../examples/opinion_spread/">Opinion spread</a></li><li><a class="tocitem" href="../examples/battle/">Battle Royale</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak</a></li><li><a class="tocitem" href="../examples/fractal_growth/">Fractal Growth</a></li></ul></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#@agent-macro"><span><code>@agent</code> macro</span></a></li><li><a class="tocitem" href="#Agent/model-retrieval-and-access"><span>Agent/model retrieval and access</span></a></li><li><a class="tocitem" href="#Available-spaces"><span>Available spaces</span></a></li><li><a class="tocitem" href="#Adding-agents"><span>Adding agents</span></a></li><li><a class="tocitem" href="#Moving-agents"><span>Moving agents</span></a></li><li><a class="tocitem" href="#Removing-agents"><span>Removing agents</span></a></li><li><a class="tocitem" href="#Discrete-space-exclusives"><span>Discrete space exclusives</span></a></li><li><a class="tocitem" href="#Continuous-space-exclusives"><span>Continuous space exclusives</span></a></li><li><a class="tocitem" href="#Graph-space-exclusives"><span>Graph space exclusives</span></a></li><li><a class="tocitem" href="#OpenStreetMap-space-exclusives"><span>OpenStreetMap space exclusives</span></a></li><li><a class="tocitem" href="#Local-area"><span>Local area</span></a></li><li><a class="tocitem" href="#A-note-on-iteration"><span>A note on iteration</span></a></li><li><a class="tocitem" href="#Higher-order-interactions"><span>Higher-order interactions</span></a></li><li><a class="tocitem" href="#Parameter-scanning"><span>Parameter scanning</span></a></li><li><a class="tocitem" href="#Data-collection"><span>Data collection</span></a></li><li><a class="tocitem" href="#Schedulers"><span>Schedulers</span></a></li><li><a class="tocitem" href="#Ensemble-runs-and-Parallelization"><span>Ensemble runs and Parallelization</span></a></li><li><a class="tocitem" href="#Path-finding"><span>Path-finding</span></a></li></ul></li><li><a class="tocitem" href="../interact/">Plotting and interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">LightGraphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The API of Agents.jl is defined on top of the fundamental structures  <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, <a href="../tutorial/#Space">Space</a>, <a href="../tutorial/#Agents.AbstractAgent"><code>AbstractAgent</code></a> which are described in the <a href="../tutorial/#Tutorial">Tutorial</a> page. In this page we list the remaining API functions, which constitute the bulk of Agents.jl functionality.</p><h2 id="@agent-macro"><a class="docs-heading-anchor" href="#@agent-macro"><code>@agent</code> macro</a><a id="@agent-macro-1"></a><a class="docs-heading-anchor-permalink" href="#@agent-macro" title="Permalink"></a></h2><p>The <a href="#Agents.@agent"><code>@agent</code></a> macro makes defining agent types within Agents.jl simple.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.@agent" href="#Agents.@agent"><code>Agents.@agent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@agent YourAgentType{X, Y} AgentSupertype begin
    some_property::X
    other_extra_property::Y
    # etc...
end</code></pre><p>Create a struct for your agents which includes the mandatory fields required to operate in a particular space. Depending on the space of your model, the <code>AgentSupertype</code> is chosen appropriately from <a href="#Agents.GraphAgent"><code>GraphAgent</code></a>, <a href="#Agents.GridAgent"><code>GridAgent</code></a>, <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a>, <a href="#Agents.OSMAgent"><code>OSMAgent</code></a>.</p><p><strong>Example</strong></p><p>Using</p><pre><code class="language-julia">@agent Person{T} GridAgent{2} begin
    age::Int
    moneyz::T
end</code></pre><p>will in fact create an agent appropriate for using with 2-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a></p><pre><code class="language-julia">mutable struct Person{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    age::Int
    moneyz::T
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/agents.jl#L31-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphAgent" href="#Agents.GraphAgent"><code>Agents.GraphAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphAgent</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>. It attributes the fields <code>id::Int, pos::Int</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/agents.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridAgent" href="#Agents.GridAgent"><code>Agents.GridAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridAgent{D}</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <code>D</code>-dimensional <a href="#Agents.GridSpace"><code>GridSpace</code></a>. It attributes the fields <code>id::Int, pos::NTuple{D,Int}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/agents.jl#L82-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousAgent" href="#Agents.ContinuousAgent"><code>Agents.ContinuousAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousAgent{D}</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <code>D</code>-dimensional <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. It attributes the fields <code>id::Int, pos::NTuple{D,Float64}, vel::NTuple{D,Float64}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/agents.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSMAgent" href="#Agents.OSMAgent"><code>Agents.OSMAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OSMAgent</code></pre><p>Combine with <a href="#Agents.@agent"><code>@agent</code></a> to create an agent type for <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>. It attributes the fields <code>id::Int, pos::Tuple{Int,Int,Float64}, route::Vector{Int}, destination::Tuple{Int,Int,Float64}</code> to the start of the agent type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/agents.jl#L106-L112">source</a></section></article><h2 id="Agent/model-retrieval-and-access"><a class="docs-heading-anchor" href="#Agent/model-retrieval-and-access">Agent/model retrieval and access</a><a id="Agent/model-retrieval-and-access-1"></a><a class="docs-heading-anchor-permalink" href="#Agent/model-retrieval-and-access" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AgentBasedModel, Integer}" href="#Base.getindex-Tuple{AgentBasedModel, Integer}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model[id]
getindex(model::ABM, id::Integer)</code></pre><p>Return an agent given its ID.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getproperty-Tuple{AgentBasedModel, Symbol}" href="#Base.getproperty-Tuple{AgentBasedModel, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">model.prop
getproperty(model::ABM, :prop)</code></pre><p>Return a property with name <code>:prop</code> from the current <code>model</code>, assuming the model <code>properties</code> are either a dictionary with key type <code>Symbol</code> or a Julia struct. For example, if a model has the set of properties <code>Dict(:weight =&gt; 5, :current =&gt; false)</code>, retrieving these values can be obtained via <code>model.weight</code>.</p><p>The property names <code>:agents, :space, :scheduler, :properties, :maxid</code> are internals and <strong>should not be accessed by the user</strong>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L134-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.seed!" href="#Agents.seed!"><code>Agents.seed!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seed!(model [, seed])</code></pre><p>Reseed the random number pool of the model with the given seed or a random one, when using a pseudo-random number generator like <code>MersenneTwister</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_agent" href="#Agents.random_agent"><code>Agents.random_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_agent(model) → agent</code></pre><p>Return a random agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L190-L193">source</a></section><section><div><pre><code class="nohighlight">random_agent(model, condition) → agent</code></pre><p>Return a random agent from the model that satisfies <code>condition(agent) == true</code>. The function generates a random permutation of agent IDs and iterates through them. If no agent satisfies the condition, <code>nothing</code> is returned instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L196-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nagents" href="#Agents.nagents"><code>Agents.nagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nagents(model::ABM)</code></pre><p>Return the number of agents in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L214-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allagents" href="#Agents.allagents"><code>Agents.allagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allagents(model)</code></pre><p>Return an iterator over all agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L220-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allids" href="#Agents.allids"><code>Agents.allids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allids(model)</code></pre><p>Return an iterator over all agent IDs of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L226-L229">source</a></section></article><h2 id="Available-spaces"><a class="docs-heading-anchor" href="#Available-spaces">Available spaces</a><a id="Available-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Available-spaces" title="Permalink"></a></h2><p>Here we list the spaces that are available &quot;out of the box&quot; from Agents.jl. To create your own, see <a href="../devdocs/#Creating-a-new-space-type">Creating a new space type</a>.</p><h3 id="Discrete-spaces"><a class="docs-heading-anchor" href="#Discrete-spaces">Discrete spaces</a><a id="Discrete-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphSpace" href="#Agents.GraphSpace"><code>Agents.GraphSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphSpace(graph::AbstractGraph)</code></pre><p>Create a <code>GraphSpace</code> instance that is underlined by an arbitrary graph from <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>. The position type for this space is <code>Int</code>, use <a href="#Agents.GraphAgent"><code>GraphAgent</code></a> for convenience. The underlying graph can be altered using <a href="#Agents.add_node!"><code>add_node!</code></a> and <a href="#Agents.rem_node!"><code>rem_node!</code></a>.</p><p><code>GraphSpace</code> represents a space where each node (i.e. position) of a graph can hold an arbitrary amount of agents, and each agent can move between the nodes of the graph. An example of its usage can be found in <a href="../examples/sir/#SIR-model-for-the-spread-of-COVID-19">SIR model for the spread of COVID-19</a>. If you want to model social networks, where each agent is equivalent with a node of a graph, you&#39;re better of using <code>nothing</code> (or other spaces) as the model space, and using a graph from LightGraphs.jl directly in the model parameters, as shown in the <a href="../examples/schoolyard/#Social-networks-with-LightGraphs.jl">Social networks with LightGraphs.jl</a> integration example.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/graph.jl#L11-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridSpace" href="#Agents.GridSpace"><code>Agents.GridSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridSpace(d::NTuple{D, Int}; periodic = true, metric = :chebyshev, pathfinder = nothing)</code></pre><p>Create a <code>GridSpace</code> that has size given by the tuple <code>d</code>, having <code>D ≥ 1</code> dimensions. Optionally decide whether the space will be periodic and what will be the distance metric used, which decides the behavior of e.g. <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>. The position type for this space is <code>NTuple{D, Int}</code>, use <a href="#Agents.GridAgent"><code>GridAgent</code></a> for convenience. In our examples we typically use <code>Dims{D}</code> instead of <code>NTuple{D, Int}</code> (they are equivalent). Valid positions have indices in the range <code>1:d[i]</code> for the <code>i</code>th dimension.</p><p><code>:chebyshev</code> metric means that the <code>r</code>-neighborhood of a position are all positions within the hypercube having side length of <code>2*floor(r)</code> and being centered in the origin position.</p><p><code>:euclidean</code> metric means that the <code>r</code>-neighborhood of a position are all positions whose cartesian indices have Euclidean distance <code>≤ r</code> from the cartesian index of the given position.</p><p><code>pathfinder</code>: Optionally provide an instance of <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a> to enable pathfinding capabilities based on the A* algorithm, see <a href="#Path-finding">Path-finding</a> in the docs.</p><p>An example using <code>GridSpace</code> is the <a href="../examples/forest_fire/#Forest-fire-model">Forest fire model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/grid.jl#L28-L49">source</a></section></article><h3 id="Continuous-spaces"><a class="docs-heading-anchor" href="#Continuous-spaces">Continuous spaces</a><a id="Continuous-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-spaces" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousSpace" href="#Agents.ContinuousSpace"><code>Agents.ContinuousSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousSpace(extent::NTuple{D, &lt;:Real}, spacing = min(extent...)/10; kwargs...)</code></pre><p>Create a <code>D</code>-dimensional <code>ContinuousSpace</code> in range 0 to (but not including) <code>extent</code>. <code>spacing</code> configures the compartment spacing that the space is divided in, in order to accelerate nearest neighbor functions like <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>. All dimensions in <code>extent</code> must be completely divisible by <code>spacing</code> (i.e. no fractional remainder). Your agent positions (field <code>pos</code>) must be of type <code>NTuple{D, &lt;:Real}</code>, use <a href="#Agents.ContinuousAgent"><code>ContinuousAgent</code></a> for convenience. In addition it is useful for agents to have a field <code>vel::NTuple{D, &lt;:Real}</code> to use in conjunction with <a href="#Agents.move_agent!"><code>move_agent!</code></a>.</p><p>The keyword <code>periodic = true</code> configures whether the space is periodic or not. If set to <code>false</code> an error will occur if an agent&#39;s position exceeds the boundary.</p><p>The keyword argument <code>update_vel!</code> is a <strong>function</strong>, <code>update_vel!(agent, model)</code> that updates the agent&#39;s velocity <strong>before</strong> the agent has been moved, see <a href="#Agents.move_agent!"><code>move_agent!</code></a>. You can of course change the agents&#39; velocities during the agent interaction, the <code>update_vel!</code> functionality targets spatial force fields acting on the agents individually (e.g. some magnetic field). By default no update is done this way. If you use <code>update_vel!</code>, the agent type must have a field <code>vel::NTuple{D, &lt;:Real}</code>.</p><p>There is no &quot;best&quot; choice for the value of <code>spacing</code>. If you need optimal performance it&#39;s advised to set up a benchmark over a range of choices. The value matters most when searching for neighbors. In <a href="../models/#Agents.Models.flocking-Tuple{}"><code>Models.flocking</code></a> for example, an optimal value for <code>spacing</code> is 66% of the search distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/continuous.jl#L13-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OpenStreetMapSpace" href="#Agents.OpenStreetMapSpace"><code>Agents.OpenStreetMapSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OpenStreetMapSpace(path::AbstractString; kwargs...)</code></pre><p>Create a space residing on the Open Street Map (OSM) file provided via <code>path</code>. The functionality related to Open Street Map spaces is in the submodule <code>OSM</code>.</p><p>This space represents the underlying map as a <em>continuous</em> entity choosing accuracy over performance by explicitly taking into account that every intersection is connected by a road with a finite length in meters. An example of its usage can be found in <a href="../examples/zombies/#Zombie-Outbreak">Zombie Outbreak</a>. Nevertheless, all functions that target <code>DiscreteSpace</code>s apply here as well, e.g. <a href="#Agents.positions"><code>positions</code></a>. The discrete part are the underlying road intersections, that are represented by a graph.</p><p>Much of the functionality of this space is provided by interfacing with <a href="https://github.com/pszufe/OpenStreetMapX.jl">OpenStreetMapX.jl</a>, for example the two keyword arguments <code>use_cache = false</code> and <code>trim_to_connected_graph = true</code> can be passed into the <code>OpenStreetMapX.get_map_data</code> function.</p><p>For details on how to obtain an OSM file for your use case, consult the OpenStreetMapX.jl README. We provide a variable <code>OSM.TEST_MAP</code> to use as a <code>path</code> for testing.</p><p>If your solution can tolerate routes to and from intersections only without caring for the continuity of the roads in between, a faster implementation can be achieved by using the <a href="https://pszufe.github.io/OpenStreetMapX.jl/stable/reference/#OpenStreetMapX.MapData">graph representation</a> of your map provided by OpenStreetMapX.jl. For tips on how to implement this, see our integration example: <a href="../examples/schoolyard/#Social-networks-with-LightGraphs.jl">Social networks with LightGraphs.jl</a>.</p><p><strong>The OSMAgent</strong></p><p>The base properties for an agent residing on an <code>OSMSpace</code> are as follows:</p><pre><code class="language-julia">mutable struct OSMAgent &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int,Int,Float64}
    route::Vector{Int}
    destination::Tuple{Int,Int,Float64}
end</code></pre><p>Current <code>pos</code>ition and <code>destination</code> tuples are represented as <code>(start intersection index, finish intersection index, distance travelled in meters)</code>. The <code>route</code> is an ordered list of intersections, providing a path to reach <code>destination</code>.</p><p>Further details can be found in <a href="#Agents.OSMAgent"><code>OSMAgent</code></a>.</p><p><strong>Routing</strong></p><p>There are two ways to generate a route, depending on the situation.</p><ol><li>Assign the value of <a href="#Agents.OSM.plan_route"><code>OSM.plan_route</code></a> to the <code>.route</code> field of an Agent. This provides <code>:shortest</code> and <code>:fastest</code> paths (with the option of a <code>return_trip</code>) between intersections or positions.</li><li><a href="#Agents.OSM.random_route!"><code>OSM.random_route!</code></a>, choses a new <code>destination</code> an plans a new path to it; overriding the current route (if any).</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L660-L713">source</a></section></article><h2 id="Adding-agents"><a class="docs-heading-anchor" href="#Adding-agents">Adding agents</a><a id="Adding-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent!" href="#Agents.add_agent!"><code>Agents.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent!(agent::AbstractAgent [, pos], model::ABM) → agent</code></pre><p>Add the <code>agent</code> to the model in the given position. If <code>pos</code> is not given, the <code>agent</code> is added to a random position. The <code>agent</code>&#39;s position is always updated to match <code>position</code>, and therefore for <code>add_agent!</code> the position of the <code>agent</code> is meaningless. Use <a href="#Agents.add_agent_pos!"><code>add_agent_pos!</code></a> to use the <code>agent</code>&#39;s position.</p><p>The type of <code>pos</code> must match the underlying space position type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L216-L225">source</a></section><section><div><pre><code class="nohighlight">add_agent!([pos,] model::ABM, args...; kwargs...) → newagent</code></pre><p>Create and add a new agent to the model using the constructor of the agent type of the model. Optionally provide a position to add the agent to as <em>first argument</em>, which must match the space position type.</p><p>This function takes care of setting the agent&#39;s id <em>and</em> position. The extra provided <code>args...</code> and <code>kwargs...</code> are propagated to other fields of the agent constructor (see example below).</p><pre><code class="nohighlight">add_agent!([pos,] A::Type, model::ABM, args...; kwargs...) → newagent</code></pre><p>Use this version for mixed agent models, with <code>A</code> the agent type you wish to create (to be called as <code>A(id, pos, args...; kwargs...)</code>), because it is otherwise not possible to deduce a constructor for <code>A</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::Int
    w::Float64
    k::Bool
end
Agent(id, pos; w=0.5, k=false) = Agent(id, pos, w, k) # keyword constructor
model = ABM(Agent, GraphSpace(complete_digraph(5)))

add_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally
add_agent!(model, 0.5, true) # correct: w becomes 0.5
add_agent!(5, model, 0.5, true) # add at position 5, w becomes 0.5
add_agent!(model; w = 0.5) # use keywords: w becomes 0.5, k becomes false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L236-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_pos!" href="#Agents.add_agent_pos!"><code>Agents.add_agent_pos!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_pos!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Add the agent to the <code>model</code> at the agent&#39;s own position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L205-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nextid" href="#Agents.nextid"><code>Agents.nextid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextid(model::ABM) → id</code></pre><p>Return a valid <code>id</code> for creating a new agent with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L128-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_position" href="#Agents.random_position"><code>Agents.random_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_position(model) → pos</code></pre><p>Return a random position in the model&#39;s space (always with appropriate Type).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L34-L37">source</a></section></article><h2 id="Moving-agents"><a class="docs-heading-anchor" href="#Moving-agents">Moving agents</a><a id="Moving-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent!" href="#Agents.move_agent!"><code>Agents.move_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent!(agent [, pos], model::ABM) → agent</code></pre><p>Move agent to the given position, or to a random one if a position is not given. <code>pos</code> must have the appropriate position type depending on the space type.</p><p>The agent&#39;s position is updated to match <code>pos</code> after the move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L40-L47">source</a></section><section><div><pre><code class="nohighlight">move_agent!(agent::A, model::ABM{&lt;:ContinuousSpace,A}, dt::Real = 1.0)</code></pre><p>Propagate the agent forwards one step according to its velocity, <em>after</em> updating the agent&#39;s velocity (if configured, see <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>). Also take care of periodic boundary conditions.</p><p>For this continuous space version of <code>move_agent!</code>, the &quot;evolution algorithm&quot; is a trivial Euler scheme with <code>dt</code> the step size, i.e. the agent position is updated as <code>agent.pos += agent.vel * dt</code>. If you want to move the agent to a specified position, do <code>move_agent!(agent, pos, model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/continuous.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.walk!" href="#Agents.walk!"><code>Agents.walk!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">walk!(agent, direction::NTuple, model; ifempty = false)</code></pre><p>Move agent in the given <code>direction</code> respecting periodic boundary conditions. If <code>periodic = false</code>, agents will walk to, but not exceed the boundary value. Possible on both <code>GridSpace</code> and <code>ContinuousSpace</code>s.</p><p>The dimensionality of <code>direction</code> must be the same as the space. <code>GridSpace</code> asks for <code>Int</code>, and <code>ContinuousSpace</code> for <code>Float64</code> vectors, describing the walk distance in each direction. <code>direction = (2, -3)</code> is an example of a valid direction on a <code>GridSpace</code>, which moves the agent to the right 2 positions and down 3 positions. Velocity is ignored for this operation in <code>ContinuousSpace</code>.</p><p><strong>Keywords</strong></p><ul><li><code>ifempty</code> will check that the target position is unnocupied and only move if that&#39;s true. Available only on <code>GridSpace</code>.</li></ul><p>Example usage in <a href="../examples/battle/#Battle-Royale">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/utilities.jl#L91-L108">source</a></section><section><div><pre><code class="nohighlight">walk!(agent, rand, model)</code></pre><p>Invoke a random walk by providing the <code>rand</code> function in place of <code>distance</code>. For <code>GridSpace</code>, the walk will cover ±1 positions in all directions, <code>ContinuousSpace</code> will reside within [-1, 1].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/utilities.jl#L157-L163">source</a></section></article><h3 id="Movement-with-paths"><a class="docs-heading-anchor" href="#Movement-with-paths">Movement with paths</a><a id="Movement-with-paths-1"></a><a class="docs-heading-anchor-permalink" href="#Movement-with-paths" title="Permalink"></a></h3><p>For <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>, and <a href="#Agents.GridSpace"><code>GridSpace</code></a>s using <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a>, a special movement method is available.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.move_along_route!" href="#Agents.move_along_route!"><code>Agents.move_along_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_along_route!(agent, model::ABM{&lt;:OpenStreetMapSpace}, distance::Real)</code></pre><p>Move an agent by <code>distance</code> in meters along its planned route.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L345-L349">source</a></section><section><div><pre><code class="nohighlight">move_along_route!(agent, model_with_pathfinding)</code></pre><p>Move <code>agent</code> for one step along the route toward its target set by <a href="#Agents.Pathfinding.set_target!"><code>Pathfinding.set_target!</code></a> for agents on a <a href="#Agents.GridSpace"><code>GridSpace</code></a> using a <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a>. If the agent does not have a precalculated path or the path is empty, it remains stationary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/grid_pathfinder.jl#L376-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.is_stationary" href="#Agents.is_stationary"><code>Agents.is_stationary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_stationary(agent, model)</code></pre><p>Return <code>true</code> if agent has reached the end of its route, or no route has been set for it. Used in setups where using <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> is valid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L131-L135">source</a></section></article><h2 id="Removing-agents"><a class="docs-heading-anchor" href="#Removing-agents">Removing agents</a><a id="Removing-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Removing-agents" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.kill_agent!" href="#Agents.kill_agent!"><code>Agents.kill_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kill_agent!(agent::AbstractAgent, model::ABM)
kill_agent!(id::Int, model::ABM)</code></pre><p>Remove an agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.genocide!" href="#Agents.genocide!"><code>Agents.genocide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genocide!(model::ABM)</code></pre><p>Kill all the agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L154-L157">source</a></section><section><div><pre><code class="nohighlight">genocide!(model::ABM, n::Int)</code></pre><p>Kill the agents whose IDs are larger than n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L165-L168">source</a></section><section><div><pre><code class="nohighlight">genocide!(model::ABM, IDs)</code></pre><p>Kill the agents with the given IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L176-L179">source</a></section><section><div><pre><code class="nohighlight">genocide!(model::ABM, f::Function)</code></pre><p>Kill all agents where the function <code>f(agent)</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L186-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.sample!" href="#Agents.sample!"><code>Agents.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample!(model::ABM, n [, weight]; kwargs...)</code></pre><p>Replace the agents of the <code>model</code> with a random sample of the current agents with size <code>n</code>.</p><p>Optionally, provide a <code>weight</code>: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the <code>weight</code> of the agent, the higher the probability that this agent will be chosen in the new sampling.</p><p><strong>Keywords</strong></p><ul><li><code>replace = true</code> : whether sampling is performed with replacement, i.e. all agents can</li></ul><p>be chosen more than once.</p><p>Example usage in <a href="../examples/wright-fisher/#Wright-Fisher-model-of-evolution">Wright-Fisher model of evolution</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/sample.jl#L4-L20">source</a></section></article><h2 id="Discrete-space-exclusives"><a class="docs-heading-anchor" href="#Discrete-space-exclusives">Discrete space exclusives</a><a id="Discrete-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.positions" href="#Agents.positions"><code>Agents.positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">positions(model::ABM{&lt;:DiscreteSpace}) → ns</code></pre><p>Return an iterator over all positions of a model with a discrete space.</p><pre><code class="nohighlight">positions(model::ABM{&lt;:DiscreteSpace}, by::Symbol) → ns</code></pre><p>Return all positions of a model with a discrete space, sorting them using the argument <code>by</code> which can be:</p><ul><li><code>:random</code> - randomly sorted</li><li><code>:population</code> - positions are sorted depending on how many agents they accommodate. The more populated positions are first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L13-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.ids_in_position" href="#Agents.ids_in_position"><code>Agents.ids_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ids_in_position(position, model::ABM{&lt;:DiscreteSpace})
ids_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the ids of agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.agents_in_position" href="#Agents.agents_in_position"><code>Agents.agents_in_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">agents_in_position(position, model::ABM{&lt;:DiscreteSpace})
agents_in_position(agent, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return the agents in the position corresponding to <code>position</code> or position of <code>agent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.fill_space!" href="#Agents.fill_space!"><code>Agents.fill_space!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, args...; kwargs...)
fill_space!([A ,] model::ABM{&lt;:DiscreteSpace,A}, f::Function; kwargs...)</code></pre><p>Add one agent to each position in the model&#39;s space. Similarly with <a href="#Agents.add_agent!"><code>add_agent!</code></a>, the function creates the necessary agents and the <code>args...; kwargs...</code> are propagated into agent creation. If instead of <code>args...</code> a function <code>f</code> is provided, then <code>args = f(pos)</code> is the result of applying <code>f</code> where <code>pos</code> is each position (tuple for grid, index for graph).</p><p>An optional first argument is an agent <strong>type</strong> to be created, and targets mixed agent models where the agent constructor cannot be deduced (since it is a union).</p><p>Example usage in <a href="../examples/daisyworld/#Daisyworld">Daisyworld</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L123-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.has_empty_positions" href="#Agents.has_empty_positions"><code>Agents.has_empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_empty_positions(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are any positions in the model without agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L72-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.empty_positions" href="#Agents.empty_positions"><code>Agents.empty_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">empty_positions(model)</code></pre><p>Return a list of positions that currently have no agents on them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_empty" href="#Agents.random_empty"><code>Agents.random_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_empty(model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return a random position without any agents, or <code>nothing</code> if no such positions exist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L80-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_single!" href="#Agents.add_agent_single!"><code>Agents.add_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agent</code></pre><p>Add the <code>agent</code> to a random position in the space while respecting a maximum of one agent per position, updating the agent&#39;s position to the new one.</p><p>This function does nothing if there aren&#39;t any empty positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L95-L102">source</a></section><section><div><pre><code class="nohighlight">add_agent_single!(model::ABM{&lt;:DiscreteSpace}, properties...; kwargs...)</code></pre><p>Same as <code>add_agent!(model, properties...; kwargs...)</code> but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent_single!" href="#Agents.move_agent_single!"><code>Agents.move_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent_single!(agent, model::ABM{&lt;:DiscreteSpace}) → agent</code></pre><p>Move agent to a random position while respecting a maximum of one agent per position. If there are no empty positions, the agent won&#39;t move.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Integer, AgentBasedModel}" href="#Base.isempty-Tuple{Integer, AgentBasedModel}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(position, model::ABM{&lt;:DiscreteSpace})</code></pre><p>Return <code>true</code> if there are no agents in <code>position</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/discrete.jl#L66-L69">source</a></section></article><h2 id="Continuous-space-exclusives"><a class="docs-heading-anchor" href="#Continuous-space-exclusives">Continuous space exclusives</a><a id="Continuous-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.interacting_pairs" href="#Agents.interacting_pairs"><code>Agents.interacting_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interacting_pairs(model, r, method; scheduler = model.scheduler)</code></pre><p>Return an iterator that yields unique pairs of agents <code>(a1, a2)</code> that are close neighbors to each other, within some interaction radius <code>r</code>.</p><p>This function is usefully combined with <code>model_step!</code>, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with <code>a1</code> and with <code>a2</code>, which is unavoidable when using <code>agent_step!</code>).</p><p>The argument <code>method</code> provides three pairing scenarios</p><ul><li><code>:all</code>: return every pair of agents that are within radius <code>r</code> of each other, not only the nearest ones.</li><li><code>:nearest</code>: agents are only paired with their true nearest neighbor (existing within radius <code>r</code>). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by distance, then by next id in <code>scheduler</code>) will be paired.</li><li><code>:types</code>: For mixed agent models only. Return every pair of agents within radius <code>r</code> (similar to <code>:all</code>), only capturing pairs of differing types. For example, a model of <code>Union{Sheep,Wolf}</code> will only return pairs of <code>(Sheep, Wolf)</code>. In the case of multiple agent types, <em>e.g.</em> <code>Union{Sheep, Wolf, Grass}</code>, skipping pairings that involve <code>Grass</code>, can be achived by a <a href="#Schedulers"><code>scheduler</code></a> that doesn&#39;t schedule <code>Grass</code> types, <em>i.e.</em>: <code>scheduler(model) = (a.id for a in allagents(model) if !(a isa Grass))</code>.</li></ul><p>Example usage in <a href="../examples/growing_bacteria/#Bacterial-Growth">Bacterial Growth</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/continuous.jl#L275-L301">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearest_neighbor" href="#Agents.nearest_neighbor"><code>Agents.nearest_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearest_neighbor(agent, model::ABM{&lt;:ContinuousSpace}, r) → nearest</code></pre><p>Return the agent that has the closest distance to given <code>agent</code>. Return <code>nothing</code> if no agent is within distance <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/continuous.jl#L196-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.elastic_collision!" href="#Agents.elastic_collision!"><code>Agents.elastic_collision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elastic_collision!(a, b, f = nothing)</code></pre><p>Resolve a (hypothetical) elastic collision between the two agents <code>a, b</code>. They are assumed to be disks of equal size touching tangentially. Their velocities (field <code>vel</code>) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.</p><p>If <code>f</code> is a <code>Symbol</code>, then the agent property <code>f</code>, e.g. <code>:mass</code>, is taken as a mass to weight the two agents for the collision. By default no weighting happens.</p><p>One of the two agents can have infinite &quot;mass&quot;, and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.</p><p>Example usage in <a href="../examples/social_distancing/#Continuous-space-social-distancing-for-COVID-19">Continuous space social distancing for COVID-19</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/continuous.jl#L221-L238">source</a></section></article><h2 id="Graph-space-exclusives"><a class="docs-heading-anchor" href="#Graph-space-exclusives">Graph space exclusives</a><a id="Graph-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Graph-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.SimpleGraphs.add_edge!" href="#LightGraphs.SimpleGraphs.add_edge!"><code>LightGraphs.SimpleGraphs.add_edge!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_edge!(model::ABM{&lt;: GraphSpace}, n::Int, m::Int)</code></pre><p>Add a new edge (relationship between two positions) to the graph. Returns a boolean, true if the operation was succesful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/graph.jl#L144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_node!" href="#Agents.add_node!"><code>Agents.add_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_node!(model::ABM{&lt;: GraphSpace})</code></pre><p>Add a new node (i.e. possible position) to the model&#39;s graph and return it. You can connect this new node with existing ones using <a href="#LightGraphs.SimpleGraphs.add_edge!"><code>add_edge!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/graph.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.rem_node!" href="#Agents.rem_node!"><code>Agents.rem_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rem_node!(model::ABM{&lt;: GraphSpace}, n::Int)</code></pre><p>Remove node (i.e. position) <code>n</code> from the model&#39;s graph. All agents in that node are killed.</p><p><strong>Warning:</strong> LightGraphs.jl (and thus Agents.jl) swaps the index of the last node with that of the one to be removed, while every other node remains as is. This means that when doing <code>rem_node!(n, model)</code> the last node becomes the <code>n</code>-th node while the previous <code>n</code>-th node (and all its edges and agents) are deleted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/graph.jl#L112-L120">source</a></section></article><h2 id="OpenStreetMap-space-exclusives"><a class="docs-heading-anchor" href="#OpenStreetMap-space-exclusives">OpenStreetMap space exclusives</a><a id="OpenStreetMap-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#OpenStreetMap-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM" href="#Agents.OSM"><code>Agents.OSM</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">OSM</code></pre><p>Submodule for functionality related to <code>OpenStreetMapSpace</code>. See the docstring of the space for more info.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.latlon" href="#Agents.OSM.latlon"><code>Agents.OSM.latlon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.latlon(pos, model)
OSM.latlon(agent, model)</code></pre><p>Return (latitude, longitude) of current road or intersection position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L172-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.intersection" href="#Agents.OSM.intersection"><code>Agents.OSM.intersection</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">intersection(latlon::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return the nearest intersection position to (latitude, longitude). Quicker, but less precise than <a href="#Agents.OSM.road"><code>OSM.road</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.road" href="#Agents.OSM.road"><code>Agents.OSM.road</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.road(latlon::Tuple{Float64,Float64}, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Return a location on a road nearest to (latitude, longitude). Slower, but more precise than <a href="#Agents.OSM.intersection"><code>OSM.intersection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.random_road_position" href="#Agents.OSM.random_road_position"><code>Agents.OSM.random_road_position</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.random_road_position(model::ABM{OpenStreetMapSpace})</code></pre><p>Similar to <a href="#Agents.random_position"><code>random_position</code></a>, but rather than providing only intersections, this method returns a location somewhere on a road heading in a random direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L55-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.plan_route" href="#Agents.OSM.plan_route"><code>Agents.OSM.plan_route</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.plan_route(start, finish, model::ABM{&lt;:OpenStreetMapSpace};
               by = :shortest, return_trip = false, kwargs...)</code></pre><p>Generate a list of intersections between <code>start</code> and <code>finish</code> points on the map. <code>start</code> and <code>finish</code> can either be intersections (<code>Int</code>) or positions (<code>Tuple{Int,Int,Float64}</code>).</p><p>When either point is a position, the associated intersection index will be removed from the route to avoid double counting.</p><p>Route is planned via the shortest path by default (<code>by = :shortest</code>), but can also be planned <code>by = :fastest</code>. Road speeds are needed for this method which can be passed in via extra keyword arguments. Consult the OpenStreetMapX documentation for more details.</p><p>If <code>return_trip = true</code>, a route will be planned from start -&gt; finish -&gt; start.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L78-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.random_route!" href="#Agents.OSM.random_route!"><code>Agents.OSM.random_route!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.random_route!(agent, model::ABM{&lt;:OpenStreetMapSpace})</code></pre><p>Plan a new random route for the agent, by selecting a random destination and planning a route from the agent&#39;s current position. Overwrite any current route.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.road_length" href="#Agents.OSM.road_length"><code>Agents.OSM.road_length</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.road_length(start::Int, finish::Int, model)
OSM.road_length(pos::Tuple{Int,Int,Float64}, model)</code></pre><p>Return the road length (in meters) between two intersections given by intersection ids.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L285-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.OSM.map_coordinates" href="#Agents.OSM.map_coordinates"><code>Agents.OSM.map_coordinates</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">OSM.map_coordinates(agent, model::ABM{OpenStreetMapSpace})</code></pre><p>Return a set of coordinates for an agent on the underlying map. Useful for plotting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/openstreetmap.jl#L265-L269">source</a></section></article><h2 id="Local-area"><a class="docs-heading-anchor" href="#Local-area">Local area</a><a id="Local-area-1"></a><a class="docs-heading-anchor-permalink" href="#Local-area" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_ids" href="#Agents.nearby_ids"><code>Agents.nearby_ids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_ids(position, model::ABM, r; kwargs...) → ids</code></pre><p>Return an iterable of the ids of the agents within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which must match type with the spatial structure of the <code>model</code>).</p><p>What the &quot;radius&quot; means depends on the space type:</p><ul><li><code>GraphSpace</code>: the degree of neighbors in the graph (thus <code>r</code> is always an integer). For example, for <code>r=2</code> include first and second degree neighbors.</li><li><code>GridSpace, ContinuousSpace</code>: Either Chebyshev (also called Moore) or Euclidean distance, in the space of cartesian indices.</li><li><code>GridSpace</code> can also take a tuple argument, e.g. <code>r = (5, 2)</code> for a 2D space, which extends 5 positions in the x direction and 2 in the y. Only possible with Chebyshev spaces.</li><li><code>OpenStreetMapSpace</code>: <code>r</code> is equivalent with distance (in meters) neeeded to be travelled according to existing roads in order to reach given <code>position</code>.</li></ul><p><strong>Keywords</strong></p><p>Keyword arguments are space-specific. For <code>GraphSpace</code> the keyword <code>neighbor_type=:default</code> can be used to select differing neighbors depending on the underlying graph directionality type.</p><ul><li><code>:default</code> returns neighbors of a vertex (position). If graph is directed, this is equivalent to <code>:out</code>. For undirected graphs, all options are equivalent to <code>:out</code>.</li><li><code>:all</code> returns both <code>:in</code> and <code>:out</code> neighbors.</li><li><code>:in</code> returns incoming vertex neighbors.</li><li><code>:out</code> returns outgoing vertex neighbors.</li></ul><p>For <code>ContinuousSpace</code>, the keyword <code>exact=false</code> controls whether the found neighbors are exactly accurate or approximate (with approximate always being a strict over-estimation), see <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L69-L99">source</a></section><section><div><pre><code class="nohighlight">nearby_ids(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_ids(agent.pos, model, r)</code> but the iterable <em>excludes</em> the given <code>agent</code>&#39;s id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L303-L308">source</a></section><section><div><pre><code class="nohighlight">nearby_ids(pos, model::ABM{&lt;:GridSpace}, r::Vector{Tuple{Int,UnitRange{Int}}})</code></pre><p>Return an iterable of ids over specified dimensions of <code>space</code> with fine grained control of distances from <code>pos</code> using each value of <code>r</code> via the (dimension, range) pattern.</p><p><strong>Note:</strong> Only available for use with non-periodic chebyshev grids.</p><p>Example, with a <code>GridSpace((100, 100, 10))</code>: <code>r = [(1, -1:1), (3, 1:2)]</code> searches dimension 1 one step either side of the current position (as well as the current position) and the third dimension searches two positions above current.</p><p>For a complete tutorial on how to use this method, see <a href="../examples/battle/#Battle-Royale">Battle Royale</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/grid.jl#L223-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_agents" href="#Agents.nearby_agents"><code>Agents.nearby_agents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_agents(agent, model::ABM, args...; kwargs...) -&gt; agent</code></pre><p>Return an iterable of the agents near the position of the given <code>agent</code>.</p><p>The value of the argument <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L333-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearby_positions" href="#Agents.nearby_positions"><code>Agents.nearby_positions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearby_positions(position, model::ABM, r=1; kwargs...) → positions</code></pre><p>Return an iterable of all positions within &quot;radius&quot; <code>r</code> of the given <code>position</code> (which excludes given <code>position</code>). The <code>position</code> must match type with the spatial structure of the <code>model</code>.</p><p>The value of <code>r</code> and possible keywords operate identically to <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>.</p><p>This function only makes sense for discrete spaces with a finite amount of positions.</p><pre><code class="nohighlight">nearby_positions(position, model::ABM{&lt;:OpenStreetMapSpace}; kwargs...) → positions</code></pre><p>For <a href="#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a> this means &quot;nearby intersections&quot; and operates directly on the underlying graph of the OSM, providing the intersection nodes nearest to the given position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L102-L118">source</a></section><section><div><pre><code class="nohighlight">nearby_positions(agent::AbstractAgent, model::ABM, r=1)</code></pre><p>Same as <code>nearby_positions(agent.pos, model, r)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/space_interaction_API.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.edistance" href="#Agents.edistance"><code>Agents.edistance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">edistance(a, b, model::ABM)</code></pre><p>Return the euclidean distance between <code>a</code> and <code>b</code> (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently <code>GridSpace</code> and <code>ContinuousSpace</code>.</p><p>Example usage in the <a href="../examples/flock/#Flock-model">Flock model</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/spaces/utilities.jl#L7-L15">source</a></section></article><h2 id="A-note-on-iteration"><a class="docs-heading-anchor" href="#A-note-on-iteration">A note on iteration</a><a id="A-note-on-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#A-note-on-iteration" title="Permalink"></a></h2><p>Most iteration in Agents.jl is <strong>dynamic</strong> and <strong>lazy</strong>, when possible, for performance reasons.</p><p><strong>Dynamic</strong> means that when iterating over the result of e.g. the <a href="#Agents.ids_in_position"><code>ids_in_position</code></a> function, the iterator will be affected by actions that would alter its contents. Specifically, imagine the scenario</p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::NTuple{4, Int}
end

model = ABM(Agent, GridSpace((5, 5, 5, 5)))
add_agent!((1, 1, 1, 1), model)
add_agent!((1, 1, 1, 1), model)
add_agent!((2, 1, 1, 1), model)
for id in ids_in_position((1, 1, 1, 1), model)
    kill_agent!(id, model)
end
collect(allids(model))</code></pre><pre class="documenter-example-output">2-element Vector{Int64}:
 2
 3</pre><p>You will notice that only 1 agent got killed. This is simply because the final state of the iteration of <code>ids_in_position</code> was reached unnaturally, because the length of its output was reduced by 1 <em>during</em> iteration. To avoid problems like these, you need to <code>collect</code> the iterator to have a non dynamic version.</p><p><strong>Lazy</strong> means that when possible the outputs of the iteration are not collected and instead are generated on the fly. A good example to illustrate this is <a href="#Agents.nearby_ids"><code>nearby_ids</code></a>, where doing something like</p><pre><code class="language-julia">a = random_agent(model)
sort!(nearby_ids(random_agent(model), model))</code></pre><p>leads to error, since you cannot <code>sort!</code> the returned iterator. This can be easily solved by adding a <code>collect</code> in between:</p><pre><code class="language-julia">a = random_agent(model)
sort!(collect(nearby_agents(a, model)))</code></pre><pre class="documenter-example-output">1-element Vector{Main.__atexample__named__docs.Agent}:
 Main.__atexample__named__docs.Agent(3, (2, 1, 1, 1))</pre><h2 id="Higher-order-interactions"><a class="docs-heading-anchor" href="#Higher-order-interactions">Higher-order interactions</a><a id="Higher-order-interactions-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-order-interactions" title="Permalink"></a></h2><p>There may be times when pair-wise, triplet-wise or higher interactions need to be accounted for across most or all of the model&#39;s agent population. The following methods provide an interface for such calculation.</p><p>These methods follow the conventions outlined above in <a href="#A-note-on-iteration">A note on iteration</a>.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.iter_agent_groups" href="#Agents.iter_agent_groups"><code>Agents.iter_agent_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iter_agent_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)</code></pre><p>Return an iterator over all agents of the model, grouped by order. When <code>order = 2</code>, the iterator returns agent pairs, e.g <code>(agent1, agent2)</code> and when <code>order = 3</code>: agent triples, e.g. <code>(agent1, agent7, agent8)</code>. <code>order</code> must be larger than <code>1</code> but has no upper bound.</p><p>Index order is provided by the <a href="#Agents.Schedulers.by_id"><code>Schedulers.by_id</code></a> scheduler by default, but can be altered with the <code>scheduler</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L237-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.map_agent_groups" href="#Agents.map_agent_groups"><code>Agents.map_agent_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_agent_groups(order::Int, f::Function, model::ABM; kwargs...)
map_agent_groups(order::Int, f::Function, model::ABM, filter::Function; kwargs...)</code></pre><p>Applies function <code>f</code> to all grouped agents of an <a href="#Agents.iter_agent_groups"><code>iter_agent_groups</code></a> iterator. <code>kwargs</code> are passed to the iterator method. <code>f</code> must take the form <code>f(NTuple{O,AgentType})</code>, where the dimension <code>O</code> is equal to <code>order</code>.</p><p>Optionally, a <code>filter</code> function that accepts an iterable and returns a <code>Bool</code> can be applied to remove unwanted matches from the results. <strong>Note:</strong> This option cannot keep matrix order, so should be used in conjuction with <a href="#Agents.index_mapped_groups"><code>index_mapped_groups</code></a> to associate agent ids with the resultant data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L250-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.index_mapped_groups" href="#Agents.index_mapped_groups"><code>Agents.index_mapped_groups</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index_mapped_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)
index_mapped_groups(order::Int, model::ABM, filter::Function; scheduler = Schedulers.by_id)</code></pre><p>Return an iterable of agent ids in the model, meeting the <code>filter</code> criterea if used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L269-L273">source</a></section></article><h2 id="Parameter-scanning"><a class="docs-heading-anchor" href="#Parameter-scanning">Parameter scanning</a><a id="Parameter-scanning-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-scanning" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.paramscan" href="#Agents.paramscan"><code>Agents.paramscan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">paramscan(parameters, initialize; kwargs...) → adf, mdf</code></pre><p>Perform a parameter scan of a ABM simulation output by collecting data from all parameter combinations into dataframes (one for agent data, one for model data). The dataframes columns are both the collected data (as in <a href="../tutorial/#Agents.run!"><code>run!</code></a>) but also the input parameter values used.</p><p><code>parameters</code> is a dictionary with key type <code>Symbol</code> which contains various parameters that will be scanned over (as well as other parameters that remain constant). This function uses <code>DrWatson</code>&#39;s <a href="https://juliadynamics.github.io/DrWatson.jl/dev/run&amp;list/#DrWatson.dict_list"><code>dict_list</code></a> convention. This means that every entry of <code>parameters</code> that is a <code>Vector</code> contains many parameters and thus is scanned. All other entries of <code>parameters</code> that are not <code>Vector</code>s are not expanded in the scan.</p><p>The second argument <code>initialize</code> is a function that creates an ABM and returns it. It must accept keyword arguments which are the <em>keys</em> of the <code>parameters</code> dictionary. Since the user decides how to use input arguments to make an ABM, <code>parameters</code> can be used to affect model properties, space type and creation as well as agent properties, see the example below.</p><p><strong>Keywords</strong></p><p>The following keywords modify the <code>paramscan</code> function:</p><ul><li><code>include_constants::Bool = false</code>: by default, only the varying parameters (Vector in <code>parameters</code>) will be included in the output <code>DataFrame</code>. If <code>true</code>, constant parameters (non-Vector in <code>parameteres</code>) will also be included.</li><li><code>parallel::Bool = false</code> whether <code>Distributed.pmap</code> is invoked to run simulations in parallel. This must be used in conjunction with <code>@everywhere</code> (see <a href="../performance_tips/#Performance-Tips">Performance Tips</a>).</li></ul><p>All other keywords are propagated into <a href="../tutorial/#Agents.run!"><code>run!</code></a>. Furthermore, <code>agent_step!, model_step!, n</code> are also keywords here, that are given to <a href="../tutorial/#Agents.run!"><code>run!</code></a> as arguments. Naturally, <code>agent_step!, model_step!, n</code> and at least one of <code>adata, mdata</code> are mandatory. The <code>adata, mdata</code> lists shouldn&#39;t contain the parameters that are already in the <code>parameters</code> dictionary to avoid duplication.</p><p><strong>Example</strong></p><p>A runnable example that uses <code>paramscan</code> is shown in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>. There, we define</p><pre><code class="language-julia">function initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)
    space = GridSpace(griddims, moore = true)
    properties = Dict(:min_to_be_happy =&gt; min_to_be_happy)
    model = ABM(SchellingAgent, space;
                properties = properties, scheduler = Schedulers.randomly)
    for n in 1:numagents
        agent = SchellingAgent(n, (1, 1), false, n &lt; numagents / 2 ? 1 : 2)
        add_agent_single!(agent, model)
    end
    return model
end</code></pre><p>and do a parameter scan by doing:</p><pre><code class="language-julia">happyperc(moods) = count(moods) / length(moods)
adata = [(:mood, happyperc)]

parameters = Dict(
    :min_to_be_happy =&gt; collect(2:5), # expanded
    :numagents =&gt; [200, 300],         # expanded
    :griddims =&gt; (20, 20),            # not Vector = not expanded
)

adf, _ = paramscan(parameters, initialize; adata, agent_step!, n = 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/paramscan.jl#L3-L70">source</a></section></article><h2 id="Data-collection"><a class="docs-heading-anchor" href="#Data-collection">Data collection</a><a id="Data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection" title="Permalink"></a></h2><p>The central simulation function is <a href="../tutorial/#Agents.run!"><code>run!</code></a>, which is mentioned in our <a href="../tutorial/#Tutorial">Tutorial</a>. But there are other functions that are related to simulations listed here. Specifically, these functions aid in making custom data collection loops, instead of using the <code>run!</code> function.</p><p>For example, the core loop of <code>run!</code> is just</p><pre><code class="language-julia">df_agent = init_agent_dataframe(model, adata)
df_model = init_model_dataframe(model, mdata)

s = 0
while until(s, n, model)
  if should_we_collect(s, model, when)
      collect_agent_data!(df_agent, model, adata, s)
  end
  if should_we_collect(s, model, when_model)
      collect_model_data!(df_model, model, mdata, s)
  end
  step!(model, agent_step!, model_step!, 1)
  s += 1
end
return df_agent, df_model</code></pre><p>(here <code>until</code> and <code>should_we_collect</code> are internal functions)</p><p><code>run!</code> uses the following functions:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.init_agent_dataframe" href="#Agents.init_agent_dataframe"><code>Agents.init_agent_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_agent_dataframe(model, adata) → agent_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/collect.jl#L167-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_agent_data!" href="#Agents.collect_agent_data!"><code>Agents.collect_agent_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_agent_data!(df, model, properties, step = 0; obtainer = identity)</code></pre><p>Collect and add agent data into <code>df</code> (see <a href="../tutorial/#Agents.run!"><code>run!</code></a> for the dispatch rules of <code>properties</code> and <code>obtainer</code>). <code>step</code> is given because the step number information is not known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/collect.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.init_model_dataframe" href="#Agents.init_model_dataframe"><code>Agents.init_model_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_model_dataframe(model, mdata) → model_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_model_data!"><code>collect_model_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/collect.jl#L393-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_model_data!" href="#Agents.collect_model_data!"><code>Agents.collect_model_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_model_data!(df, model, properties, step = 0, obtainer = identity)</code></pre><p>Same as <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a> but for model data instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/collect.jl#L420-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.dataname" href="#Agents.dataname"><code>Agents.dataname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dataname(k) → name</code></pre><p>Return the name of the column of the <code>i</code>-th collected data where <code>k = adata[i]</code> (or <code>mdata[i]</code>). <code>dataname</code> also accepts tuples with aggregate and conditional values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/collect.jl#L352-L358">source</a></section></article><h2 id="Schedulers"><a class="docs-heading-anchor" href="#Schedulers">Schedulers</a><a id="Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Schedulers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers" href="#Agents.Schedulers"><code>Agents.Schedulers</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Schedulers</code></pre><p>Submodule containing all predefined schedulers of Agents.jl and the scheduling API. Schedulers have a very simple interface. They are functions that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a &quot;true&quot; iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. You can also use the function <code>schedule(model)</code> to obtain the scheduled ID list, if you prefer to write your own <code>step!</code>-like loop.</p><p>See also <a href="#Advanced-scheduling">Advanced scheduling</a> for making more advanced schedulers.</p><p>Notice that schedulers can be given directly to model creation, and thus become the &quot;default&quot; scheduler a model uses, but they can just as easily be incorporated in a <code>model_step!</code> function as shown in <a href="../tutorial/#Advanced-stepping">Advanced stepping</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L10-L25">source</a></section></article><h3 id="Predefined-schedulers"><a class="docs-heading-anchor" href="#Predefined-schedulers">Predefined schedulers</a><a id="Predefined-schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-schedulers" title="Permalink"></a></h3><p>Some useful schedulers are available below as part of the Agents.jl API:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.fastest" href="#Agents.Schedulers.fastest"><code>Agents.Schedulers.fastest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.fastest</code></pre><p>A scheduler that activates all agents once per step in the order dictated by the agent&#39;s container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L35-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.by_id" href="#Agents.Schedulers.by_id"><code>Agents.Schedulers.by_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.by_id</code></pre><p>A scheduler that activates all agents agents at each step according to their id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L43-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.randomly" href="#Agents.Schedulers.randomly"><code>Agents.Schedulers.randomly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.randomly</code></pre><p>A scheduler that activates all agents once per step in a random order. Different random ordering is used at each different step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.partially" href="#Agents.Schedulers.partially"><code>Agents.Schedulers.partially</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.partially(p)</code></pre><p>A scheduler that at each step activates only <code>p</code> percentage of randomly chosen agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L61-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.by_property" href="#Agents.Schedulers.by_property"><code>Agents.Schedulers.by_property</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.by_property(property)</code></pre><p>A scheduler that at each step activates the agents in an order dictated by their <code>property</code>, with agents with greater <code>property</code> acting first. <code>property</code> can be a <code>Symbol</code>, which just dictates which field of the agents to compare, or a function which inputs an agent and outputs a real number.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L74-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Schedulers.by_type" href="#Agents.Schedulers.by_type"><code>Agents.Schedulers.by_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Schedulers.by_type(shuffle_types::Bool, shuffle_agents::Bool)</code></pre><p>A scheduler useful only for mixed agent models using <code>Union</code> types.</p><ul><li>Setting <code>shuffle_types = true</code> groups by agent type, but randomizes the type order.</li></ul><p>Otherwise returns agents grouped in order of appearance in the <code>Union</code>.</p><ul><li><code>shuffle_agents = true</code> randomizes the order of agents within each group, <code>false</code> returns</li></ul><p>the default order of the container (equivalent to <a href="#Agents.Schedulers.fastest"><code>Schedulers.fastest</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L91-L98">source</a></section><section><div><pre><code class="nohighlight">Schedulers.by_type((C, B, A), shuffle_agents::Bool)</code></pre><p>A scheduler that activates agents by type in specified order (since <code>Union</code>s are not order preserving). <code>shuffle_agents = true</code> randomizes the order of agents within each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/schedulers.jl#L113-L117">source</a></section></article><h3 id="Advanced-scheduling"><a class="docs-heading-anchor" href="#Advanced-scheduling">Advanced scheduling</a><a id="Advanced-scheduling-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-scheduling" title="Permalink"></a></h3><p>You can use <a href="https://docs.julialang.org/en/v1.5/manual/methods/#Function-like-objects">Function-like-objects</a> to make your scheduling possible of arbitrary events. For example, imagine that after the <code>n</code>-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define</p><pre><code class="language-julia">mutable struct MyScheduler
    n::Int # step number
    w::Float64
end</code></pre><p>and then define a calling method for it like so</p><pre><code class="language-julia">function (ms::MyScheduler)(model::ABM)
    ms.n += 1 # increment internal counter by 1 each time its called
              # be careful to use a *new* instance of this scheduler when plotting!
    if ms.n &lt; 10
        return allids(model) # order doesn&#39;t matter in this case
    else
        ids = collect(allids(model))
        # filter all ids whose agents have `w` less than some amount
        filter!(id -&gt; model[id].w &lt; ms.w, ids)
        return ids
    end
end</code></pre><p>and pass it to e.g. <code>step!</code> by initializing it</p><pre><code class="language-julia">ms = MyScheduler(100, 0.5)
step!(model, agentstep, modelstep, 100; scheduler = ms)</code></pre><h2 id="Ensemble-runs-and-Parallelization"><a class="docs-heading-anchor" href="#Ensemble-runs-and-Parallelization">Ensemble runs and Parallelization</a><a id="Ensemble-runs-and-Parallelization-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-runs-and-Parallelization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.ensemblerun!" href="#Agents.ensemblerun!"><code>Agents.ensemblerun!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ensemblerun!(models::Vector, agent_step!, model_step!, n; kwargs...)</code></pre><p>Perform an ensemble simulation of <a href="../tutorial/#Agents.run!"><code>run!</code></a> for all <code>model ∈ models</code>. Each <code>model</code> should be a (different) instance of an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> but probably initialized with a different random seed or different initial agent distribution. All models obey the same rules <code>agent_step!, model_step!</code> and are evolved for <code>n</code>.</p><p>Similarly to <a href="../tutorial/#Agents.run!"><code>run!</code></a> this function will collect data. It will furthermore add one additional column to the dataframe called <code>:ensemble</code>, which has an integer value counting the ensemble member. The function returns <code>agent_df, model_df, models</code>.</p><p>The keyword <code>parallel = false</code>, when <code>true</code>, will run the simulations in parallel using Julia&#39;s <code>Distributed.pmap</code> (you need to have loaded <code>Agents</code> with <code>@everywhere</code>, see docs online).</p><p>All other keywords are propagated to <a href="../tutorial/#Agents.run!"><code>run!</code></a> as-is.</p><p>Example usage in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>.</p><p>If you want to scan parameters and at the same time run multiple simulations at each parameter combination, simply use <code>seed</code> as a parameter, and use that parameter to tune the model&#39;s initial random seed and agent distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/ensemblerun.jl#L4-L26">source</a></section><section><div><pre><code class="nohighlight">ensemblerun!(generator, agent_step!, model_step!, n; kwargs...)</code></pre><p>Generate many <code>ABM</code>s and propagate them into <code>ensemblerun!(models, ...)</code> using the provided <code>generator</code> which is a one-argument function whose input is a seed.</p><p>This method has additional keywords <code>ensemble = 5, seeds = rand(UInt32, ensemble)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/ensemblerun.jl#L42-L48">source</a></section></article><h3 id="How-to-use-Distributed"><a class="docs-heading-anchor" href="#How-to-use-Distributed">How to use <code>Distributed</code></a><a id="How-to-use-Distributed-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-Distributed" title="Permalink"></a></h3><p>To use the <code>parallel=true</code> option of <a href="#Agents.ensemblerun!"><code>ensemblerun!</code></a> you need to load <code>Agents</code> and define your fundamental types at all processors. How to do this is shown in <a href="../examples/schelling/#Ensembles-and-distributed-computing">Ensembles and distributed computing</a> section of Schelling&#39;s Segregation Model example. See also the <a href="../performance_tips/#Performance-Tips">Performance Tips</a> page for parallelization.</p><h2 id="Path-finding"><a class="docs-heading-anchor" href="#Path-finding">Path-finding</a><a id="Path-finding-1"></a><a class="docs-heading-anchor-permalink" href="#Path-finding" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding" href="#Agents.Pathfinding"><code>Agents.Pathfinding</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Pathfinding</code></pre><p>Submodule containing functionality for path-finding based on the A* algorithm. Currently available only for <a href="#Agents.GridSpace"><code>GridSpace</code></a>.</p><p>You can enable path-finding and set it&#39;s options by passing an instance of a <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a> struct to the <code>pathfinder</code> parameter of the <a href="#Agents.GridSpace"><code>GridSpace</code></a> constructor. During the simulation, call <a href="#Agents.Pathfinding.set_target!"><code>Pathfinding.set_target!</code></a> to set the target destination for an agent. This triggers the algorithm to calculate a path from the agent&#39;s current position to the one specified. You can alternatively use <a href="#Agents.Pathfinding.set_best_target!"><code>Pathfinding.set_best_target!</code></a> to choose the best target from a list. Once a target has been set, you can move an agent one step along its precalculated path using the <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> function.</p><p>Refer to the <a href="../examples/maze/#Maze-Solver">Maze Solver</a> and <a href="../examples/runners/#Mountain-Runners">Mountain Runners</a> examples using path-finding and see the available functions below as well.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/all_pathfinders.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.Pathfinder" href="#Agents.Pathfinding.Pathfinder"><code>Agents.Pathfinding.Pathfinder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.Pathfinder(; kwargs...)</code></pre><p>Enable pathfinding using the A* algorithm by passing an instance of <code>Pathfinder</code> into <a href="#Agents.GridSpace"><code>GridSpace</code></a>. Pathfinding works by using the functions <a href="#Agents.Pathfinding.set_target!"><code>Pathfinding.set_target!</code></a> and <a href="#Agents.move_along_route!"><code>move_along_route!</code></a> see <a href="#Agents.Pathfinding"><code>Pathfinding</code></a> for more.</p><p><strong>Keywords</strong></p><ul><li><code>diagonal_movement = true</code> states that agents are allowed to move diagonally.   Otherwise, only orthogonal directions are possible.</li><li><code>admissibility = 0</code> allows the algorithm to approximate paths to speed up pathfinding   significantly. A value of <code>admissibility</code> allows paths at most <code>(1+admissibility)</code> times   the optimal path length.</li><li><code>walkable = nothing</code> specifies (un)walkable regions of the space. If specified, it should   be a <code>BitArray</code> array of the same size as the corresponding <a href="#Agents.GridSpace"><code>GridSpace</code></a>. This defaults   to <code>nothing</code>, which allows agents to walk on any position in the space. An example usage can   be found in <a href="../examples/maze/#Maze-Solver">Maze Solver</a>.</li><li><code>cost_metric</code> is an instance of a cost metric and specifies the method   to use for approximating the distance between two points. This defaults   to <a href="#Agents.Pathfinding.DirectDistance"><code>Pathfinding.DirectDistance</code></a> with appropriate dimensionality.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/grid_pathfinder.jl#L15-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.set_target!" href="#Agents.Pathfinding.set_target!"><code>Agents.Pathfinding.set_target!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.set_target!(agent, target::NTuple{D,Int}, model)</code></pre><p>Calculate and store the shortest path to move the agent from its current position to <code>target</code> (a grid position e.g. <code>(1, 5)</code>) for models using <a href="#Agents.Pathfinding"><code>Pathfinding</code></a>.</p><p>Use this method in conjuction with <a href="#Agents.move_along_route!"><code>move_along_route!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/grid_pathfinder.jl#L289-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.set_best_target!" href="#Agents.Pathfinding.set_best_target!"><code>Agents.Pathfinding.set_best_target!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.set_best_target!(agent, targets::Vector{NTuple{D,Int}}, model)</code></pre><p>Calculate and store the best path to move the agent from its current position to a chosen target position taken from <code>targets</code> for models using <a href="#Agents.Pathfinding"><code>Pathfinding</code></a>.</p><p>The <code>condition = :shortest</code> keyword retuns the shortest path which is shortest (allowing for the conditions of the models pathfinder) out of the possible target positions. Alternatively, the <code>:longest</code> path may also be requested.</p><p>Returns the position of the chosen target.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/grid_pathfinder.jl#L305-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.walkmap" href="#Agents.Pathfinding.walkmap"><code>Agents.Pathfinding.walkmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.walkmap(model)</code></pre><p>Return the walkable map of a <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a>.</p><p>It is possible to mutate the map directly, for example <code>Pathfinding.walkmap(model)[15, 40] = false</code>. If this is mutated, a new path needs to be planned using <a href="#Agents.Pathfinding.set_target!"><code>Pathfinding.set_target!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/grid_pathfinder.jl#L365-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.heightmap" href="#Agents.Pathfinding.heightmap"><code>Agents.Pathfinding.heightmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Pathfinding.heightmap(model)</code></pre><p>Return the heightmap of a <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a> if the <a href="#Agents.Pathfinding.HeightMap"><code>Pathfinding.HeightMap</code></a> metric is in use, <code>nothing</code> otherwise.</p><p>It is possible to mutate the map directly, for example <code>Pathfinding.heightmap(model)[15, 40] = 115</code> or <code>Pathfinding.heightmap(model) .= rand(50, 50)</code>. If this is mutated, a new path needs to be planned using <a href="#Agents.Pathfinding.set_target!"><code>Pathfinding.set_target!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/grid_pathfinder.jl#L347-L356">source</a></section></article><h3 id="Metrics"><a class="docs-heading-anchor" href="#Metrics">Metrics</a><a id="Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.DirectDistance" href="#Agents.Pathfinding.DirectDistance"><code>Agents.Pathfinding.DirectDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.DirectDistance{D}([direction_costs::Vector{Int}]) &lt;: CostMetric{D}</code></pre><p>Distance is approximated as the shortest path between the two points, provided the <code>walkable</code> property of <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a> allows. Optionally provide a <code>Vector{Int}</code> that represents the cost of going from a tile to the neighboring tile on the <code>i</code> dimensional diagonal (default is <code>10√i</code>).</p><p>If <code>diagonal_movement=false</code> in <a href="#Agents.Pathfinding.Pathfinder"><code>Pathfinding.Pathfinder</code></a>, neighbors in diagonal positions will be excluded. Cost defaults to the first value of the provided vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/metrics.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.MaxDistance" href="#Agents.Pathfinding.MaxDistance"><code>Agents.Pathfinding.MaxDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.MaxDistance{D}() &lt;: CostMetric{D}</code></pre><p>Distance between two tiles is approximated as the maximum of absolute difference in coordinates between them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/metrics.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.Pathfinding.HeightMap" href="#Agents.Pathfinding.HeightMap"><code>Agents.Pathfinding.HeightMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pathfinding.HeightMap(hmap::Array{Int,D} [, base_metric::CostMetric]) &lt;: CostMetric{D}</code></pre><p>Distance between two positions is the sum of the shortest distance between them and the absolute difference in height. A heightmap of the same size as the corresponding <a href="#Agents.GridSpace"><code>GridSpace{D}</code></a> is required. Distance is calculated using <a href="#Agents.Pathfinding.DirectDistance"><code>Pathfinding.DirectDistance</code></a> by default, and can be changed by specifying <code>base_metric</code>. An example usage can be found in <a href="../examples/runners/#Mountain-Runners">Mountain Runners</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/submodules/pathfinding/metrics.jl#L41-L48">source</a></section></article><p>Building a custom metric is straightforward, if the provided ones do not suit your purpose. See the <a href="../devdocs/#Developer-Docs">Developer Docs</a> for details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Predefined Models</a><a class="docs-footer-nextpage" href="../interact/">Plotting and interactive application »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 22:35">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
