<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Agents.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Space"><span>1. The space</span></a></li><li><a class="tocitem" href="#.-The-agent-type"><span>2. The agent type</span></a></li><li><a class="tocitem" href="#.-The-model"><span>3. The model</span></a></li><li><a class="tocitem" href="#.-Evolving-the-model"><span>4. Evolving the model</span></a></li><li><a class="tocitem" href="#.-Collecting-data"><span>5. Collecting data</span></a></li><li><a class="tocitem" href="#Seeding-and-Random-numbers"><span>Seeding and Random numbers</span></a></li><li><a class="tocitem" href="#An-educative-example"><span>An educative example</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/">Overview</a></li><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sugarscape/">Sugarscape</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../examples/predator_prey_fast/">Predator-Prey</a></li><li><a class="tocitem" href="../examples/maze/">Maze Solver</a></li><li><a class="tocitem" href="../examples/runners/">Mountain Runners</a></li><li><a class="tocitem" href="../examples/growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../examples/opinion_spread/">Opinion spread</a></li><li><a class="tocitem" href="../examples/battle/">Battle Royale</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak</a></li><li><a class="tocitem" href="../examples/fractal_growth/">Fractal Growth</a></li></ul></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../interact/">Plotting and interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">LightGraphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>In Agents.jl a central structure maps unique IDs (integers) to agent instances, similar to a dictionary. During the simulation, the model evolves in discrete steps. During one step, the user decides which agents will act, how will they act, how many times, and whether any model-level properties will be adjusted. Once the time evolution is defined, collecting data during time evolution is straightforward by simply stating which data should be collected.</p><p>In the spirit of simple design, all of this is done by defining simple Julia data types, like basic functions, structs and dictionaries.</p><p>To set up an ABM simulation in Agents.jl, a user only needs to follow these steps:</p><ol><li>Choose in what kind of space the agents will live in, for example a graph, a grid, etc. Several spaces are provided by Agents.jl and can be initialized immediately.</li><li>Define the agent type (or types, for mixed models) that will populate the ABM. This is defined as a standard Julia <code>struct</code> and contains two mandatory fields <code>id, pos</code>, with the position field being appropriate for the chosen space.</li><li>The created agent type, the chosen space, and optional additional model level properties (typically in the form of a dictionary) are provided in our universal structure <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. This instance defines the model within an Agents.jl simulation. Further options are also available, regarding schedulers and random number generation.</li><li>Provide functions that govern the time evolution of the ABM. A user can provide an agent-stepping function, that acts on each agent one by one, and/or model-stepping function, that steps the entire model as a whole. These functions are standard Julia functions that take advantage of the Agents.jl <a href="../api/#API">API</a>.</li><li>Collect data. To do this, specify which data should be collected, by providing one standard Julia <code>Vector</code> of data-to-collect for agents, and another one for the model, for example <code>[:mood, :wealth]</code>. The outputted data are in the form of a <code>DataFrame</code>.</li></ol><p>If you&#39;re planning of running massive simulations, it might be worth having a look at the <a href="../performance_tips/#Performance-Tips">Performance Tips</a> after familiarizing yourself with Agents.jl.</p><h2 id="Space"><a class="docs-heading-anchor" href="#Space">1. The space</a><a id="Space-1"></a><a class="docs-heading-anchor-permalink" href="#Space" title="Permalink"></a></h2><p>Agents.jl offers several possibilities for the space the agents live in. In addition, it is straightforward to implement a fundamentally new type of space, see <a href="../devdocs/#Developer-Docs">Developer Docs</a>.</p><p>The available spaces are:</p><ul><li><a href="../api/#Agents.GraphSpace"><code>GraphSpace</code></a>: Agent positions are equivalent with nodes of a graph/network.</li><li><a href="../api/#Agents.GridSpace"><code>GridSpace</code></a>: Space is discretized into boxes, typical style for cellular automata.</li><li><a href="../api/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>: Truthful representation of continuous space, regarding location, orientation, and identification of neighboring agents.</li><li><a href="../api/#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>: A space based on Open Street Map, where agents are confined to move along streets of the map, using real-world meter values for the length of each street.</li></ul><p>One simply initializes an instance of a space, e.g. with <code>grid = GridSpace((10, 10))</code> and passes that into <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. See each individual space for all its possible arguments.</p><h2 id=".-The-agent-type"><a class="docs-heading-anchor" href="#.-The-agent-type">2. The agent type</a><a id=".-The-agent-type-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-agent-type" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">YourAgentType &lt;: AbstractAgent</code></pre><p>Agents participating in Agents.jl simulations are instances of user-defined Types that are subtypes of <code>AbstractAgent</code>. It is almost always the case that mutable Types make for a simpler modelling experience.</p><p>Your agent type(s) <strong>must have</strong> the <code>id</code> field as first field. Depending on the space structure there might be a <code>pos</code> field of appropriate type and a <code>vel</code> field of appropriate type. Each space structure quantifies precicely what extra fields (if any) are necessary, however we recommend to use the <a href="../api/#Agents.@agent"><code>@agent</code></a> macro to help you create the agent type.</p><p>Your agent type may have other additional fields relevant to your system, for example variable quantities like &quot;status&quot; or other &quot;counters&quot;.</p><p>As an example, a <a href="../api/#Agents.GraphSpace"><code>GraphSpace</code></a> requires an <code>id::Int</code> field and a <code>pos::Int</code> field. To make an agent with two additional properties, <code>weight, happy</code>, we&#39;d write</p><pre><code class="language-julia">mutable struct ExampleAgent &lt;: AbstractAgent
    id::Int
    pos::Int
    weight::Float64
    happy::Bool
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/agents.jl#L3-L28">source</a></section></article><p>Once an agent is created it can be added to a model using e.g. <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. Then, the agent can interact with the model and the space further by using e.g. <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> or <a href="../api/#Agents.kill_agent!"><code>kill_agent!</code></a>.</p><p>For more functions visit the <a href="../api/#API">API</a> page.</p><h2 id=".-The-model"><a class="docs-heading-anchor" href="#.-The-model">3. The model</a><a id=".-The-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AgentBasedModel(AgentType [, space]; properties, kwargs...) → model</code></pre><p>Create an agent based model from the given agent type and <code>space</code>. You can provide an agent <em>instance</em> instead of type, and the type will be deduced. <code>ABM</code> is equivalent with <code>AgentBasedModel</code>.</p><p>The agents are stored in a dictionary that maps unique IDs (integers) to agents. Use <code>model[id]</code> to get the agent with the given <code>id</code>.</p><p><code>space</code> is a subtype of <code>AbstractSpace</code>, see <a href="#Space">Space</a> for all available spaces. If it is ommited then all agents are virtually in one position and there is no spatial structure.</p><p><strong>Note:</strong> Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.</p><p><strong>Note:</strong> Agents.jl supports multiple agent types by passing a <code>Union</code> of agent types as <code>AgentType</code>. However, please have a look at <a href="../performance_tips/#Performance-Tips">Performance Tips</a> for potential drawbacks of this approach.</p><p><strong>Keywords</strong></p><p><code>properties = nothing</code> is additional model-level properties (typically a dictionary) that can be accessed as <code>model.properties</code>. If <code>properties</code> is a dictionary with key type <code>Symbol</code>, or of it is a struct, then the syntax <code>model.name</code> is short hand for <code>model.properties[:name]</code> (or <code>model.properties.name</code> for structs). This syntax can&#39;t be used for <code>name</code> being <code>agents, space, scheduler, properties, rng, maxid</code>, which are the fields of <code>AgentBasedModel</code>.</p><p><code>scheduler = Schedulers.fastest</code> decides the order with which agents are activated (see e.g. <a href="../api/#Agents.Schedulers.by_id"><code>Schedulers.by_id</code></a> and the scheduler API). <code>scheduler</code> is only meaningful if an agent-stepping function is defined for <a href="#Agents.step!"><code>step!</code></a> or <a href="#Agents.run!"><code>run!</code></a>, otherwise a user decides a scheduler in the model-stepping function, as illustrated in the <a href="#Advanced-stepping">Advanced stepping</a> part of the tutorial.</p><p><code>rng = Random.default_rng()</code> provides random number generation to the model. Accepts any subtype of <code>AbstractRNG</code> and is accessed by <code>model.rng</code>.</p><p><code>warn=true</code>: Type tests for <code>AgentType</code> are done, and by default warnings are thrown when appropriate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/core/model.jl#L41-L80">source</a></section></article><h2 id=".-Evolving-the-model"><a class="docs-heading-anchor" href="#.-Evolving-the-model">4. Evolving the model</a><a id=".-Evolving-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-Evolving-the-model" title="Permalink"></a></h2><p>Any ABM model should have at least one and at most two step functions. An <em>agent step function</em> is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a <em>model step function</em>.</p><p>An agent step function should only accept two arguments: first, an agent object, and second, a model object.</p><p>The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in <a href="#Agents.dummystep"><code>dummystep</code></a> as the agent step function. This is typically the case for <a href="#Advanced-stepping">Advanced stepping</a>.</p><p>After you have defined these two functions, you evolve your model with <code>step!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.step!" href="#Agents.step!"><code>Agents.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(model, agent_step!, n::Int = 1)
step!(model, agent_step!, model_step!, n::Int = 1, agents_first::Bool = true)</code></pre><p>Update agents <code>n</code> steps according to the stepping function <code>agent_step!</code>. Agents will be activated as specified by the <code>model.scheduler</code>. <code>model_step!</code> is triggered <em>after</em> every scheduled agent has acted, unless the argument <code>agents_first</code> is <code>false</code> (which then first calls <code>model_step!</code> and then activates the agents).</p><p><code>step!</code> ignores scheduled IDs that do not exist within the model, allowing you to safely kill agents dynamically.</p><pre><code class="nohighlight">step!(model, agent_step!, model_step!, n::Function, agents_first::Bool = true)</code></pre><p>In this version <code>n</code> is a function. Then <code>step!</code> runs the model until <code>n(model, s)</code> returns <code>true</code>, where <code>s</code> is the current amount of steps taken, starting from 0. For this method of <code>step!</code>, <code>model_step!</code> must be provided always (use <a href="#Agents.dummystep"><code>dummystep</code></a> if you have no model stepping dynamics).</p><p>See also <a href="#Advanced-stepping">Advanced stepping</a> for stepping complex models where <code>agent_step!</code> might not be convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/step.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.dummystep" href="#Agents.dummystep"><code>Agents.dummystep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dummystep(model)</code></pre><p>Use instead of <code>model_step!</code> in <a href="#Agents.step!"><code>step!</code></a> if no function is useful to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/step.jl#L29-L33">source</a></section><section><div><pre><code class="nohighlight">dummystep(agent, model)</code></pre><p>Use instead of <code>agent_step!</code> in <a href="#Agents.step!"><code>step!</code></a> if no function is useful to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/step.jl#L35-L39">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Current step number</header><div class="admonition-body"><p>Notice that the current step number is not explicitly given to the <code>model_step!</code> function, because this is useful only for a subset of ABMs. If you need the step information, implement this by adding a counting parameter into the model <code>properties</code>, and incrementing it by 1 each time <code>model_step!</code> is called. An example can be seen in the <code>model_step!</code> function of <a href="../examples/daisyworld/#Daisyworld">Daisyworld</a>, where a <code>tick</code> is increased at each step.</p></div></div><h3 id="Advanced-stepping"><a class="docs-heading-anchor" href="#Advanced-stepping">Advanced stepping</a><a id="Advanced-stepping-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-stepping" title="Permalink"></a></h3><p>The interface of <a href="#Agents.step!"><code>step!</code></a>, which allows the option of both <code>agent_step!</code> and <code>model_step!</code> is driven mostly by convenience. In principle, the <code>model_step!</code> function by itself can perform all operations related with stepping the ABM. However, for many models, this simplified approach offers the benefit of not having to write an explicit loop over existing agents inside the <code>model_step!</code>. Most of the examples in our documentation can be expressed using an independent <code>agent_step!</code> and <code>model_step!</code> function.</p><p>On the other hand, more advanced models require special handling for scheduling, or may need to schedule several times and act on different subsets of agents with different functions. In such a scenario, it is more sensible to provide only a <code>model_step!</code> function (and use <code>dummystep</code> as <code>agent_step!</code>), where all configuration is contained within. Notice that if you follow this road, the argument <code>scheduler</code> given to <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> somewhat loses its meaning.</p><p>Here is an example:</p><pre><code class="language-julia">function complex_step!(model)
    for a in scheduler1(model)
        agent_step1!(a, model)
    end
    intermediate_model_action!(model)
    for a in scheduler2(model)
        agent_step2!(a, model)
    end
    final_model_action!(model)
end

step!(model, dummystep, complex_step!, n)</code></pre><p>For defining your own schedulers, see <a href="../api/#Schedulers">Schedulers</a>.</p><h2 id=".-Collecting-data"><a class="docs-heading-anchor" href="#.-Collecting-data">5. Collecting data</a><a id=".-Collecting-data-1"></a><a class="docs-heading-anchor-permalink" href="#.-Collecting-data" title="Permalink"></a></h2><p>Running the model and collecting data while the model runs is done with the <a href="#Agents.run!"><code>run!</code></a> function. Besides <code>run!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection, while scanning ranges of the parameters of the model.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.run!" href="#Agents.run!"><code>Agents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df
run!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df</code></pre><p>Run the model (step it with the input arguments propagated into <a href="#Agents.step!"><code>step!</code></a>) and collect data specified by the keywords, explained one by one below. Return the data as two <code>DataFrame</code>s, one for agent-level data and one for model-level data.</p><p><strong>Data-deciding keywords</strong></p><ul><li><p><code>adata::Vector</code> means &quot;agent data to collect&quot;. If an entry is a <code>Symbol</code>, e.g. <code>:weight</code>, then the data for this entry is agent&#39;s field <code>weight</code>. If an entry is a <code>Function</code>, e.g. <code>f</code>, then the data for this entry is just <code>f(a)</code> for each agent <code>a</code>. The resulting dataframe columns are named with the input symbol (here <code>:weight, :f</code>).</p></li><li><p><code>adata::Vector{&lt;:Tuple}</code>: if <code>adata</code> is a vector of tuples instead, data aggregation is done over the agent properties.</p><p>For each 2-tuple, the first entry is the &quot;key&quot; (any entry like the ones mentioned above, e.g. <code>:weight, f</code>). The second entry is an aggregating function that aggregates the key, e.g. <code>mean, maximum</code>. So, continuing from the above example, we would have <code>adata = [(:weight, mean), (f, maximum)]</code>.</p><p>It&#39;s also possible to provide a 3-tuple, with the third entry being a conditional function (returning a <code>Bool</code>), which assesses if each agent should be included in the aggregate. For example: <code>x_pos(a) = a.pos[1]&gt;5</code> with <code>(:weight, mean, x_pos)</code> will result in the average weight of agents conditional on their x-position being greater than 5.</p><p>The resulting data name columns use the function <a href="../api/#Agents.dataname"><code>dataname</code></a>. They create something like <code>:mean_weight</code> or <code>:maximum_f_x_pos</code>. In addition, you can use anonymous functions in a list comprehension to assign elements of an array into different columns: <code>adata = [(a)-&gt;(a.interesting_array[i]) for i=1:N]</code>. Column names can also be renamed with <code>DataFrames.rename!</code> after data is collected.</p><p><strong>Notice:</strong> Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. <em>E.g.</em> instead of passing <code>mean</code>, pass <code>mymean(a) = isempty(a) ? 0.0 : mean(a)</code>.</p></li><li><p><code>mdata::Vector</code> means &quot;model data to collect&quot; and works exactly like <code>adata</code>. For the model, no aggregation is possible (nothing to aggregate over).</p></li></ul><p>By default both keywords are <code>nothing</code>, i.e. nothing is collected/aggregated.</p><p><strong>Mixed-Models</strong></p><p>For mixed-models, the <code>adata</code> keyword has some additional options &amp; properties.   An additional column <code>agent_type</code> will be placed in the output   dataframe.</p><p>In the case that data is needed for one agent type that does not exist   in a second agent type, <code>missing</code> values will be added to the dataframe.</p><p><strong>Warning:</strong> Since this option is inherently type unstable, try to avoid this   in a performance critical situation.</p><p>Aggregate functions will fail if <code>missing</code> values are not handled explicitly.   If <code>a1.weight</code> but <code>a2</code> (type: Agent2) has no <code>weight</code>, use   <code>a2(a) = a isa Agent2; adata = [(:weight, sum, a2)]</code> to filter out the missing results.</p><p><strong>Other keywords</strong></p><ul><li><code>when=true</code> : at which steps <code>s</code> to perform the data collection and processing. A lot of flexibility is offered based on the type of <code>when</code>. If <code>when::Vector</code>, then data are collect if <code>s ∈ when</code>. Otherwise data are collected if <code>when(model, s)</code> returns <code>true</code>. By default data are collected in every step.</li><li><code>when_model = when</code> : same as <code>when</code> but for model data.</li><li><code>obtainer = identity</code> : method to transfer collected data to the <code>DataFrame</code>. Typically only change this to <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy"><code>copy</code></a> if some data are mutable containers (e.g. <code>Vector</code>) which change during evolution, or <a href="https://docs.julialang.org/en/v1/base/base/#Base.deepcopy"><code>deepcopy</code></a> if some data are nested mutable containers. Both of these options have performance penalties.</li><li><code>agents_first=true</code> : Whether to update agents first and then the model, or vice versa.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/19176adace2c671b7dc273b3321df8ccfde98d8c/src/simulations/collect.jl#L25-L95">source</a></section></article><p>The <a href="#Agents.run!"><code>run!</code></a> function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregating model data, or arbitrary combinations.</p><p>This means that <a href="#Agents.run!"><code>run!</code></a> has not been designed for maximum performance (or minimum memory allocation). However, we also expose a simple data-collection API (see <a href="../api/#Data-collection">Data collection</a>), that gives users even more flexibility, allowing them to make their own &quot;data collection loops&quot; arbitrarily calling <code>step!</code> and collecting data as, and when, needed.</p><p>As your models become more complex, it may not be advantageous to use lots of helper functions in the global scope to assist with data collection. If this is the case in your model, here&#39;s a helpful tip to keep things clean:</p><pre><code class="language-julia">function assets(model)
    total_savings(model) = model.bank_balance + sum(model.assets)
    function stategy(model)
        if model.year == 0
            return model.initial_strategy
        else
            return get_strategy(model)
        end
    end
    return [:age, :details, total_savings, strategy]
end
run!(model, agent_step!, model_step!, 10; mdata = assets(model))</code></pre><h2 id="Seeding-and-Random-numbers"><a class="docs-heading-anchor" href="#Seeding-and-Random-numbers">Seeding and Random numbers</a><a id="Seeding-and-Random-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Seeding-and-Random-numbers" title="Permalink"></a></h2><p>Each model created by <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> provides a random number generator pool <code>model.rng</code> which by default coincides with the global RNG. For performance reasons, one should never use <code>rand()</code> without using a pool, thus throughout our examples we use <code>rand(model.rng)</code> or <code>rand(model.rng, 1:10, 100)</code>, etc.</p><p>Another benefit of this approach is deterministic models that can be ran again and yield the same output. To do this, either always pass a specifically seeded RNG to the model creation, e.g. <code>MersenneTwister(1234)</code>, or call <code>seed!(model, 1234)</code> (with any number) after creating the model but before actually running the simulation.</p><p>Passing <code>RandomDevice()</code> will use the system&#39;s entropy source (coupled with hardware like <a href="https://ubld.it/truerng_v3">TrueRNG</a> will invoke a true random source, rather than pseudo-random methods like <code>MersenneTwister</code>). Models using this method cannot be repeatable, but avoid potential biases of pseudo-randomness.</p><h2 id="An-educative-example"><a class="docs-heading-anchor" href="#An-educative-example">An educative example</a><a id="An-educative-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-educative-example" title="Permalink"></a></h2><p>A simple, education-oriented example of using the basic Agents.jl API is given in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>, also discussing in detail how to visualize your ABMs. For a quick reference concerning the main concepts of agent based modelling, and how the Agents.jl examples implement each one, take a look at the <a href="../examples/#Overview-of-Examples">Overview of Examples</a> page.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 April 2021 22:35">Tuesday 13 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
