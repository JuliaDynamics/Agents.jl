<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><meta name="title" content="Tutorial · Agents.jl"/><meta property="og:title" content="Tutorial · Agents.jl"/><meta property="twitter:title" content="Tutorial · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#tutorial_fast"><span>Tutorial - copy-pasteable  version</span></a></li><li><a class="tocitem" href="#Core-steps-of-an-Agents.jl-simulation"><span>Core steps of an Agents.jl simulation</span></a></li><li><a class="tocitem" href="#The-Schelling-segregation-model-basic-rules"><span>The Schelling segregation model basic rules</span></a></li><li><a class="tocitem" href="#Step-1:-creating-the-space"><span>Step 1: creating the space</span></a></li><li><a class="tocitem" href="#Step-2:-the-@agent-command"><span>Step 2: the <code>@agent</code> command</span></a></li><li><a class="tocitem" href="#Step-2:-creating-the-agent-type"><span>Step 2: creating the agent type</span></a></li><li><a class="tocitem" href="#Step-2:-redefining-agent-types"><span>Step 2: redefining agent types</span></a></li><li><a class="tocitem" href="#Step-3:-form-of-the-evolution-rule(s)-in-discrete-time"><span>Step 3: form of the evolution rule(s) in discrete time</span></a></li><li><a class="tocitem" href="#Step-3:-agent-stepping-function-for-the-Schelling-model"><span>Step 3: agent stepping function for the Schelling model</span></a></li><li><a class="tocitem" href="#Step-4:-the-AgentBasedModel"><span>Step 4: the <code>AgentBasedModel</code></span></a></li><li><a class="tocitem" href="#Step-4:-initializing-the-model"><span>Step 4: initializing the model</span></a></li><li><a class="tocitem" href="#Step-4:-an-(optional)-scheduler"><span>Step 4: an (optional) scheduler</span></a></li><li><a class="tocitem" href="#Step-4:-populating-it-with-agents"><span>Step 4: populating it with agents</span></a></li><li><a class="tocitem" href="#Step-4:-random-number-generator"><span>Step 4: random number generator</span></a></li><li><a class="tocitem" href="#Step-4:-making-the-initialization-a-keyword-based-function"><span>Step 4: making the initialization a keyword-based function</span></a></li><li><a class="tocitem" href="#Step-5:-evolve-the-model"><span>Step 5: evolve the model</span></a></li><li><a class="tocitem" href="#Step-6:-Visualizations"><span>Step 6: Visualizations</span></a></li><li><a class="tocitem" href="#Step-7:-data-collection"><span>Step 7: data collection</span></a></li><li><a class="tocitem" href="#Multiple-agent-types-in-Agents.jl"><span>Multiple agent types in Agents.jl</span></a></li><li><a class="tocitem" href="#Multiple-agent-types-with-Union-types"><span>Multiple agent types with <code>Union</code> types</span></a></li><li><a class="tocitem" href="#Multiple-agent-types-with-@multiagent"><span>Multiple agent types with <code>@multiagent</code></span></a></li><li><a class="tocitem" href="#Adding-agents-of-different-types-to-the-model"><span>Adding agents of different types to the model</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/flock/">Flocking model</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../examples/rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../examples/">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../examples/agents_visualizations/">Plotting and Interactivity</a></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../examples/celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/docs/src/tutorial.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><video width="auto" controls autoplay loop>
<source src="../schelling.mp4" type="video/mp4">
</video><p>This is the main overarching tutorial for Agents.jl. It will walk you through the typical workflow of doing agent based modelling (ABM) using Agents.jl, while introducing and explaining the core components of Agents.jl. The tutorial will utilize the <a href="https://en.wikipedia.org/wiki/Schelling%27s_model_of_segregation">Schelling segregation model</a> as an example to apply the concepts we learn.</p><p>Besides the normal step-by-step educative version of the tutorial, there is also <a href="#tutorial_fast">the fast, shortened, copy-pasteable version</a> right below. We strongly recommend going through the normal tutorial step-by-step though!</p><h2 id="tutorial_fast"><a class="docs-heading-anchor" href="#tutorial_fast">Tutorial - copy-pasteable  version</a><a id="tutorial_fast-1"></a><a class="docs-heading-anchor-permalink" href="#tutorial_fast" title="Permalink"></a></h2><p><em>Gotta go fast!</em></p><pre><code class="language-julia hljs">using Agents # bring package into scope

# make the space the agents will live in
space = GridSpace((20, 20)) # 20×20 grid cells

# make an agent type appropriate to this space and with the
# properties we want based on the ABM we will simulate
@agent struct Schelling(GridAgent{2}) # inherit all properties of `GridAgent{2}`
    mood::Bool = false # all agents are sad by default :&#39;(
    group::Int # the group does not have a default value!
end

# define the evolution rule: a function that acts once per step on
# all activated agents (acts in-place on the given agent)
function schelling_step!(agent, model)
    # Here we access a model-level property `min_to_be_happy`
    # This will have an assigned value once we create the model
    minhappy = model.min_to_be_happy
    count_neighbors_same_group = 0
    # For each neighbor, get group and compare to current agent&#39;s group
    # and increment `count_neighbors_same_group` as appropriately.
    # Here `nearby_agents` (with default arguments) will provide an iterator
    # over the nearby agents one grid cell away, which are at most 8.
    for neighbor in nearby_agents(agent, model)
        if agent.group == neighbor.group
            count_neighbors_same_group += 1
        end
    end
    # After counting the neighbors, decide whether or not to move the agent.
    # If `count_neighbors_same_group` is at least min_to_be_happy, set the
    # mood to true. Otherwise, move the agent to a random position, and set
    # mood to false.
    if count_neighbors_same_group ≥ minhappy
        agent.mood = true
    else
        agent.mood = false
        move_agent_single!(agent, model)
    end
    return
end

# make a container for model-level properties
properties = Dict(:min_to_be_happy =&gt; 3)

# Create the central `AgentBasedModel` that stores all simution information
model = StandardABM(
    Schelling, # type of agents
    space; # space they live in
    agent_step! = schelling_step!, properties
)

# populate the model with agents by automatically creating and adding them
# to random position in the space
for n in 1:300
    add_agent_single!(model; group = n &lt; 300 / 2 ? 1 : 2)
end

# run the model for 5 steps, and collect data.
# The data to collect are given as a vector of tuples: 1st element of tuple is
# what property, or what function of agent -&gt; data, to collect. 2nd element
# is how to aggregate the collected property over all agents in the simulation
using Statistics: mean
xpos(agent) = agent.pos[1]
adata = [(:mood, sum), (xpos, mean)]
adf, mdf = run!(model, 5; adata)
adf # a Julia `DataFrame`</code></pre><div><div style = "float: left;"><span>6×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">step</th><th style = "text-align: left;">sum_mood</th><th style = "text-align: left;">mean_xpos</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">0</td><td style = "text-align: right;">0</td><td style = "text-align: right;">10.3933</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">1</td><td style = "text-align: right;">209</td><td style = "text-align: right;">10.2767</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">2</td><td style = "text-align: right;">246</td><td style = "text-align: right;">10.71</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">3</td><td style = "text-align: right;">258</td><td style = "text-align: right;">10.5233</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">4</td><td style = "text-align: right;">276</td><td style = "text-align: right;">10.53</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">5</td><td style = "text-align: right;">284</td><td style = "text-align: right;">10.7</td></tr></tbody></table></div><h2 id="Core-steps-of-an-Agents.jl-simulation"><a class="docs-heading-anchor" href="#Core-steps-of-an-Agents.jl-simulation">Core steps of an Agents.jl simulation</a><a id="Core-steps-of-an-Agents.jl-simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Core-steps-of-an-Agents.jl-simulation" title="Permalink"></a></h2><p>In Agents.jl a central abstract structure called <code>AgentBasedModel</code> contains all information necessary to run a simulation: the evolution rule (also called dynamic rule), the agents of the simulation, the space the agents move and interact in, and other model-level properties relevant to the simulation.</p><p>An Agents.jl simulation is composed of first building such an <code>AgentBasedModel</code> (steps 1-4 below) and then evolving it and/or analyzing it (steps 5-7 below):</p><ol><li>Choose what <strong>kind of space</strong> the agents will live in, for example a graph, a grid, etc. Several spaces are provided by Agents.jl and can be initialized immediately.</li><li>Define the <strong>agent type(s)</strong> that will populate the ABM. Agent types are Julia <code>mutable struct</code>s that are created with <a href="../api/#Agents.@agent"><code>@agent</code></a>. The types must contain some mandatory fields, which is ensured by using <a href="../api/#Agents.@agent"><code>@agent</code></a>. The remaining fields of the agent type are up to the user&#39;s choice.</li><li>Define the <strong>evolution rule(s)</strong>, i.e., how the model evolves in time. The evolution rule(s) are always standard Julia functions that take advantage of the Agents.jl <a href="../api/#API">API</a>. The exact way one defines the evolution rules depends on the type of <code>AgentBasedModel</code> used. Agents.jl allows simulations in both discrete time via <a href="../api/#Agents.StandardABM"><code>StandardABM</code></a> as well as continuous time via <a href="../api/#Agents.EventQueueABM"><code>EventQueueABM</code></a>. In this tutorial we will learn the discrete-time version. See the <a href="@ref eventbased_tutorial">rock-paper-scissors</a> example for an introduction to the continuous time version.</li><li>Initialize an <strong><code>AgentBasedModel</code> instance</strong> that contains the agent type(s), the chosen space, the evolution rule(s), other optional additional model-level properties, and other simulation tuning properties like schedulers or random number generators. Then, populate this model with agent instances.</li><li><em>(Trivial)</em> <strong>evolve the model</strong> forwards in time.</li><li><em>(Optional)</em> <strong>Visualize the model</strong> and animate its time evolution. This can help checking that the model behaves as expected and there aren&#39;t any mistakes, or can be used in making figures for a paper/presentation.</li><li><strong>Collect data</strong>. To do this, specify which data should be collected, by providing one standard Julia <code>Vector</code> of data-to-collect for agents, for example <code>[:mood, :wealth]</code>, and another one for the model. The agent data names are given as the keyword <code>adata</code> and the model as keyword <code>mdata</code> to the function <a href="../api/#Agents.run!"><code>run!</code></a>. This function outputs collected data in the form of a <code>DataFrame</code>.</li></ol><p>In the spirit of simple design, all of these steps are done by defining simple Julia data structures, like vectors, dictionaries, functions, or structs. This means that using Agents.jl comes with <em>transferrable</em> knowledge to the whole Julia ecosystem. Indeed, looking at the &quot;Integration examples&quot; (see sidebar of online docs) Agents.jl can be readily used with any other Julia package, exactly because its design is based on existing, and widely established, Julia language concepts.</p><h2 id="The-Schelling-segregation-model-basic-rules"><a class="docs-heading-anchor" href="#The-Schelling-segregation-model-basic-rules">The Schelling segregation model basic rules</a><a id="The-Schelling-segregation-model-basic-rules-1"></a><a class="docs-heading-anchor-permalink" href="#The-Schelling-segregation-model-basic-rules" title="Permalink"></a></h2><ul><li>A fixed pre-determined number of agents exist in the model.</li><li>Agents belong to one of two groups (1 or 2).</li><li>The agents live in a two-dimensional non-periodic grid.</li><li>Only one agent per position is allowed.</li><li>At each state of the simulation, each agent looks at its 8 neighboring positions (cardinal and diagonal directions). It then counts how many neighboring agents belong to the same group (if any). This leads to 8 neighboring positions per position (except at the edges of the grid).</li><li>If an agent has at least <code>min_to_be_happy</code> neighbors belonging to the same group, then it becomes happy.</li><li>Else, the agent is unhappy and moves to a new random location in space while respecting the 1-agent-per-position rule.</li></ul><p>In the following we will build this model following the aforementioned steps. The 0-th step of any Agents.jl simulation is to bring the package into scope:</p><pre><code class="language-julia hljs">using Agents</code></pre><h2 id="Step-1:-creating-the-space"><a class="docs-heading-anchor" href="#Step-1:-creating-the-space">Step 1: creating the space</a><a id="Step-1:-creating-the-space-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-creating-the-space" title="Permalink"></a></h2><p>Agents.jl offers multiple spaces one can utilize to perform simulations, all of which are listed in the <a href="@ref available_spaces">available spaces section</a>. If we go through the list, we quickly realize that the space we need to use here is <a href="../api/#Agents.GridSpaceSingle"><code>GridSpaceSingle</code></a> which is a grid that allows only one agent per position. So, we can go ahead and create an instance of this type. We need to specify the total size of the grid, and also that the distance metric should be the Chebyshev one, which means that diagonal and orthogonal directions quantify as the same distance away. We also specify that the space should <em>not</em> be periodic.</p><pre><code class="language-julia hljs">size = (10, 10)
space = GridSpaceSingle(size; periodic = false, metric = :chebyshev)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false</code></pre><h2 id="Step-2:-the-@agent-command"><a class="docs-heading-anchor" href="#Step-2:-the-@agent-command">Step 2: the <code>@agent</code> command</a><a id="Step-2:-the-@agent-command-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-the-@agent-command" title="Permalink"></a></h2><p>Agents in Agents.jl are instances of user-defined <code>struct</code>s that subtype <code>AbstractAgent</code>. This means that agents are data containers that contain some particular data fields that are necessary to perform simulations with Agents.jl, as well as any other data field that the user requires. If an agent instance <code>agent</code> exists in the simulation then the data field named &quot;weight&quot; is obtained from the agent using <code>agent.weight</code>. This is standard Julia syntax to access the data field named &quot;weight&quot; for any data structure that contains such a field.</p><p>To create agent types, and define what properties they should have, it is strongly recommended to use the <a href="../api/#Agents.@agent"><code>@agent</code></a> command. You can read its documentation in detail if you wish to understand it deeply. But the long story made sort is that this command ensures that agents have the minimum amount of required necessary properties to function within a given space and model by &quot;inheriting&quot; pre-defined agent properties suited for each type of space.</p><p>The simplest syntax of [<code>@agent</code>] is (and see its documentation for all its capabilities):</p><pre><code class="language-julia hljs">@agent struct YourAgentType(AgentTypeToInheritFrom) [&lt;: OptionalSupertype]
    extra_property::Float64 # annotating the type leads to optimal computational performance
    other_extra_property_with_default::Bool = true
    const other_extra_constant_property::Int
    # etc...
end</code></pre><p>The command may seem intimidating at first, but it is in truth not that different from Julia&#39;s native <a href="https://docs.julialang.org/en/v1/manual/types/#Composite-Types"><code>struct</code> definition</a>! For example,</p><pre><code class="language-julia hljs">@agent struct Person(GridAgent{2})
    age::Int
    money::Float64
end</code></pre><p>would make an agent type with named properties <code>age, money</code>, while also inheriting all named properties of the <code>GridAgent{2}</code> predefined type. These properties are <code>(id::Int, pos::Tuple{Int, Int})</code> and are necessary for simulating agents in a two-dimensional grid space. The documentation of each space describes what pre-defined agent one needs to inherit from in the <code>@agent</code> command, which is how we found that we need to put <code>GridAgent{2}</code> there. The <code>{2}</code> is simply an annotation that the space is 2-dimensional, as Agents.jl allows simulations in arbitrary-dimensional spaces.</p><h2 id="Step-2:-creating-the-agent-type"><a class="docs-heading-anchor" href="#Step-2:-creating-the-agent-type">Step 2: creating the agent type</a><a id="Step-2:-creating-the-agent-type-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-creating-the-agent-type" title="Permalink"></a></h2><p>With this knowledge, let&#39;s now make the agent type for the Schelling segregation model. According to the rules of the game, the agent needs to have two auxilary properties: its mood (boolean) and the group it belongs to (integer). The agent also needs to inherit from <code>GridAgent{2}</code> as in the example above. So, we define:</p><pre><code class="language-julia hljs">@agent struct SchellingAgent(GridAgent{2})
    mood::Bool # whether the agent is happy in its position
    group::Int # The group of the agent, determines mood as it interacts with neighbors
end</code></pre><p>Let&#39;s explitily print the fields of the data structure <code>SchellingAgent</code> that we created:</p><pre><code class="language-julia hljs">for (name, type) in zip(fieldnames(SchellingAgent), fieldtypes(SchellingAgent))
    println(name, &quot;::&quot;, type)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">id::Int64
pos::Tuple{Int64, Int64}
mood::Bool
group::Int64</code></pre><p>All these fields can be accessed during the simulation, but it is important to keep in mind that <code>id</code> cannot be modified, and <code>pos</code> must never be modified directly; only through valid API functions such as <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a>.</p><p>For example, if we initialize such an agent</p><pre><code class="language-julia hljs">example_agent = SchellingAgent(id = 1, pos = (2, 3), mood = true, group = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SchellingAgent(1, (2, 3), true, 1)</code></pre><p>we can obtain</p><pre><code class="language-julia hljs">example_agent.mood</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><p>and set</p><pre><code class="language-julia hljs">example_agent.mood = false</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">false</code></pre><p>but can&#39;t set the <code>id</code>:</p><pre><code class="language- hljs">```
example_agent.id = 2
```
```
ERROR: setfield!: const field .id of type SchellingAgent cannot be changed
Stacktrace:
 [1] setproperty!(x::SchellingAgent, f::Symbol, v::Int64)
   @ Base .\Base.jl:41
```</code></pre><h2 id="Step-2:-redefining-agent-types"><a class="docs-heading-anchor" href="#Step-2:-redefining-agent-types">Step 2: redefining agent types</a><a id="Step-2:-redefining-agent-types-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-redefining-agent-types" title="Permalink"></a></h2><p>You will notice that <em>it is not possible to redefine</em> agent types using the same name as the one they were originally defined with. E.g., this will error:</p><pre><code class="language-julia hljs">@agent struct SchellingAgent(GridAgent{2})
    mood::Bool # whether the agent is happy in its position
    group::Int # The group of the agent, determines mood as it interacts with neighbors
    age::Int
end</code></pre><pre><code class="nohighlight hljs">ERROR: invalid redefinition of constant Main.SchellingAgent
Stacktrace:
 [1] macro expansion
   @ util.jl:609 [inlined]
 [2] macro expansion
   @ .julia\dev\Agents\src\core\agents.jl:210 [inlined]
 [3] top-level scope
   @ .julia\dev\Agents\docs\src\tutorial.jl:266</code></pre><p>This is not a limitation of Agents.jl but a fundamental limitation of the Julia language that very likely will be addressed in the near future. Normally, you would need to restart your Julia session to redefine a custom <code>struct</code>. However, it is simpler to just do a mass rename in the text editor you use to write Julia code (for example, Ctrl+Shift+H in VSCode can do a mass rename). Change the name of the agent type to e.g., the same name ending in 2, 3, ..., and carry on, until you are happy with the final configuration. When this happens you will have to restart Julia and rename the type back to having no numeric ending. Inconvenient, but thankfully it only takes a couple of seconds to resolve!</p><div class="admonition is-info"><header class="admonition-header">This is the most performant version, unfortunately.</header><div class="admonition-body"><p>Throughout the development of Agents.jl we have thought of this &quot;redefining annoyance&quot; and ways to resolve it. Unfortunately, all alternative design approaches to agent based modelling that don&#39;t have redefinition problems lead to drastic performance downsides. Given that mass-renaming in the development phase of a project is not too big of a hurdle, we decided to stick with the most performant design!</p></div></div><h2 id="Step-3:-form-of-the-evolution-rule(s)-in-discrete-time"><a class="docs-heading-anchor" href="#Step-3:-form-of-the-evolution-rule(s)-in-discrete-time">Step 3: form of the evolution rule(s) in discrete time</a><a id="Step-3:-form-of-the-evolution-rule(s)-in-discrete-time-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-form-of-the-evolution-rule(s)-in-discrete-time" title="Permalink"></a></h2><p>The form of the evolution rule(s) depends on the type of <a href="../api/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> we want to use. For the example we are following here, we will use <a href="../api/#Agents.StandardABM"><code>StandardABM</code></a>. For this, time is discrete. In this case, the evolution rule needs to be provided as at least one, or at most two functions: an agent stepping function, that acts on scheduled agents one by one, and/or a model stepping function, that steps the entire model as a whole. These functions are standard Julia functions that take advantage of the Agents.jl <a href="../api/#API">API</a>. At each discrete step of the simulation, the agent stepping function is applied once to all scheduled agents, and the model stepping function is applied once to the model. The model stepping function may also modify arbitrarily many agents since at any point all agents of the simulation are accessible from the agent based model.</p><p>To give you an idea, here is an example of a model stepping function:</p><pre><code class="language-julia hljs">function model_step!(model)
    exchange = model.exchange # obtain the `exchange` model property
    agent = model[5] # obtain agent with ID = 5
    # Iterate over neighboring agents (within distance 1)
    for neighbor in nearby_agents(model, agent, 1)
        transfer = minimum(neighbor.money, exchange)
        agent.money += transfer
        neighbor.money -= transfer
    end
    return # function end. As it is in-place it `return`s nothing.
end</code></pre><p>This model stepping function did not operate on all agents of the model, only on agent with ID 5 and its spatial neighbors. Typically you would want to operate on more agents, which is why Agents.jl also allows the concept of the agent stepping function. This feature enables scheduling agents automatically given some scheduling rule, skipping the agents that were scheduled to act but have been removed from the model (due to e.g., the actions of other agents), and also allows optimizations that are based on the specific type of <code>AgentBasedModel</code>.</p><h2 id="Step-3:-agent-stepping-function-for-the-Schelling-model"><a class="docs-heading-anchor" href="#Step-3:-agent-stepping-function-for-the-Schelling-model">Step 3: agent stepping function for the Schelling model</a><a id="Step-3:-agent-stepping-function-for-the-Schelling-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-agent-stepping-function-for-the-Schelling-model" title="Permalink"></a></h2><p>According to the rules of the Schelling segregation model, we don&#39;t need a model stepping function, but an agent stepping function that acts on all agents. So we define:</p><pre><code class="language-julia hljs">function schelling_step!(agent, model)
    # Here we access a model-level property `min_to_be_happy`.
    # This will have an assigned value once we create the model.
    minhappy = model.min_to_be_happy
    count_neighbors_same_group = 0
    # For each neighbor, get group and compare to current agent&#39;s group
    # and increment `count_neighbors_same_group` as appropriately.
    # Here `nearby_agents` (with default arguments) will provide an iterator
    # over the nearby agents one grid cell away, which are at most 8.
    for neighbor in nearby_agents(agent, model)
        if agent.group == neighbor.group
            count_neighbors_same_group += 1
        end
    end
    # After counting the neighbors, decide whether or not to move the agent.
    # If count_neighbors_same_group is at least the min_to_be_happy, set the
    # mood to true. Otherwise, move the agent to a random position, and set
    # mood to false.
    if count_neighbors_same_group ≥ minhappy
        agent.mood = true
    else
        agent.mood = false
        move_agent_single!(agent, model)
    end
    return
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">schelling_step! (generic function with 1 method)</code></pre><p>Here we used some of the built-in functionality of Agents.jl, in particular:</p><ul><li><a href="../api/#Agents.nearby_positions"><code>nearby_positions</code></a> that returns the neighboring position on which the agent resides</li><li><a href="../api/#Agents.move_agent_single!"><code>move_agent_single!</code></a> which moves an agent to a random empty position on the grid while respecting an at most 1 agent per position rule</li><li><code>model[id]</code> which returns the agent with given <code>id</code> in the <code>model</code>,</li></ul><p>. <code>model.min_to_be_happy</code> which returns the model-level property named <code>min_to_be_happy</code></p><p>A full list of built-in functionality and their explanations are available in the <a href="../api/#API">API</a> page.</p><p>We stress that in contrast to the above <code>model_step!</code>, <code>schelling_step!</code> will be called for <em>every</em> scheduled agent, while <code>model_step!</code> would only be called <em>once</em> per simulation step. By default, all agents in the model are scheduled once per step, but we will discuss this more later in the &quot;scheduling&quot; section.</p><p>At least one of the model or agent stepping functions must be provided.</p><h2 id="Step-4:-the-AgentBasedModel"><a class="docs-heading-anchor" href="#Step-4:-the-AgentBasedModel">Step 4: the <code>AgentBasedModel</code></a><a id="Step-4:-the-AgentBasedModel-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-the-AgentBasedModel" title="Permalink"></a></h2><p>The <code>AgentBasedModel</code> is the central structure in an Agents.jl simulation that map agent IDs to agent instances (which is why the <code>.id</code> field cannot be changed), as well as containing all information necessary to perform the simulation: the evolution rules, the space, model-level properties, and more.</p><p>Additiohally <a href="../api/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> defines an interface that research can build upon to create new flavors of ABMs that can still benefit for the thousands of functions Agents.jl offers out of the box such as <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a>.</p><h2 id="Step-4:-initializing-the-model"><a class="docs-heading-anchor" href="#Step-4:-initializing-the-model">Step 4: initializing the model</a><a id="Step-4:-initializing-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-initializing-the-model" title="Permalink"></a></h2><p>In this simulation we are using <a href="../api/#Agents.StandardABM"><code>StandardABM</code></a>. From its documentation, we learn that to initialize it we have to provide the agent type(s) participating in the simulation, the space instance, and, as keyword arguments, the evolution rules, and any model-level properties.</p><p>Here, we have defined the first three already. The only model-level property for the Schelling simulation would be the minimum agents of the same group required for an agent to be happy. We make this a dictionary so we can access this property by name:</p><pre><code class="language-julia hljs">properties = Dict(:min_to_be_happy =&gt; 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Int64} with 1 entry:
  :min_to_be_happy =&gt; 3</code></pre><p>And now, we simply put everything together in the <a href="../api/#Agents.StandardABM"><code>StandardABM</code></a> constructor:</p><pre><code class="language-julia hljs">schelling = StandardABM(
    # input arguments
    SchellingAgent, space;
    # keyword arguments
    properties, # in Julia if the input variable and keyword are named the same,
                # you don&#39;t need to repeat the keyword!
    agent_step! = schelling_step!
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 0 agents of type SchellingAgent
 agents container: Dict
 space: GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false
 scheduler: fastest
 properties: min_to_be_happy</code></pre><p>The model is printed in the console displaying all of the most basic information about it.</p><h2 id="Step-4:-an-(optional)-scheduler"><a class="docs-heading-anchor" href="#Step-4:-an-(optional)-scheduler">Step 4: an (optional) scheduler</a><a id="Step-4:-an-(optional)-scheduler-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-an-(optional)-scheduler" title="Permalink"></a></h2><p>Since we opted to use an <code>agent_step!</code> function, the scheduler of the model matters. Here we used the default scheduler (which is also the fastest one) to create the model. We could instead try to activate the agents according to their property <code>:group</code>, so that all agents of group 1 act first. We would then use the scheduler <a href="../api/#Agents.Schedulers.ByProperty"><code>Schedulers.ByProperty</code></a> like so:</p><pre><code class="language-julia hljs">scheduler = Schedulers.ByProperty(:group)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Agents.Schedulers.ByProperty{Symbol}(:group, Int64[], Int64[])</code></pre><p>and pass this to the model creation</p><pre><code class="language-julia hljs">schelling = StandardABM(
    SchellingAgent,
    space;
    properties,
    agent_step! = schelling_step!,
    scheduler,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 0 agents of type SchellingAgent
 agents container: Dict
 space: GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false
 scheduler: Agents.Schedulers.ByProperty{Symbol}
 properties: min_to_be_happy</code></pre><h2 id="Step-4:-populating-it-with-agents"><a class="docs-heading-anchor" href="#Step-4:-populating-it-with-agents">Step 4: populating it with agents</a><a id="Step-4:-populating-it-with-agents-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-populating-it-with-agents" title="Permalink"></a></h2><p>The printing above says that the model has 0 agents, as indeed, we haven&#39;t added any. We could also obtain this information with the <a href="../api/#Agents.nagents"><code>nagents</code></a> function:</p><pre><code class="language-julia hljs">nagents(schelling)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0</code></pre><p>We can add agents to this model using <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. This function generates a new agent instance and adds it to the model. The function automatically configures the agent ID and chooses a random position for it by default (while the user can specify one if necessary). The subsequent arguments given to <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>, i.e., beyond the optional position and the model instance are all the extra properties the agent type(s) have, which was decided when we made the agent type(s) with the <a href="../api/#Agents.@agent"><code>@agent</code></a> command above.</p><p>For example, this adds the agent to a specified position, and attributes <code>false</code> to its <code>mood</code> and <code>1</code> to its group`:</p><pre><code class="language-julia hljs">added_agent_1 = add_agent!((1, 1), schelling, false, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SchellingAgent(1, (1, 1), false, 1)</code></pre><p>while this adds an agent to a randomly picked position as we did not provide a position as the first input to the function:</p><pre><code class="language-julia hljs">added_agent_2 = add_agent!(schelling, false, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SchellingAgent(2, (2, 9), false, 1)</code></pre><p>Notice also that agent fields may be specified by keyowrds as well, which is arguably the more readable syntax:</p><pre><code class="language-julia hljs">added_agent_3 = add_agent!(schelling; mood = true, group = 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SchellingAgent(3, (2, 2), true, 2)</code></pre><p>If we spend some time learning the <a href="../api/#API">API</a> functions, we realize that For the Schelling model specification, there is a more fitting function to use: <a href="../api/#Agents.add_agent_single!"><code>add_agent_single!</code></a>, which offers an automated way to create and add agents while ensuring that we have at most 1 agent per unique position.</p><pre><code class="language-julia hljs">added_agent_4 = add_agent_single!(schelling; mood = false, group = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SchellingAgent(4, (4, 6), false, 1)</code></pre><p>And let&#39;s confirm that now the model should have 4 agents</p><pre><code class="language-julia hljs">nagents(schelling)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4</code></pre><h2 id="Step-4:-random-number-generator"><a class="docs-heading-anchor" href="#Step-4:-random-number-generator">Step 4: random number generator</a><a id="Step-4:-random-number-generator-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-random-number-generator" title="Permalink"></a></h2><p>Each ABM in Agents.jl contains a random number generator (RNG) instance that can be obtained with <code>abmrng(model)</code>. A benefit of this approach is making models deterministic so that they can be run again and yield the same output. For reproducibility and performance reasons, one should never use <code>rand()</code> without using the RNG in the evolution rule(s) functions. Indeed, throughout our examples we use <code>rand(abmrng(model))</code> or <code>rand(abmrng(model), 1:10, 100)</code>, etc, providing the RNG as the first input to the <code>rand</code> function. All functions of the Agents.jl <a href="../api/#API">API</a> that utilize randomness, such as the <a href="../api/#Agents.add_agent_single!"><code>add_agent_single!</code></a> function we used above, internally use <code>abmrng(model)</code> as well.</p><p>You can explicitly choose the RNG the model will use by passing an instance of an <code>AbstractRNG</code>. For example a common RNG is <code>Xoshiro</code>, and we give this to the model via the <code>rng</code> keyword:</p><pre><code class="language-julia hljs">using Random: Xoshiro # access the RNG object

schelling = StandardABM(
    SchellingAgent,
    space;
    properties,
    agent_step! = schelling_step!,
    scheduler,
    rng = Xoshiro(1234) # input number is the seed
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 0 agents of type SchellingAgent
 agents container: Dict
 space: GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false
 scheduler: Agents.Schedulers.ByProperty{Symbol}
 properties: min_to_be_happy</code></pre><h2 id="Step-4:-making-the-initialization-a-keyword-based-function"><a class="docs-heading-anchor" href="#Step-4:-making-the-initialization-a-keyword-based-function">Step 4: making the initialization a keyword-based function</a><a id="Step-4:-making-the-initialization-a-keyword-based-function-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-making-the-initialization-a-keyword-based-function" title="Permalink"></a></h2><p>It is recommended that model initialization is done through a function obtaining all initialization parameters as keywords. Inside this function the model should be populated by agents as well.</p><p>This has several advantages. First, it makes it easy to recreate the model and change its parameters. Second, because the function is defined based on keywords, it will be of further use in <a href="../api/#Agents.paramscan"><code>paramscan</code></a> as we will discuss below.</p><pre><code class="language-julia hljs">function initialize(; total_agents = 320, gridsize = (20, 20), min_to_be_happy = 3, seed = 125)
    space = GridSpaceSingle(gridsize; periodic = false)
    properties = Dict(:min_to_be_happy =&gt; min_to_be_happy)
    rng = Xoshiro(seed)
    model = StandardABM(
        SchellingAgent, space;
        agent_step! = schelling_step!, properties, rng,
        container = Vector, # agents are not removed, so we us this
        scheduler = Schedulers.Randomly() # all agents are activated once at random
    )
    # populate the model with agents, adding equal amount of the two types of agents
    # at random positions in the model. At the start all agents are unhappy.
    for n in 1:total_agents
        add_agent_single!(model; mood = false, group = n &lt; total_agents / 2 ? 1 : 2)
    end
    return model
end

schelling = initialize()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 320 agents of type SchellingAgent
 agents container: Vector
 space: GridSpaceSingle with size (20, 20), metric=chebyshev, periodic=false
 scheduler: Agents.Schedulers.Randomly
 properties: min_to_be_happy</code></pre><h2 id="Step-5:-evolve-the-model"><a class="docs-heading-anchor" href="#Step-5:-evolve-the-model">Step 5: evolve the model</a><a id="Step-5:-evolve-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-evolve-the-model" title="Permalink"></a></h2><p>Alright, now that we have a model populated with agents we can evolve it forwards in time. This step is rather trivial. We simply call the <a href="@ref"><code>step!</code></a> function on the model</p><pre><code class="language-julia hljs">step!(schelling)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 320 agents of type SchellingAgent
 agents container: Vector
 space: GridSpaceSingle with size (20, 20), metric=chebyshev, periodic=false
 scheduler: Agents.Schedulers.Randomly
 properties: min_to_be_happy</code></pre><p>which progresses the simulation for one step. Or, we can progress for arbitrary many steps</p><pre><code class="language-julia hljs">step!(schelling, 3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 320 agents of type SchellingAgent
 agents container: Vector
 space: GridSpaceSingle with size (20, 20), metric=chebyshev, periodic=false
 scheduler: Agents.Schedulers.Randomly
 properties: min_to_be_happy</code></pre><p>or, we can progress until a provided function that inputs the model and the current model time evaluates to <code>true</code>. For example, lets step until at least 90% of the agents are happy.</p><pre><code class="language-julia hljs">happy90(model, time) = count(a -&gt; a.mood == true, allagents(model))/nagents(model) ≥ 0.9

step!(schelling, happy90)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 320 agents of type SchellingAgent
 agents container: Vector
 space: GridSpaceSingle with size (20, 20), metric=chebyshev, periodic=false
 scheduler: Agents.Schedulers.Randomly
 properties: min_to_be_happy</code></pre><p>Note that in the above function we didn&#39;t actually utilize the <code>time</code> argument. In a realistic setting it is strongly recommended to utilize it to put an additional condition bounding the total number of steps (such as <code>if time &gt; 1000; return true</code>), so that the time evolution does not fall into an infinite loop because the function never evaluates to <code>true</code>.</p><p>In any case, we can see how many steps the model has taken so far with <a href="../api/#Agents.abmtime"><code>abmtime</code></a></p><pre><code class="language-julia hljs">abmtime(schelling)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6</code></pre><h2 id="Step-6:-Visualizations"><a class="docs-heading-anchor" href="#Step-6:-Visualizations">Step 6: Visualizations</a><a id="Step-6:-Visualizations-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Visualizations" title="Permalink"></a></h2><p>There is a <a href="../examples/agents_visualizations/#vis_tutorial">dedicated tutorial</a> for visualization, animation, and making custom interactive GUIs for agent based models. Here, we will use the the <a href="../api/#Agents.abmplot"><code>abmplot</code></a> function to plot the distribution of agents on a 2D grid at every step, using the <a href="http://makie.juliaplots.org/stable/">Makie</a> plotting ecosystem.</p><p>First, we load the plotting backend</p><pre><code class="language-julia hljs">using CairoMakie # choosing a plotting backend</code></pre><p>and then we simply define functions that given an agent they return its color or marker. Let&#39;s color the two groups orange and blue and make one a square and the other a circle.</p><pre><code class="language-julia hljs">groupcolor(a) = a.group == 1 ? :blue : :orange
groupmarker(a) = a.group == 1 ? :circle : :rect</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">groupmarker (generic function with 1 method)</code></pre><p>We pass those functions to <a href="../api/#Agents.abmplot"><code>abmplot</code></a></p><pre><code class="language- hljs">figure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)
figure # returning the figure displays it</code></pre><p>The function <a href="../api/#Agents.abmvideo"><code>abmvideo</code></a> can be used to save an animation of the ABM into a video.</p><pre><code class="language- hljs">schelling = initialize()
abmvideo(
    &quot;schelling.mp4&quot;, schelling;
    ac = groupcolor, am = groupmarker, as = 10,
    framerate = 4, frames = 20,
    title = &quot;Schelling&#39;s segregation model&quot;
)</code></pre><video width="auto" controls autoplay loop>
<source src="../schelling.mp4" type="video/mp4">
</video><h2 id="Step-7:-data-collection"><a class="docs-heading-anchor" href="#Step-7:-data-collection">Step 7: data collection</a><a id="Step-7:-data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Step-7:-data-collection" title="Permalink"></a></h2><p>Running the model and collecting data while the model runs is done with the <a href="../api/#Agents.run!"><code>run!</code></a> function. Besides <code>run!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection while scanning ranges of the parameters of the model, and the <a href="../api/#Agents.ensemblerun!"><code>ensemblerun!</code></a> that performs ensemble simulations and data collection.</p><p>The <a href="../api/#Agents.run!"><code>run!</code></a> function has been designed for maximum flexibility: practically all scenarios of data collection are possible, whether you need agent data, model data, aggregated data, or arbitrary combinations.</p><p>To use <a href="../api/#Agents.run!"><code>run!</code></a> we simply provide a vector of what agent properties to collect as data. The <code>adata</code> keyword corresponds to the &quot;agent data&quot;, and there is the <code>mdata</code> keyword for model data.</p><p>For example, specifying the properties as <code>Symbol</code>s means to collect the named properties</p><pre><code class="language-julia hljs">adata = [:pos, :mood, :group]

schelling = initialize()
adf, mdf = run!(schelling, 5; adata) # run for 5 steps
adf[end-10:end, :] # display only the last few rows</code></pre><div><div style = "float: left;"><span>11×5 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">step</th><th style = "text-align: left;">id</th><th style = "text-align: left;">pos</th><th style = "text-align: left;">mood</th><th style = "text-align: left;">group</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Tuple{Int64, Int64}" style = "text-align: left;">Tuple…</th><th title = "Bool" style = "text-align: left;">Bool</th><th title = "Int64" style = "text-align: left;">Int64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">5</td><td style = "text-align: right;">310</td><td style = "text-align: left;">(15, 13)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">5</td><td style = "text-align: right;">311</td><td style = "text-align: left;">(3, 16)</td><td style = "text-align: right;">false</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">5</td><td style = "text-align: right;">312</td><td style = "text-align: left;">(1, 11)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">5</td><td style = "text-align: right;">313</td><td style = "text-align: left;">(13, 6)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: right;">314</td><td style = "text-align: left;">(16, 17)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">5</td><td style = "text-align: right;">315</td><td style = "text-align: left;">(20, 6)</td><td style = "text-align: right;">false</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: right;">5</td><td style = "text-align: right;">316</td><td style = "text-align: left;">(13, 4)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: right;">5</td><td style = "text-align: right;">317</td><td style = "text-align: left;">(12, 8)</td><td style = "text-align: right;">false</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: right;">5</td><td style = "text-align: right;">318</td><td style = "text-align: left;">(3, 11)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: right;">5</td><td style = "text-align: right;">319</td><td style = "text-align: left;">(15, 18)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">11</td><td style = "text-align: right;">5</td><td style = "text-align: right;">320</td><td style = "text-align: left;">(19, 9)</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr></tbody></table></div><p><a href="../api/#Agents.run!"><code>run!</code></a> collects data in the form of a <code>DataFrame</code> which is Julia&#39;s premier format for tabular data (and you probably need to learn how to use it independently of Agents.jl if you don&#39;t know it yet, see the documentation of DataFrames.jl to do so). Above, data were collected for each agent and for each step of the simulation.</p><p>Besides <code>Symbol</code>s, we can specify functions as agent data to collect</p><pre><code class="language-julia hljs">x(agent) = agent.pos[1]
schelling = initialize()
adata = [x, :mood, :group]
adf, mdf = run!(schelling, 5; adata)
adf[end-10:end, :] # display only the last few rows</code></pre><div><div style = "float: left;"><span>11×5 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">step</th><th style = "text-align: left;">id</th><th style = "text-align: left;">x</th><th style = "text-align: left;">mood</th><th style = "text-align: left;">group</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Bool" style = "text-align: left;">Bool</th><th title = "Int64" style = "text-align: left;">Int64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">5</td><td style = "text-align: right;">310</td><td style = "text-align: right;">15</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">5</td><td style = "text-align: right;">311</td><td style = "text-align: right;">3</td><td style = "text-align: right;">false</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">5</td><td style = "text-align: right;">312</td><td style = "text-align: right;">1</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">5</td><td style = "text-align: right;">313</td><td style = "text-align: right;">13</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">5</td><td style = "text-align: right;">314</td><td style = "text-align: right;">16</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">5</td><td style = "text-align: right;">315</td><td style = "text-align: right;">20</td><td style = "text-align: right;">false</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">7</td><td style = "text-align: right;">5</td><td style = "text-align: right;">316</td><td style = "text-align: right;">13</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">8</td><td style = "text-align: right;">5</td><td style = "text-align: right;">317</td><td style = "text-align: right;">12</td><td style = "text-align: right;">false</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">9</td><td style = "text-align: right;">5</td><td style = "text-align: right;">318</td><td style = "text-align: right;">3</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">10</td><td style = "text-align: right;">5</td><td style = "text-align: right;">319</td><td style = "text-align: right;">15</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">11</td><td style = "text-align: right;">5</td><td style = "text-align: right;">320</td><td style = "text-align: right;">19</td><td style = "text-align: right;">true</td><td style = "text-align: right;">2</td></tr></tbody></table></div><p>With the above <code>adata</code> vector, we collected all agent&#39;s data. We can instead collect aggregated data for the agents. For example, let&#39;s only get the number of happy individuals, and the average of the &quot;x&quot; (not very interesting, but anyway!). To do this, make <code>adata</code> a vector of <code>Tuple</code>s, where the first entry of the tuple is the data to collect, and the second how to aggregate it over agents.</p><pre><code class="language-julia hljs">using Statistics: mean
schelling = initialize();
adata = [(:mood, sum), (x, mean)]
adf, mdf = run!(schelling, 5; adata)
adf</code></pre><div><div style = "float: left;"><span>6×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">step</th><th style = "text-align: left;">sum_mood</th><th style = "text-align: left;">mean_x</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Float64" style = "text-align: left;">Float64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">0</td><td style = "text-align: right;">0</td><td style = "text-align: right;">10.3281</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">1</td><td style = "text-align: right;">211</td><td style = "text-align: right;">10.4313</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">2</td><td style = "text-align: right;">248</td><td style = "text-align: right;">10.3688</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">3</td><td style = "text-align: right;">260</td><td style = "text-align: right;">10.2969</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">4</td><td style = "text-align: right;">275</td><td style = "text-align: right;">9.99687</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">6</td><td style = "text-align: right;">5</td><td style = "text-align: right;">286</td><td style = "text-align: right;">10.225</td></tr></tbody></table></div><p>Other examples in the documentation are more realistic, with more meaningful collected data. You should consult the documentation of <a href="../api/#Agents.run!"><code>run!</code></a> for more power over data collection.</p><p><em><strong>And this concludes the main tutorial!</strong></em></p><h2 id="Multiple-agent-types-in-Agents.jl"><a class="docs-heading-anchor" href="#Multiple-agent-types-in-Agents.jl">Multiple agent types in Agents.jl</a><a id="Multiple-agent-types-in-Agents.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-agent-types-in-Agents.jl" title="Permalink"></a></h2><p>In realistic modelling situations it is often the case the the ABM is composed of different types of agents. Agents.jl supports two approaches for multi-agent ABMs. The first uses the <code>Union</code> type (this subsection), and the second uses the <a href="../api/#Agents.@multiagent"><code>@multiagent</code></a> command (next subsection). <code>@multiagent</code> is recommended as default, because in many cases it will have performance advantages over the <code>Union</code> approach without having tangible disadvantages. However, we strongly recommend you to read through the <a href="../performance_tips/#multi_vs_union">comparison of the two approaches</a>.</p><p><em>Note that using multiple agent types is a possibility entirely orthogonal to the type of <code>AgentBasedModel</code> or the type of space. Everything we describe here works for any Agents.jl simulation.</em></p><h2 id="Multiple-agent-types-with-Union-types"><a class="docs-heading-anchor" href="#Multiple-agent-types-with-Union-types">Multiple agent types with <code>Union</code> types</a><a id="Multiple-agent-types-with-Union-types-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-agent-types-with-Union-types" title="Permalink"></a></h2><p>The simplest way to add more agent types is to make more of them with <a href="../api/#Agents.@agent"><code>@agent</code></a> and then give a <code>Union</code> of agent types as the agent type when making the <code>AgentBasedModel</code>. For example, let&#39;s say that a new type of agent enters the simulation; a politician that would &quot;attract&quot; a preferred demographic. We then would make</p><pre><code class="language-julia hljs">@agent struct Politician(GridAgent{2})
    preferred_demographic::Int
end</code></pre><p>and, when making the model we would specify</p><pre><code class="language-julia hljs">model = StandardABM(
    Union{SchellingAgent, Politician}, # type of agents
    space; # space they live in
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 0 agents of type Union{Main.Politician, Main.SchellingAgent}
 agents container: Dict
 space: GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false
 scheduler: fastest</code></pre><p>Naturally, we would have to define a new agent stepping function that would act differently depending on the agent type. This could be done by making a function that calls other functions depending on the type, such as</p><pre><code class="language-julia hljs">function union_step!(agent, model)
    if typeof(agent) &lt;: AgentSchelling
        schelling_step!(agent, model)
    elseif typeof(agent) &lt;: Politician
        politician_step!(agent, model)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">union_step! (generic function with 1 method)</code></pre><p>and then passing</p><pre><code class="language-julia hljs">model = StandardABM(
    Union{SchellingAgent, Politician}, # type of agents
    space; # space they live in
    agent_step! = union_step!
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 0 agents of type Union{Main.Politician, Main.SchellingAgent}
 agents container: Dict
 space: GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false
 scheduler: fastest</code></pre><p>This approach also works with the <a href="../api/#Agents.@multiagent"><code>@multiagent</code></a> possibility we discuss below. <code>Union</code> types however also offer the unique possibility of utilizing Julia&#39;s <a href="https://docs.julialang.org/en/v1/manual/methods/">multiple dispatch system</a>. Hence, we can use the same function name and add dispatch to it, such as:</p><pre><code class="language-julia hljs">function dispatch_step!(agent::SchellingAgent, model)
    # stuff.
end

function dispatch_step!(agent::Politician, model)
    # other stuff.
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">dispatch_step! (generic function with 2 methods)</code></pre><p>and give <code>dispatch_step!</code> to the <code>agent_step!</code> keyword during model creation.</p><h2 id="Multiple-agent-types-with-@multiagent"><a class="docs-heading-anchor" href="#Multiple-agent-types-with-@multiagent">Multiple agent types with <code>@multiagent</code></a><a id="Multiple-agent-types-with-@multiagent-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-agent-types-with-@multiagent" title="Permalink"></a></h2><p><a href="../api/#Agents.@multiagent"><code>@multiagent</code></a> does not offer the multiple dispatch possibility, but in the majority of cases leads to better computational performance. Intentionally the command has been designed to be as similar to <a href="../api/#Agents.@agent"><code>@agent</code></a> as possible. The syntax to use it is like so:</p><pre><code class="language- hljs">@multiagent struct MultiSchelling{X}(GridAgent{2})
    @agent struct Civilian # can&#39;t re-define existing `Schelling` name
        mood::Bool = false
        group::Int
    end
    @agent struct Governor{X} # can&#39;t redefine existing `Politician` name
        group::Int
        influence::X
    end
end</code></pre><p>This macro created three names into scope:</p><pre><code class="language- hljs">(MultiSchelling, Civilian, Governor)</code></pre><p>however, only one of these names is an actual Julia type:</p><pre><code class="language- hljs">fieldnames(MultiSchelling)</code></pre><p>that contains all fields of all subtypes without duplication, while</p><pre><code class="language- hljs">fieldnames(Civilian)</code></pre><p>doesn&#39;t have any fields. Instead, you should think of <code>Civilian</code> and <code>Governor</code> as just convenience functions that have been defined for you to &quot;behave like&quot; types. E.g., you can initialize</p><pre><code class="language- hljs">civ = Civilian(; id = 2, pos = (2, 2), group = 2) # default `mood`</code></pre><p>or</p><pre><code class="language- hljs">gov = Governor(; id = 3 , pos = (2, 2), group = 2, influence = 0.5)</code></pre><p>exactly as if these were types made with <a href="../api/#Agents.@agent"><code>@agent</code></a>. These are all of type <code>MultiSchelling</code></p><pre><code class="language- hljs">typeof(gov)</code></pre><p>and hence you can&#39;t use <code>typeof</code> to differentiate them. But you can use</p><pre><code class="language- hljs">kindof(gov)</code></pre><p>instead. Hence, the agent stepping function should be something like</p><pre><code class="language-julia hljs">function multi_step!(agent, model)
    if kindof(agent) == :Civilian
        schelling_step!(agent, model)
    elseif kindof(agent) == :Governor
        politician_step!(agent, model)
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">multi_step! (generic function with 1 method)</code></pre><p>and give that to the model creation</p><pre><code class="language- hljs">model = StandardABM(
    MultiSchelling, # the multi-agent supertype is given as the type
    space;
    agent_step! = multi_step!
)</code></pre><h2 id="Adding-agents-of-different-types-to-the-model"><a class="docs-heading-anchor" href="#Adding-agents-of-different-types-to-the-model">Adding agents of different types to the model</a><a id="Adding-agents-of-different-types-to-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-agents-of-different-types-to-the-model" title="Permalink"></a></h2><p>Regardless of whether you went down the <code>Union</code> or <code>@multiagent</code> route, the API of Agents.jl has been designed such that there is no difference in subsequent usage. To add agents to a model, we use the existing <a href="../api/#Agents.add_agent_single!"><code>add_agent_single!</code></a> command, but now specifying as a first argument the type of agent to add.</p><p>For example, in the union case we provide the <code>Union</code> type when we create the model,</p><pre><code class="language-julia hljs">model = StandardABM(Union{SchellingAgent, Politician}, space)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">StandardABM with 0 agents of type Union{Main.Politician, Main.SchellingAgent}
 agents container: Dict
 space: GridSpaceSingle with size (10, 10), metric=chebyshev, periodic=false
 scheduler: fastest</code></pre><p>we add them by specifying the type</p><pre><code class="language-julia hljs">add_agent_single!(SchellingAgent, model; group = 1, mood = true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.SchellingAgent(1, (3, 7), true, 1)</code></pre><p>or</p><pre><code class="language-julia hljs">add_agent_single!(Politician, model; preferred_demographic = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.Politician(2, (8, 7), 1)</code></pre><p>and we see</p><pre><code class="language-julia hljs">collect(allagents(model))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Union{Main.Politician, Main.SchellingAgent}}:
 Main.Politician(2, (8, 7), 1)
 Main.SchellingAgent(1, (3, 7), true, 1)</code></pre><p>For the <code>@multiagent</code> case, there is really no difference. We have</p><pre><code class="language- hljs">model = StandardABM(MultiSchelling, space)</code></pre><p>we add</p><pre><code class="language- hljs">add_agent_single!(Civilian, model; group = 1)</code></pre><p>or</p><pre><code class="language- hljs">add_agent_single!(Governor, model; influence = 0.5, group = 1)</code></pre><p>and we see</p><pre><code class="language-julia hljs">collect(allagents(model))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Union{Main.Politician, Main.SchellingAgent}}:
 Main.Politician(2, (8, 7), 1)
 Main.SchellingAgent(1, (3, 7), true, 1)</code></pre><p>And that&#39;s the end of the tutorial!!! You can visit other examples to see other types of usage of Agents.jl, or go into the <a href="../api/#API">API</a> to find the functions you need to make your own ABM!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/sir/">SIR model for the spread of COVID-19 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Thursday 7 March 2024 10:20">Thursday 7 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
