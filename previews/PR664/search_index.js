var documenterSearchIndex = {"docs":
[{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/zombies.jl\"","category":"page"},{"location":"examples/zombies/#Zombie-Outbreak-in-a-City-1","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"","category":"section"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../outbreak.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"This model showcases an ABM running on a map, using OpenStreetMapSpace.","category":"page"},{"location":"examples/zombies/#Constructing-the-end-of-days-1","page":"Zombie Outbreak in a City","title":"Constructing the end of days","text":"","category":"section"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"using Agents\nusing Random","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"We'll simulate a zombie outbreak in a city. To do so, we start with an agent which satisfies the OSMSpace conditions of having a position of type Tuple{Int,Int,Float64}. For simplicity though we shall build this with the @agent macro.","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"@agent Zombie OSMAgent begin\n    infected::Bool\n    speed::Float64\nend","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"To be explicit, this macro builds the following type:","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"mutable struct Zombie <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int,Float64}\n    infected::Bool\n    speed::Float64\nend","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"where a tuple (i, j, x)::Tuple{Int,Int,Float64} means a position on the road between nodes i, j of the map, having progressed x distance along the road.","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"The model constructor we build consists of a map, and 100 agents scattered randomly around it. They have their own agenda and need to travel to some new destination. Unfortunately one of the population has turned and will begin infecting anyone who comes close.","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"function initialise(; seed = 1234)\n    map_path = OSM.test_map()\n    properties = Dict(:dt => 1 / 60)\n    model = ABM(\n        Zombie,\n        OpenStreetMapSpace(map_path);\n        properties = properties,\n        rng = Random.MersenneTwister(seed)\n    )\n\n    for id in 1:100\n        start = random_position(model) # At an intersection\n        speed = rand(model.rng) * 5.0 + 2.0 # Random speed from 2-7kmph\n        human = Zombie(id, start, false, speed)\n        add_agent_pos!(human, model)\n        OSM.plan_random_route!(human, model; limit = 50) # try 50 times to find a random route\n    end\n    # We'll add patient zero at a specific (longitude, latitude)\n    start = OSM.nearest_road((9.9351811, 51.5328328), model)\n    finish = OSM.nearest_node((9.945125635913511, 51.530876112711745), model)\n\n    speed = rand(model.rng) * 5.0 + 2.0 # Random speed from 2-7kmph\n    zombie = add_agent!(start, model, true, speed)\n    plan_route!(zombie, finish, model)\n    # This function call creates & adds an agent, see `add_agent!`\n    return model\nend","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"In our model, zombies are seemingly oblivious to their state, since they keep going about their business, but start eating people along the way. Perhaps they can finally express their distaste for city commuting.","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"function agent_step!(agent, model)\n    # Each agent will progress along their route\n    # Keep track of distance left to move this step, in case the agent reaches its\n    # destination early\n    distance_left = move_along_route!(agent, model, agent.speed * model.dt)\n\n    if is_stationary(agent, model) && rand(model.rng) < 0.1\n        # When stationary, give the agent a 10% chance of going somewhere else\n        OSM.plan_random_route!(agent, model; limit = 50)\n        # Start on new route, moving the remaining distance\n        move_along_route!(agent, model, distance_left)\n    end\n\n    if agent.infected\n        # Agents will be infected if they get too close (within 10m) to a zombie.\n        map(i -> model[i].infected = true, nearby_ids(agent, model, 0.01))\n    end\n    return\nend","category":"page"},{"location":"examples/zombies/#Visualising-the-fall-of-humanity-1","page":"Zombie Outbreak in a City","title":"Visualising the fall of humanity","text":"","category":"section"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"using InteractiveDynamics\nusing CairoMakie\nCairoMakie.activate!() # hide\nac(agent) = agent.infected ? :green : :black\nas(agent) = agent.infected ? 10 : 8\nmodel = initialise()\n\nabmvideo(\"outbreak.mp4\", model, agent_step!;\ntitle = \"Zombie outbreak\", framerate = 15, frames = 200, as, ac)","category":"page"},{"location":"examples/zombies/#","page":"Zombie Outbreak in a City","title":"Zombie Outbreak in a City","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../outbreak.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"comparison/#ABM-Framework-Comparison-1","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"","category":"section"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Many agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see here for a review). Notable examples are NetLogo, Repast, MASON, and Mesa.","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"In this page we compare Agents.jl with Mesa, Netlogo and Mason, to assess where Agents.jl excels and also may need some future improvement. We used the following models for the comparison:","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Predator-prey dynamics (Wolf Sheep Grass), a GridSpace model, which requires agents to be added, removed and moved; as well as identify properties of neighbouring positions.\nThe Flocking model (Flocking), a ContinuousSpace model, chosen over other models to include a MASON benchmark. Agents must move in accordance with social rules over the space.\nThe Forest fire model, provides comparisons for cellular automata type ABMs (i.e. when agents do not move). NOTE: The Agents.jl implementation of this model has been changed in v4.0 to be directly comparable to Mesa and NetLogo. As a consequence it no longer follows the original rule-set.\nSchelling's-segregation-model (Schelling), an additional GridSpace model to compare with MASON. Simpler rules than Wolf Sheep Grass.","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"The results are characterised in two ways: how long it took each model to perform the same scenario (initial conditions, grid size, run length etc. are the same across all frameworks), and how many lines of code (LOC) it took to describe each model and its dynamics. We use this result as a metric to represent the complexity of learning and working with a framework.","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Time taken is presented in normalised units, measured against the runtime of Agents.jl. In other words: the results do not depend on any computers specific hardware. If one wishes to repeat the results personally by using the scripts in the ABMFrameworkComparisons repository: they will compute the same results. For details on the parameters used for each comparison, see the benchmark.jl file in that repository.","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"For LOC, we use the following convention: code is formatted using standard practices & linting for the associated language. Documentation strings and in-line comments (residing on lines of their own) are discarded, as well as any benchmark infrastructure. NetLogo is assigned two values since its files have a code base section and an encoding of the GUI. Since many parameters live in the GUI, we must take this into account. Thus 375 (785) in a NetLogo count means 375 lines in the code section, 785 lines total in the file. An additional complication to this value in NetLogo is that it stores plotting information (colours, shapes, sizes) as agent properties, and as such the number outside of the bracket may be slightly inflated.","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"Model/Framework Agents 4.5.3 Mesa 0.8.9 Netlogo 6.2 MASON 20.0\nWolf Sheep Grass 1 21.5x 12.4x NA\n(LOC) 122 227 137 (871) .\nFlocking 1 26.8x 10.3xᕯ 2.1x\n(LOC) 62 102 82 (689) 369\nForest Fire 1 120.5x 53.8x NA\n(LOC) 23 35 43 (545) .\nSchelling 1 84.7x 40.9x 73.1x\n(LOC) 31 56 60 (743) 248","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"ᕯ Netlogo has a different implementation to the other three frameworks here. It cheats a little by only choosing one nearest neighbor in some cases rather than considering all neighbors within vision. So a true comparison would ultimately see a slower result.","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"The results clearly speak for themselves. Across all four models, Agents.jl's performance is exceptional whilst using the least amount of code. This removes many frustrating barriers-to-entry for new users, and streamlines the development process for established ones.","category":"page"},{"location":"comparison/#Table-based-comparison-1","page":"ABM Framework Comparison","title":"Table-based comparison","text":"","category":"section"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"In our paper discussing Agents.jl, we compiled a comparison over a large list of features and metrics from the four frameworks discussed above. They are shown below in a table-based format:","category":"page"},{"location":"comparison/#","page":"ABM Framework Comparison","title":"ABM Framework Comparison","text":"(Image: Table 1) (Image: Table 1 continued)","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/diffeq.jl\"","category":"page"},{"location":"examples/diffeq/#Integrating-Agents.jl-with-DifferentialEquations.jl-1","page":"DifferentialEquations.jl","title":"Integrating Agents.jl with DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Leveraging other best-in-class packages from the Julia ecosystem is one of the many strengths Agents.jl provides over alternative ABMs.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The DifferentialEquations.jl package is one excellent example. Here, we provide a few ways of leveraging DifferentialEquations to solve agent based models in an efficient and performant manner, whilst mitigating stability issues one may encounter.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"It is common in discrete time step tools (such as Agents) to also discretise equations required for obtaining solutions. In the following example, we use the forward Euler method to discretise a logistic function","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"fracmathrmdsmathrmdt = s left(1-fracs120right) - h","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"into","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"s_t+1 = s_t + s_t (1-s_t120)-h","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"In this example, s denotes some fish stock that increases over time until a maximum population (e.g. 120 here) is met, with the additional property that a harvest (h) may also remove some population (we also assume a timestep of 1 normalised unit to simplify things).","category":"page"},{"location":"examples/diffeq/#Problem-setup-1","page":"DifferentialEquations.jl","title":"Problem setup","text":"","category":"section"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Let's build a fishing community with fishers, each with differing methods and experience, culminating in a variety of competence when it comes to actually catching fish.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"using Agents\nusing Distributions\nusing CairoMakie\nCairoMakie.activate!() # hide\nusing Random # hide\n\n@agent Fisher NoSpaceAgent begin\n    id::Int\n    competence::Int\n    yearly_catch::Float64\nend\n\nfunction agent_step!(agent, model)\n    # Make sure we sample from the fish distribution\n    agent.yearly_catch = rand(model.rng, Poisson(agent.competence))\nend\n\nfunction dstock(model)\n    # Only allow fishing if stocks are high enough\n    h = model.stock > model.min_threshold ? sum(a.yearly_catch for a in allagents(model)) :\n        0.0\n\n    model.stock * (1 - (model.stock / model.max_population)) - h\nend\n\nfunction model_step!(model)\n    model.stock += dstock(model)\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"These methods should be quite straightforward: each step of the model (agent_step!), every agent will catch some fish based on their competency. There are some safeguards in place to not allow fishers to totally deplete the stock, thus dstock checks the total yearly catch and only harvests if the population is above a minimal threshold (in a more complete example, one should set a flag to state that this year's catch exceeded the limit and regulate fishing next year, but we'll ignore this complexity for this example).","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Building this model is simple. Set some initial conditions for the stock, and add agents with some competence.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"function initialise(;\n    stock = 5.0, # Initial population of fish\n    max_population = 500.0, # Maximum value of fish stock\n    min_threshold = 60.0, # Regulate fishing if population drops below this value\n    nagents = 50,\n)\n    model = ABM(\n        Fisher;\n        properties = Dict(\n            :stock => stock,\n            :max_population => max_population,\n            :min_threshold => min_threshold,\n        ),\n    )\n    for _ in 1:nagents\n        add_agent!(\n            model,\n            # Competence level is a lognormal distribution between 1 and 5\n            floor(rand(model.rng, truncated(LogNormal(), 1, 6))),\n            # Yearly catch can start at 0\n            0.0,\n        )\n    end\n    model\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"We can now run the model and see how the fishery fairs over the next 20 years.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\n\nmodel = initialise()\n_, results = run!(model, agent_step!, model_step!, 20; mdata = [:stock])\n\nf = Figure(resolution = (600, 400))\nax =\n    f[1, 1] = Axis(\n        f,\n        xlabel = \"Year\",\n        ylabel = \"Stock\",\n        title = \"Fishery Inventory\",\n    )\nlines!(ax, results.stock, linewidth = 2, color = :blue)\nf","category":"page"},{"location":"examples/diffeq/#Add-in-some-bureaucracy-1","page":"DifferentialEquations.jl","title":"Add in some bureaucracy","text":"","category":"section"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"OK, so let's add in some annoyances for the fishers. Of course, they wish to go out and catch regularly, but regulators only want to do their job once a year! Since it's the regulators who will monitor the total stock condition and advise fishers as to whether or not they can continue fishing, a systematic blind spot is inadvertently introduced into the system. Yearly catch and regulation occur on one day a year, whilst the stock will of course grow on a daily basis.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"To achieve this, we extend the model like so:","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"function agent_step!(agent, model)\n    if model.tick % 365 == 0\n        agent.yearly_catch = rand(model.rng, Poisson(agent.competence))\n    end\nend\n\nfunction dstock(model)\n    # Only allow fishing if stocks are high enough\n    # (monitored yearly, so this will return 0 364 days of the year)\n    h = model.tick % 365 == 0 && model.stock > model.min_threshold ?\n        sum(a.yearly_catch for a in allagents(model)) : 0.0\n\n    model.stock * (1 - (model.stock / model.max_population)) - h\nend\n\nfunction model_step!(model)\n    model.tick += 1\n    model.stock += dstock(model)\nend\n\nfunction initialise(;\n    stock = 400.0, # Initial population of fish (lets move to an equilibrium position)\n    max_population = 500.0, # Maximum value of fish stock\n    min_threshold = 60.0, # Regulate fishing if population drops below this value\n    nagents = 50,\n)\n    model = ABM(\n        Fisher;\n        properties = Dict(\n            :stock => stock,\n            :max_population => max_population,\n            :min_threshold => min_threshold,\n            :tick => 0, # Time keeper in units of days\n        ),\n    )\n    for _ in 1:nagents\n        add_agent!(model, floor(rand(model.rng, truncated(LogNormal(), 1, 6))), 0.0)\n    end\n    model\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Now that our model is running with a daily timestep, we must extend the run length value, and we'll also start from a steady state population.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\nmodel = initialise()\nyearly(model, s) = s % 365 == 0\n_, results =\n    run!(model, agent_step!, model_step!, 20 * 365; mdata = [:stock], when = yearly)\n\nf = Figure(resolution = (600, 400))\nax =\n    f[1, 1] = Axis(\n        f,\n        xlabel = \"Year\",\n        ylabel = \"Stock\",\n        title = \"Fishery Inventory\",\n    )\nlines!(ax, results.stock, linewidth = 2, color = :blue)\nf","category":"page"},{"location":"examples/diffeq/#Baseline-benchmark-1","page":"DifferentialEquations.jl","title":"Baseline benchmark","text":"","category":"section"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Lets get a baseline performance result for our model.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"using BenchmarkTools\n\nRandom.seed!(6549) #hide\n@btime Agents.step!(model, agent_step!, model_step!, 20 * 365) setup =\n    (model = initialise())","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"So this is fairly quick since the model is a simple one, but it's certainly not as efficient as it could be. We calculate the stock value every single day, since the forward Eulerian method requires us to, so it can evolve correctly. In addition to this, Eulerian expansion introduces uncertainty into our results, which is tied to the choice of step size. For accurate results, one should never really use this approximate method - although it is almost ubiquitous throughout contemporary research code. For a thorough exposé on this, have a read of Why you shouldn't use Eulers method to solve ODEs.","category":"page"},{"location":"examples/diffeq/#Coupling-DifferentialEquations.jl-to-Agents.jl-1","page":"DifferentialEquations.jl","title":"Coupling DifferentialEquations.jl to Agents.jl","text":"","category":"section"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Lets therefore modify our system to solve the logistic equation in a continuous context, but discretely monitor and harvest.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"import OrdinaryDiffEq\n\nfunction agent_diffeq_step!(agent, model)\n    agent.yearly_catch = rand(model.rng, Poisson(agent.competence))\nend\n\nfunction model_diffeq_step!(model)\n    # We step 364 days with this call.\n    OrdinaryDiffEq.step!(model.i, 364.0, true)\n    # Only allow fishing if stocks are high enough\n    model.i.p[2] =\n        model.i.u[1] > model.min_threshold ? sum(a.yearly_catch for a in allagents(model)) :\n        0.0\n    # Notify the integrator that conditions may be altered\n    OrdinaryDiffEq.u_modified!(model.i, true)\n    # Then apply our catch modifier\n    OrdinaryDiffEq.step!(model.i, 1.0, true)\n    # Store yearly stock in the model for plotting\n    model.stock = model.i.u[1]\n    # And reset for the next year\n    model.i.p[2] = 0.0\n    OrdinaryDiffEq.u_modified!(model.i, true)\nend\n\nfunction initialise_diffeq(;\n    stock = 400.0, # Initial population of fish (lets move to an equilibrium position)\n    max_population = 500.0, # Maximum value of fish stock\n    min_threshold = 60.0, # Regulate fishing if population drops below this value\n    nagents = 50,\n)\n\n    function fish_stock!(ds, s, p, t)\n        max_population, h = p\n        ds[1] = s[1] * (1 - (s[1] / max_population)) - h\n    end\n    prob =\n        OrdinaryDiffEq.ODEProblem(fish_stock!, [stock], (0.0, Inf), [max_population, 0.0])\n    integrator = OrdinaryDiffEq.init(prob, OrdinaryDiffEq.Tsit5(); advance_to_tstop = true)\n\n    model = ABM(\n        Fisher;\n        properties = Dict(\n            :stock => stock,\n            :max_population => max_population,\n            :min_threshold => min_threshold,\n            :i => integrator, # The OrdinaryDiffEq integrator\n        ),\n    )\n    for _ in 1:nagents\n        add_agent!(model, floor(rand(model.rng, truncated(LogNormal(), 1, 6))), 0.0)\n    end\n    model\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Notice that we've reverted back to a yearly rather than daily timestep here, since the ODE solver is now in charge of evolving the logistic function forward. We've used the integrator interface to achieve this.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Note that we use OrdinaryDiffEq here, which is a component of DifferentialEquations. Users may switch this to any subcomponent of the DifferentialEquations ecosystem, or use DifferentialEquations directly. Since we don't need other components for this example, we'll stick with the subcomponent but speak in general terms since the packages are interchangable in this context.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"This implementation uses import to explicitly identify which functions are from DifferentialEquations and not Agents. However, since both Agents and DifferentialEquations provide a step! function, each use must be qualified explicitly if one were to choose to bring all of DifferentialEquations into scope via the using keyword.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\nmodeldeq = initialise_diffeq()\n_, resultsdeq = run!(modeldeq, agent_diffeq_step!, model_diffeq_step!, 20; mdata = [:stock])\n\nf = Figure(resolution = (600, 400))\nax =\n    f[1, 1] = Axis(\n        f,\n        xlabel = \"Year\",\n        ylabel = \"Stock\",\n        title = \"Fishery Inventory\",\n    )\nlines!(ax, resultsdeq.stock, linewidth = 2, color = :blue)\nf","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The small complexity addition yields us a generous speed up of around 4.5x.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\n@btime Agents.step!(model, agent_diffeq_step!, model_diffeq_step!, 20) setup =\n    (model = initialise_diffeq())","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Digging into the results a little more, we can see that the DifferentialEquations solver did not need to solve the logistic equation at every agent step to achieve a stable solution for us:","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"length(modeldeq.i.sol.t)","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"365 * 20 > length(modeldeq.i.sol.t)","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"With other initial conditions, there's the possibility that this may not be the case. When this occurs, these additional samples provide mathematical guarantees that the results are accurate (to a given tolerance), which is a safeguard not possible for our Euler example.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Compare our two results directly, both start with the same random seed and evolve in precisely the same manner:","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"f = Figure(resolution = (600, 400))\nax =\n    f[1, 1] = Axis(\n        f,\n        xlabel = \"Year\",\n        ylabel = \"Stock\",\n        title = \"Fishery Inventory\",\n    )\nlineE = lines!(ax, results.stock, linewidth = 2, color = :blue)\nlineTS = lines!(ax, resultsdeq.stock, linewidth = 2, color = :red)\nleg = f[1, end+1] = Legend(f, [lineE, lineTS], [\"Euler\", \"TSit5\"])\nf","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"That's an average discrepancy of 30 fish! Optimising the step size in the Euler method can close this gap, but this is yet more analysis overhead we'd prefer to avoid by using better solutions.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"In addition, the ODE solver will be faster most of the time, regardless of how many steps it needs to take. If not, there are other, more effective solvers that can be used for your particular case.","category":"page"},{"location":"examples/diffeq/#Coupling-Agents.jl-to-DifferentialEquations.jl-1","page":"DifferentialEquations.jl","title":"Coupling Agents.jl to DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Perhaps you're more familiar to the DifferentialEquations solve interface and you're new to Agents?","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"We can also couple the two systems the other way. Let's use callbacks to handle the agent based aspects of our problem.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"function agent_cb_step!(agent, model)\n    agent.yearly_catch = rand(model.rng, Poisson(agent.competence))\nend\n\nfunction initialise_cb(; min_threshold = 60.0, nagents = 50)\n    model = ABM(Fisher; properties = Dict(:min_threshold => min_threshold))\n\n    for _ in 1:nagents\n        add_agent!(model, floor(rand(model.rng, truncated(LogNormal(), 1, 6))), 0.0)\n    end\n    model\nend\n\nRandom.seed!(759) #hide\nmodelcb = initialise_cb()","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"That's it for the Agents side of things! Now to build the ODE.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"import DiffEqCallbacks\n\nfunction fish!(integrator, model)\n    integrator.p[2] = integrator.u[1] > model.min_threshold ?\n        sum(a.yearly_catch for a in allagents(model)) : 0.0\n    Agents.step!(model, agent_cb_step!, 1)\nend\n\nfunction fish_stock!(ds, s, p, t)\n    max_population, h = p\n    ds[1] = s[1] * (1 - (s[1] / max_population)) - h\nend\n\ntspan = (0.0, 20.0 * 365.0)\nconst initial_stock = 400.0\nconst max_population = 500.0\n\nprob = OrdinaryDiffEq.ODEProblem(fish_stock!, [initial_stock], tspan, [max_population, 0.0])\n\n# Each Dec 31st, we call fish! that adds our catch modifier to the stock, and steps the model\nfish = DiffEqCallbacks.PeriodicCallback(i -> fish!(i, modelcb), 364)\n# Stocks are replenished again\nreset = DiffEqCallbacks.PeriodicCallback(i -> i.p[2] = 0.0, 365)\n\nsol = OrdinaryDiffEq.solve(\n    prob,\n    OrdinaryDiffEq.Tsit5();\n    callback = OrdinaryDiffEq.CallbackSet(fish, reset),\n)\ndiscrete = vcat(sol(0:365:(365 * 20))[:,:]...)\nf = Figure(resolution = (600, 400))\nax =\n    f[1, 1] = Axis(\n        f,\n        xlabel = \"Year\",\n        ylabel = \"Stock\",\n        title = \"Fishery Inventory\",\n    )\nlines!(ax, discrete, linewidth = 2, color = :blue)\nf","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The results are different here, since the construction of this version and the one above are quite different and cannot be randomly seeded in the same manner.","category":"page"},{"location":"examples/diffeq/#","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"However, as you can see, it is for the most part just a re-arranged implementation of the integrator method - giving users flexibility in their architecture choices.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/sir.jl\"","category":"page"},{"location":"examples/sir/#SIR-model-for-the-spread-of-COVID-19-1","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../covid_evolution.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"This example illustrates how to use GraphSpace and how to model agents on an graph (network) where the transition probabilities between each node (position) is not constant.","category":"page"},{"location":"examples/sir/#SIR-model-1","page":"SIR model for the spread of COVID-19","title":"SIR model","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"A SIR model tracks the ratio of Susceptible, Infected, and Recovered individuals within a population. Here we add one more category of individuals: those who are infected, but do not know it. Transmission rate for infected and diagnosed individuals is lower than infected and undetected. We also allow a fraction of recovered individuals to catch the disease again, meaning that recovering the disease does not bring full immunity.","category":"page"},{"location":"examples/sir/#Model-parameters-1","page":"SIR model for the spread of COVID-19","title":"Model parameters","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Here are the model parameters, some of which have default values.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Ns: a vector of population sizes per city. The amount of cities is just C=length(Ns).\nβ_und: a vector for transmission probabilities β of the infected but undetected per city. Transmission probability is how many susceptible are infected per day by an infected individual. If social distancing is practiced, this number decreases.\nβ_det: an array for transmission probabilities β of the infected and detected per city. If hospitals are full, this number increases.\ninfection_period = 30: how many days before a person dies or recovers.\ndetection_time = 14: how many days before an infected person is detected.\ndeath_rate = 0.02: the probability that the individual will die after the infection_period.\nreinfection_probability = 0.05: The probability that a recovered person can get infected again.\nmigration_rates: A matrix of migration probability per individual per day from one city to another.\nIs = [zeros(C-1)..., 1]: An array for initial number of infected but undetected people per city. This starts as only one infected individual in the last city.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Notice that Ns, β, Is all need to have the same length, as they are numbers for each city. We've tried to add values to the infection parameters similar to the ones you would hear on the news about COVID-19.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The good thing with Agent based models is that you could easily extend the model we implement here to also include age as an additional property of each agent. This makes ABMs flexible and suitable for research of virus spreading.","category":"page"},{"location":"examples/sir/#Making-the-model-in-Agents.jl-1","page":"SIR model for the spread of COVID-19","title":"Making the model in Agents.jl","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We start by defining the PoorSoul agent type and the ABM","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using Agents, Random\nusing Agents.DataFrames, Agents.Graphs\nusing Distributions: Poisson, DiscreteNonParametric\nusing DrWatson: @dict\nusing CairoMakie\nCairoMakie.activate!() # hide\n\n@agent PoorSoul GraphAgent begin\n    days_infected::Int  # number of days since is infected\n    status::Symbol  # 1: S, 2: I, 3:R\nend\n\nfunction model_initiation(;\n    Ns,\n    migration_rates,\n    β_und,\n    β_det,\n    infection_period = 30,\n    reinfection_probability = 0.05,\n    detection_time = 14,\n    death_rate = 0.02,\n    Is = [zeros(Int, length(Ns) - 1)..., 1],\n    seed = 0,\n)\n\n    rng = MersenneTwister(seed)\n    @assert length(Ns) ==\n    length(Is) ==\n    length(β_und) ==\n    length(β_det) ==\n    size(migration_rates, 1) \"length of Ns, Is, and B, and number of rows/columns in migration_rates should be the same \"\n    @assert size(migration_rates, 1) == size(migration_rates, 2) \"migration_rates rates should be a square matrix\"\n\n    C = length(Ns)\n    # normalize migration_rates\n    migration_rates_sum = sum(migration_rates, dims = 2)\n    for c in 1:C\n        migration_rates[c, :] ./= migration_rates_sum[c]\n    end\n\n    properties = @dict(\n        Ns,\n        Is,\n        β_und,\n        β_det,\n        β_det,\n        migration_rates,\n        infection_period,\n        infection_period,\n        reinfection_probability,\n        detection_time,\n        C,\n        death_rate\n    )\n    space = GraphSpace(complete_digraph(C))\n    model = ABM(PoorSoul, space; properties, rng)\n\n    # Add initial individuals\n    for city in 1:C, n in 1:Ns[city]\n        ind = add_agent!(city, model, 0, :S) # Susceptible\n    end\n    # add infected individuals\n    for city in 1:C\n        inds = ids_in_position(city, model)\n        for n in 1:Is[city]\n            agent = model[inds[n]]\n            agent.status = :I # Infected\n            agent.days_infected = 1\n        end\n    end\n    return model\nend","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We will make a function that starts a model with C number of cities, and creates the other parameters automatically by attributing some random values to them. You could directly use the above constructor and specify all Ns, β, etc. for a given set of cities.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"All cities are connected with each other, while it is more probable to travel from a city with small population into a city with large population.","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using LinearAlgebra: diagind\n\nfunction create_params(;\n    C,\n    max_travel_rate,\n    infection_period = 30,\n    reinfection_probability = 0.05,\n    detection_time = 14,\n    death_rate = 0.02,\n    Is = [zeros(Int, C - 1)..., 1],\n    seed = 19,\n)\n\n    Random.seed!(seed)\n    Ns = rand(50:5000, C)\n    β_und = rand(0.3:0.02:0.6, C)\n    β_det = β_und ./ 10\n\n    Random.seed!(seed)\n    migration_rates = zeros(C, C)\n    for c in 1:C\n        for c2 in 1:C\n            migration_rates[c, c2] = (Ns[c] + Ns[c2]) / Ns[c]\n        end\n    end\n    maxM = maximum(migration_rates)\n    migration_rates = (migration_rates .* max_travel_rate) ./ maxM\n    migration_rates[diagind(migration_rates)] .= 1.0\n\n    params = @dict(\n        Ns,\n        β_und,\n        β_det,\n        migration_rates,\n        infection_period,\n        reinfection_probability,\n        detection_time,\n        death_rate,\n        Is\n    )\n\n    return params\nend\n\nparams = create_params(C = 8, max_travel_rate = 0.01)\nmodel = model_initiation(; params...)","category":"page"},{"location":"examples/sir/#SIR-Stepping-functions-1","page":"SIR model for the spread of COVID-19","title":"SIR Stepping functions","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Now we define the functions for modelling the virus spread in time","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"function agent_step!(agent, model)\n    migrate!(agent, model)\n    transmit!(agent, model)\n    update!(agent, model)\n    recover_or_die!(agent, model)\nend\n\nfunction migrate!(agent, model)\n    pid = agent.pos\n    d = DiscreteNonParametric(1:(model.C), model.migration_rates[pid, :])\n    m = rand(model.rng, d)\n    if m ≠ pid\n        move_agent!(agent, m, model)\n    end\nend\n\nfunction transmit!(agent, model)\n    agent.status == :S && return\n    rate = if agent.days_infected < model.detection_time\n        model.β_und[agent.pos]\n    else\n        model.β_det[agent.pos]\n    end\n\n    d = Poisson(rate)\n    n = rand(model.rng, d)\n    n == 0 && return\n\n    for contactID in ids_in_position(agent, model)\n        contact = model[contactID]\n        if contact.status == :S ||\n           (contact.status == :R && rand(model.rng) ≤ model.reinfection_probability)\n            contact.status = :I\n            n -= 1\n            n == 0 && return\n        end\n    end\nend\n\nupdate!(agent, model) = agent.status == :I && (agent.days_infected += 1)\n\nfunction recover_or_die!(agent, model)\n    if agent.days_infected ≥ model.infection_period\n        if rand(model.rng) ≤ model.death_rate\n            kill_agent!(agent, model)\n        else\n            agent.status = :R\n            agent.days_infected = 0\n        end\n    end\nend","category":"page"},{"location":"examples/sir/#Example-animation-1","page":"SIR model for the spread of COVID-19","title":"Example animation","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"At the moment abmplot does not plot GraphSpaces, but we can still utilize the ABMObservable. We do not need to collect data here, only the current status of the model will be used in visualization","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using InteractiveDynamics\nusing CairoMakie\nCairoMakie.activate!() # hide\nabmobs = ABMObservable(model; agent_step!)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We then initialize elements that are lifted observables from abmobs:","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"infected_fraction(m, x) = count(m[id].status == :I for id in x) / length(x)\ninfected_fractions(m) = [infected_fraction(m, ids_in_position(p, m)) for p in positions(m)]\nfracs = lift(infected_fractions, abmobs.model)\ncolor = lift(fs -> [cgrad(:inferno)[f] for f in fs], fracs)\ntitle = lift(\n    (s, m) -> \"step = $(s), infected = $(round(Int, 100infected_fraction(m, allids(m))))%\",\n    abmobs.s, abmobs.model\n)","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"And lastly we use them to plot things in a figure","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"fig = Figure(resolution = (600, 400))\nax = Axis(fig[1, 1]; title, xlabel = \"City\", ylabel = \"Population\")\nbarplot!(ax, model.Ns; strokecolor = :black, strokewidth = 1, color)\nfig","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Now we can even make an animation of it","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"record(fig, \"covid_evolution.mp4\"; framerate = 5) do io\n    for j in 1:30\n        recordframe!(io)\n        Agents.step!(abmobs, 1)\n    end\n    recordframe!(io)\nend","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../covid_evolution.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"One can really see \"explosive growth\" in this animation. Things look quite calm for a while and then suddenly supermarkets have no toilet paper anymore!","category":"page"},{"location":"examples/sir/#Exponential-growth-1","page":"SIR model for the spread of COVID-19","title":"Exponential growth","text":"","category":"section"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We now run the model and collect data. We define two useful functions for data collection:","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)\nnothing # hide","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"and then collect data","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"model = model_initiation(; params...)\n\nto_collect = [(:status, f) for f in (infected, recovered, length)]\ndata, _ = run!(model, agent_step!, 100; adata = to_collect)\ndata[1:10, :]","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We now plot how quantities evolved in time to show the exponential growth of the virus","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"N = sum(model.Ns) # Total initial population\nx = data.step\nfig = Figure(resolution = (600, 400))\nax = fig[1, 1] = Axis(fig, xlabel = \"steps\", ylabel = \"log10(count)\")\nli = lines!(ax, x, log10.(data[:, aggname(:status, infected)]), color = :blue)\nlr = lines!(ax, x, log10.(data[:, aggname(:status, recovered)]), color = :red)\ndead = log10.(N .- data[:, aggname(:status, length)])\nld = lines!(ax, x, dead, color = :green)\nLegend(fig[1, 2], [li, lr, ld], [\"infected\", \"recovered\", \"dead\"])\nfig","category":"page"},{"location":"examples/sir/#","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The exponential growth is clearly visible since the logarithm of the number of infected increases linearly, until everyone is infected.","category":"page"},{"location":"models/#Predefined-Models-1","page":"Predefined Models","title":"Predefined Models","text":"","category":"section"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"Predefined agent based models exist in the Models submodule in the form of functions that return model, agent_step!, model_step! when called.","category":"page"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"They are accessed like:","category":"page"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"using Agents\nmodel, agent_step!, model_step! = Models.flocking(; kwargs...)","category":"page"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"The Examples section of the docs outline how to use and interact with each model.","category":"page"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"warn: Warn\nPlease notice that the predefined models are a convenience and  not considered part of the public API. This means that they can have breaking changes between versions of Agents.jl without warning.","category":"page"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"So far, the predefined models that exist in the Models sub-module are:","category":"page"},{"location":"models/#","page":"Predefined Models","title":"Predefined Models","text":"Modules = [Models]\nOrder   = [:function]","category":"page"},{"location":"models/#Agents.Models.flocking-Tuple{}","page":"Predefined Models","title":"Agents.Models.flocking","text":"flocking(;\n    n_birds = 100,\n    speed = 1.0,\n    cohere_factor = 0.25,\n    separation = 4.0,\n    separate_factor = 0.25,\n    match_factor = 0.01,\n    visual_distance = 5.0,\n    extent = (100, 100),\n    spacing = visual_distance / 1.5\n)\n\nSame as in Flocking model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.schelling-Tuple{}","page":"Predefined Models","title":"Agents.Models.schelling","text":"schelling(;\n    numagents = 320,\n    griddims = (20, 20),\n    min_to_be_happy = 3,\n)\n\nSame as in Schelling's segregation model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.sir-Tuple{}","page":"Predefined Models","title":"Agents.Models.sir","text":"sir(;\n    C = 8,\n    max_travel_rate = 0.01,\n    Ns = rand(50:5000, C),\n    β_und = rand(0.3:0.02:0.6, C),\n    β_det = β_und ./ 10,\n    infection_period = 30,\n    reinfection_probability = 0.05,\n    detection_time = 14,\n    death_rate = 0.02,\n    Is = [zeros(Int, length(Ns) - 1)..., 1],\n    seed = 19,\n)\n\nSame as in SIR model for the spread of COVID-19.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.zombies-Tuple{}","page":"Predefined Models","title":"Agents.Models.zombies","text":"zombies(; seed = 1234)\n\nSame as in the Zombie Outbreak example.\n\n\n\n\n\n","category":"method"},{"location":"performance_tips/#Performance-Tips-1","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Here we list various tips that will help users make faster ABMs with Agents.jl. Please do read through Julia's own Performance Tips section as well, as it will help you write performant code in general.","category":"page"},{"location":"performance_tips/#Benchmark-your-stepping-functions!-1","page":"Performance Tips","title":"Benchmark your stepping functions!","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"By design Agents.jl allows users to create their own arbitrary stepping functions that control the time evolution of the model. This provides maximum freedom on creating an ABM. However, it has the downside that Agents.jl cannot help you with the performance of the stepping functions themselves. So, be sure that you benchmark your code, and you follow Julia's Performance Tips!","category":"page"},{"location":"performance_tips/#Take-advantage-of-parallelization-1","page":"Performance Tips","title":"Take advantage of parallelization","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"In Agents.jl we offer native parallelization over the full model evolution and data collection loop. This is done by providing a parallel = true keyword argument to ensemblerun! or paramscan. This uses distributed computing via Julia's Distributed module. For that, start Julia with julia -p n where n is the number of processing cores or add processes from within a Julia session using:","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"using Distributed\naddprocs(4)","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"For distributed computing to work, all definitions must be preceded with @everywhere, e.g.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"using Distributed\n@everywhere using Agents\n@everywhere function initialized\n@everywhere mutable struct SchellingAgent(...) ...\n@everywhere function agent_step!(...) = ...\n@everywhere adata = ...","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"To avoid having @everywhere in everywhere, you can use the @everywhere begin...end block, e.g.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"@everywhere begin\n    using Agents\n    using Random\n    using Statistics: mean\n    using DataFrames\nend","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"To further reduce the use of @everywhere you can move the core definition of your model in a file, e.g. in schelling.jl:","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"using Agents\nfunction initialize(...) ...\nmutable struct SchellingAgent(...) ...\nfunction agent_step!(...) = ...","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"then include the file with everywhere:","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"@everywhere include(\"schelling.jl\")","category":"page"},{"location":"performance_tips/#In-model-parallelization-1","page":"Performance Tips","title":"In-model parallelization","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Julia provides several tools for parallelization and distributed computing. Notice that we cannot help you with parallelizing the actual model evolution via the agent- and model-stepping functions. This is something you must do manually, as depending on the model, parallelization might not be possible at all due to e.g. the access and overwrite of the same memory location (writing on same agent in different threads or killing/creating agents). If your model evolution satisfies the criteria allowing parallelism, the simplest way to do it is using Julia's @threads or @spawn macros.","category":"page"},{"location":"performance_tips/#Use-Type-stable-containers-for-the-model-properties-1","page":"Performance Tips","title":"Use Type-stable containers for the model properties","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"This tip is actually not related to Agents.jl and you will also read about it in Julia's abstract container tips. In general, avoid containers whose values are of unknown type. E.g.:","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"using Agents\nstruct MyAgent <: AbstractAgent\n\tid::Int\nend\nproperties = Dict(:par1 => 1, :par2 => 1.0, :par3 => \"Test\")\nmodel = ABM(MyAgent; properties = properties)\nmodel_step!(model) = begin\n\ta = model.par1 * model.par2\nend","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"is a bad idea, because of:","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"@code_warntype model_step!(model)","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Variables\n  #self#::Core.Compiler.Const(model_step!, false)\n  model::AgentBasedModel{Nothing,MyAgent,typeof(fastest),Dict{Symbol,Any},Random.MersenneTwister}\n  a::Any\n\nBody::Any\n1 ─ %1 = Base.getproperty(model, :par1)::Any\n│   %2 = Base.getproperty(model, :par2)::Any\n│   %3 = (%1 * %2)::Any\n│        (a = %3)\n└──      return %3","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"which makes the model stepping function have type instability due to the model properties themselves being type unstable.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"The solution is to use a Dictionary for model properties only when all values are of the same type, or to use a custom mutable struct for model properties where each property is type annotated, e.g:","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Base.@kwdef mutable struct Parameters\n\tpar1::Int = 1\n\tpar2::Float64 = 1.0\n\tpar3::String = \"Test\"\nend\n\nproperties = Parameters()\nmodel = ABM(MyAgent; properties = properties)","category":"page"},{"location":"performance_tips/#Don't-use-agents-to-represent-a-spatial-property-1","page":"Performance Tips","title":"Don't use agents to represent a spatial property","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"In some cases there is some property that exists in every point of a discrete space, e.g. the amount of grass, or whether there is grass or not, or whether there is a tree there that is burning or not. This most typically happens when one simulates a cellular automaton.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"It might be tempting to represent this property as a specific type of agent like Grass or Tree, and add an instance of this agent in every position of the GridSpace. However, in Agents.jl this is not necessary and a much more performant approach can be followed. Specifically, you can represent this property as a standard Julia Array that is a property of the model. This will typically lead to a 5-10 fold increase in performance.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"For an example of how this is done, see the Forest fire model, which is a cellular automaton that has no agents in it, or the Daisyworld model, which has both agents as well as a spatial property represented by an Array.","category":"page"},{"location":"performance_tips/#Avoid-Unions-of-many-different-agent-types-(temporary!)-1","page":"Performance Tips","title":"Avoid Unions of many different agent types (temporary!)","text":"","category":"section"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Due to the way Julia's type system works, and the fact that agents are grouped in a dictionary mapping IDs to agent instances, using multiple types for different agents always creates a performance hit because it leads to type instability.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Thankfully, due to some performance enhancements in Base Julia, unions of up to three different Agent types do not suffer much. You can see this by running the test/performance/variable_agent_types_simple_dynamics.jl file, which benchmarks the time to run a model that will do exactly the same amount of numeric operations, but each time subdividing it among an increasing number of agent types. Its output is","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"using Agents\nx = pathof(Agents)\nt = joinpath(dirname(dirname(x)), \"test\", \"performance\", \"variable_agent_types_simple_dynamics.jl\")\ninclude(t)","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"The result is that having many types (here 15 different types) makes the code about 5-6 times slower.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"Notice that this is a temporary problem! In the future we plan to re-work Agents.jl internals regarding multi-agent models and deal with this performance hit without requiring the user to do something differently.","category":"page"},{"location":"performance_tips/#","page":"Performance Tips","title":"Performance Tips","text":"At the moment, if you want to use many different agent types, you can try including all properties all types should have in one type. You can specify what \"type\" of agent it is via including a field type or kind whose value is a symbol: :wolf, :sheep, :grass. Properties that should only belong to one kind of agent could be initialized with a \"null\" value for the other kinds. This will increase the amount of memory used by the model, as all agent instances will contain more data than necessary, so you need to check yourself if the performance gain due to type stability makes up for it.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/schelling.jl\"","category":"page"},{"location":"examples/schelling/#Schelling's-segregation-model-1","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../schelling.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"In this introductory example we parallelize the main Tutorial while building the following definition of Schelling's segregation model:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Agents belong to one of two groups (0 or 1).\nThe agents live in a two-dimensional grid. Only one agent per position is allowed.\nFor each agent we care about finding all of its 8 nearest neighbors (cardinal and diagonal directions). To do this, we will create a GridSpaceSingle with a Chebyshev metric, and when searching for nearby agents we will use a radius of 1 (which is also the default). This leads to 8 neighboring positions per position (except at the edges of the grid).\nIf an agent has at least k=3 neighbors belonging to the same group, then it is happy.\nIf an agent is unhappy, it keeps moving to new locations until it is happy, while respecting the 1-agent-per-position rule.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 3/8 of neighbors to be in the same group) could still lead to total segregation of neighborhoods.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"This model is also available as Models.schelling.","category":"page"},{"location":"examples/schelling/#Creating-a-space-1","page":"Schelling's segregation model","title":"Creating a space","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Agents\n\nspace = GridSpaceSingle((10, 10); periodic = false)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that by default the GridSpaceSingle has metric = Chebyshev(), which is what we want. Agents existing in this type of space must have a position field that is a NTuple{2, Int}. We ensure this below by using @agent along with the minimal agent for grid spaces, GridAgent{2}.","category":"page"},{"location":"examples/schelling/#Defining-the-agent-type-1","page":"Schelling's segregation model","title":"Defining the agent type","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"@agent SchellingAgent GridAgent{2} begin\n    mood::Bool # whether the agent is happy in its position. (true = happy)\n    group::Int # The group of the agent, determines mood as it interacts with neighbors\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We added two more fields for this model, namely a mood field which will store true for a happy agent and false for an unhappy one, and an group field which stores 0 or 1 representing two groups.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Do notice that GridAgent{2} attributed the id::Int field, and the pos::NTuple{2, Int} field to our agent type","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"for (name, type) in zip(fieldnames(SchellingAgent), fieldtypes(SchellingAgent))\n    println(name, \"::\", type)\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"All these fields can be accessed during the simulation, but it is important to keep in mind that id must never be modified, and pos must be modified only through valid API functions such as move_agent!.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"You can think of the @agent macro defining the following expression:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"mutable struct SchellingAgent <: AbstractAgent\n    id::Int             # The identifier number of the agent\n    pos::NTuple{2, Int} # The x, y location of the agent on a 2D grid\n    mood::Bool          # ...\n    group::Int          # ...\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"However, the reason to use @agent instead of hand-coding the 'mandatory' fields is that it allows us to (1) ensure that some fields are constants, (2) add additional fields that may be necessary but not really part of the public API, and hence set internally by Agents.jl when using various API functions.","category":"page"},{"location":"examples/schelling/#Creating-an-ABM-1","page":"Schelling's segregation model","title":"Creating an ABM","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"To make our model we follow the instructions of AgentBasedModel. We also want to include a property min_to_be_happy in our model, and so we have:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"properties = Dict(:min_to_be_happy => 3)\nschelling = ABM(SchellingAgent, space; properties)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Here we used the default scheduler (which is also the fastest one) to create the model. We could instead try to activate the agents according to their property :group, so that all agents of group 1 act first. We would then use the scheduler Schedulers.ByProperty like so:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"schelling2 = ABM(\n    SchellingAgent,\n    space;\n    properties = properties,\n    scheduler = Schedulers.ByProperty(:group),\n)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that Schedulers.ByProperty accepts an argument and returns a struct, which is why we didn't just give Schedulers.ByProperty to scheduler.","category":"page"},{"location":"examples/schelling/#Creating-the-ABM-through-a-function-1","page":"Schelling's segregation model","title":"Creating the ABM through a function","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Here we put the model instantiation in a function so that it will be easy to recreate the model and change its parameters.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"In addition, inside this function, we populate the model with some agents. We also change the scheduler to Schedulers.Randomly. Because the function is defined based on keywords, it will be of further use in paramscan below.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Random # for reproducibility\nfunction initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3, seed = 125)\n    space = GridSpaceSingle(griddims, periodic = false)\n    properties = Dict(:min_to_be_happy => min_to_be_happy)\n    rng = Random.MersenneTwister(seed)\n    model = ABM(\n        SchellingAgent, space;\n        properties, rng, scheduler = Schedulers.Randomly()\n    )\n\n    # populate the model with agents, adding equal amount of the two types of agents\n    # at random positions in the model\n    for n in 1:numagents\n        agent = SchellingAgent(n, (1, 1), false, n < numagents / 2 ? 1 : 2)\n        add_agent_single!(agent, model)\n    end\n    return model\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that the position that an agent is initialized does not matter in this example. This is because we use add_agent_single!, which places the agent in a random, empty location on the grid, thus updating its position.","category":"page"},{"location":"examples/schelling/#Defining-a-step-function-1","page":"Schelling's segregation model","title":"Defining a step function","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Finally, we define a step function to determine what happens to an agent when activated. For the purpose of this implementation of Schelling's segregation model, we only need an agent step function and not a model stepping function.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"function agent_step!(agent, model)\n    minhappy = model.min_to_be_happy\n    count_neighbors_same_group = 0\n    # For each neighbor, get group and compare to current agent's group\n    # and increment `count_neighbors_same_group` as appropriately.\n    # Here `nearby_agents` (with default arguments) will provide an iterator\n    # over the nearby agents one grid point away, which are at most 8.\n    for neighbor in nearby_agents(agent, model)\n        if agent.group == neighbor.group\n            count_neighbors_same_group += 1\n        end\n    end\n    # After counting the neighbors, decide whether or not to move the agent.\n    # If count_neighbors_same_group is at least the min_to_be_happy, set the\n    # mood to true. Otherwise, move the agent to a random position, and set\n    # mood to false.\n    if count_neighbors_same_group ≥ minhappy\n        agent.mood = true\n    else\n        agent.mood = false\n        move_agent_single!(agent, model)\n    end\n    return\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"When defining agent_step!, we used some of the built-in functions of Agents.jl, such as nearby_positions that returns the neighboring position on which the agent resides, ids_in_position that returns the IDs of the agents on a given position, and move_agent_single! which moves agents to random empty position on the grid. A full list of built-in functions and their explanations are available in the API page.","category":"page"},{"location":"examples/schelling/#Stepping-the-model-1","page":"Schelling's segregation model","title":"Stepping the model","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Let's initialize the model with 370 agents on a 20 by 20 grid.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize()","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can advance the model one step","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"step!(model, agent_step!)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Or for three steps","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"step!(model, agent_step!, 3)","category":"page"},{"location":"examples/schelling/#Visualizing-the-data-1","page":"Schelling's segregation model","title":"Visualizing the data","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"There is a dedicated tutorial for visualization, animation, and interaction for agent based models. See Visualizations and Animations for Agent Based Models.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can use the abmplot function to plot the distribution of agents on a 2D grid at every generation, via the InteractiveDynamics.jl package and the Makie.jl plotting ecosystem.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Let's color the two groups orange and blue and make one a square and the other a circle.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using InteractiveDynamics\nusing CairoMakie # choosing a plotting backend\nCairoMakie.activate!() # hide\n\ngroupcolor(a) = a.group == 1 ? :blue : :orange\ngroupmarker(a) = a.group == 1 ? :circle : :rect\nfigure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure # returning the figure displays it","category":"page"},{"location":"examples/schelling/#Animating-the-evolution-1","page":"Schelling's segregation model","title":"Animating the evolution","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"The function abmvideo can be used to save an animation of the ABM into a video. You could of course also explicitly use abmplot in a record loop for finer control over additional plot elements.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize();\nabmvideo(\n    \"schelling.mp4\", model, agent_step!;\n    ac = groupcolor, am = groupmarker, as = 10,\n    framerate = 4, frames = 20,\n    title = \"Schelling's segregation model\"\n)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../schelling.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/schelling/#Collecting-data-during-time-evolution-1","page":"Schelling's segregation model","title":"Collecting data during time evolution","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can use the run! function with keywords to run the model for multiple steps and collect values of our desired fields from every agent and put these data in a DataFrame object. We define a vector of Symbols for the agent fields that we want to collect as data","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"adata = [:pos, :mood, :group]\n\nmodel = initialize()\ndata, _ = run!(model, agent_step!, 5; adata)\ndata[1:10, :] # print only a few rows","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We could also use functions in adata, for example we can define","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"x(agent) = agent.pos[1]\nmodel = initialize()\nadata = [x, :mood, :group]\ndata, _ = run!(model, agent_step!, 5; adata)\ndata[1:10, :]","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"With the above adata vector, we collected all agent's data. We can instead collect aggregated data for the agents. For example, let's only get the number of happy individuals, and the average of the \"x\" (not very interesting, but anyway!)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Statistics: mean\nmodel = initialize();\nadata = [(:mood, sum), (x, mean)]\ndata, _ = run!(model, agent_step!, 5; adata)\ndata","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Other examples in the documentation are more realistic, with more meaningful collected data. Don't forget to use the function dataname to access the columns of the resulting dataframe by name.","category":"page"},{"location":"examples/schelling/#Launching-the-interactive-application-1","page":"Schelling's segregation model","title":"Launching the interactive application","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Given the definitions we have already created for a normally plotting or animating the ABM it is almost trivial to launch an interactive application for it, through the function abmexploration.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We define a dictionary that maps some model-level parameters to a range of potential values, so that we can interactively change them.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"parange = Dict(:min_to_be_happy => 0:8)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We also define the data we want to collect and interactively explore, and also some labels for them, for shorter names (since the defaults can get large)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"adata = [(:mood, sum), (x, mean)]\nalabels = [\"happy\", \"avg. x\"]\n\nmodel = initialize(; numagents = 300) # fresh model, noone happy","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using GLMakie # using a different plotting backend that enables interactive plots\n\nfigure, adf, mdf = abmexploration(\n    model, agent_step!, dummystep, parange;\n    ac = groupcolor, am = groupmarker, as = 10,\n    adata, alabels\n)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/agents/schelling_app.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/schelling/#Saving/loading-the-model-state-1","page":"Schelling's segregation model","title":"Saving/loading the model state","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"It is often useful to save a model after running it, so that multiple branching scenarios can be simulated from that point onwards. For example, once most of the population is happy, let's see what happens if some more agents occupy the empty cells. The new agents could all be of one group, or belong to a third, new, group. Simulating this needs multiple copies of the model. Agents.jl provides the functions AgentsIO.save_checkpoint and AgentsIO.load_checkpoint to save and load models to JLD2 files respectively.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"First, let's create a model with 200 agents and run it for 40 iterations.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"@eval Main __atexample__named__schelling = $(@__MODULE__) # hide\n\nmodel = initialize(numagents = 200, min_to_be_happy = 5, seed = 42)\nrun!(model, agent_step!, 40)\n\nfigure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Most of the agents have settled happily. Now, let's save the model.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"AgentsIO.save_checkpoint(\"schelling.jld2\", model)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Note that we can now leave the REPL, and come back later to run the model, right from where we left off.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = AgentsIO.load_checkpoint(\"schelling.jld2\"; scheduler = Schedulers.Randomly())","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Since functions are not saved, the scheduler has to be passed while loading the model. Let's now verify that we loaded back exactly what we saved.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"figure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For starters, let's see what happens if we add 100 more agents of group 1","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"for i in 1:100\n    agent = SchellingAgent(nextid(model), (1, 1), false, 1)\n    add_agent_single!(agent, model)\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Let's see what our model looks like now.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"figure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"And then run it for 40 iterations.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"run!(model, agent_step!, 40)\n\nfigure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"It looks like the agents eventually cluster again. What if the agents are of a new group? We can start by loading the model back in from the file, thus resetting the changes we made.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = AgentsIO.load_checkpoint(\"schelling.jld2\"; scheduler = Schedulers.Randomly())\n\nfor i in 1:100\n    agent = SchellingAgent(nextid(model), (1, 1), false, 3)\n    add_agent_single!(agent, model)\nend","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"To visualize the model, we need to redefine groupcolor and groupmarker to handle a third group.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"groupcolor(a) = (:blue, :orange, :green)[a.group]\ngroupmarker(a) = (:circle, :rect, :cross)[a.group]\n\nfigure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"The new agents are scattered randomly, as expected. Now let's run the model.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"run!(model, agent_step!, 40)\n\nfigure, _ = abmplot(model; ac = groupcolor, am = groupmarker, as = 10)\nfigure","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"The new agents also form their own clusters, despite being completely scattered. It's also interesting to note that there is minimal rearrangement among the existing groups. The new agents simply occupy the remaining space.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"rm(\"schelling.jld2\") # hide","category":"page"},{"location":"examples/schelling/#Ensembles-and-distributed-computing-1","page":"Schelling's segregation model","title":"Ensembles and distributed computing","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can run ensemble simulations and collect the output of every member in a single DataFrame. To that end we use the ensemblerun! function. The function accepts a Vector of ABMs, each (typically) initialized with a different seed and/or agent distribution. For example we can do","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"models = [initialize(seed = x) for x in rand(UInt8, 3)];\nnothing #hide","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"and then","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"adf, = ensemblerun!(models, agent_step!, dummystep, 5; adata)\nadf[(end - 10):end, :]","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"It is possible to run the ensemble in parallel. For that, we should start julia with julia -p n where n is the number of processing cores. Alternatively, we can define the number of cores from within a Julia session:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Distributed\naddprocs(4)","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For distributed computing to work, all definitions must be preceded with @everywhere, e.g.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Distributed\n@everywhere using Agents\n@everywhere @agent SchellingAgent ...\n@everywhere agent_step!(...) = ...","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Then we can tell the ensemblerun! function to run the ensemble in parallel using the keyword parallel = true:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"adf, = ensemblerun!(models, agent_step!, dummystep, 5; adata, parallel = true)","category":"page"},{"location":"examples/schelling/#Scanning-parameter-ranges-1","page":"Schelling's segregation model","title":"Scanning parameter ranges","text":"","category":"section"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We often are interested in the effect of different parameters on the behavior of an agent-based model. Agents.jl provides the function paramscan to automatically explore the effect of different parameter values.","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We have already defined our model initialization function as initialize. We now also define a processing function, that returns the percentage of happy agents:","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"happyperc(moods) = count(moods) / length(moods)\nadata = [(:mood, happyperc)]\n\nparameters = Dict(\n    :min_to_be_happy => collect(2:5), # expanded\n    :numagents => [200, 300],         # expanded\n    :griddims => (20, 20),            # not Vector = not expanded\n)\n\nadf, _ = paramscan(parameters, initialize; adata, agent_step!, n = 3)\nadf","category":"page"},{"location":"examples/schelling/#","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We nicely see that the larger :min_to_be_happy is, the slower the convergence to \"total happiness\".","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/../../../.julia/packages/InteractiveDynamics/q73Ef/docs/src/agents.jl\"","category":"page"},{"location":"agents_visualizations/#Visualizations-and-Animations-for-Agent-Based-Models-1","page":"Plotting and Interactivity","title":"Visualizations and Animations for Agent Based Models","text":"","category":"section"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"This page describes functions that can be used in conjunction with Agents.jl to animate and interact with agent based models.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"The animation at the start of the page is created using the code of this page, see below.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"The docs are built using versions:","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"using Pkg\nPkg.status([\"Agents\", \"InteractiveDynamics\", \"CairoMakie\"];\n    mode = PKGMODE_MANIFEST, io=stdout\n)","category":"page"},{"location":"agents_visualizations/#Static-plotting-of-ABMs-1","page":"Plotting and Interactivity","title":"Static plotting of ABMs","text":"","category":"section"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Static plotting, which is also the basis for creating custom plots that include an abm plot, is done using the abmplot function. Its usage is exceptionally straight-forward, and in principle one simply defines functions for how the agents should be plotted. Here we will use a pre-defined model, the Daisyworld as an example throughout this docpage. To learn about this model you can visit the full example,","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"using InteractiveDynamics, Agents\nusing CairoMakie\ndaisypath = joinpath(dirname(pathof(InteractiveDynamics)), \"agents\", \"daisyworld_def.jl\")\ninclude(daisypath)\nmodel, daisy_step!, daisyworld_step! = daisyworld(;\n    solar_luminosity = 1.0, solar_change = 0.0, scenario = :change\n)\nmodel","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Now, to plot daisyworld is as simple as","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"daisycolor(a::Daisy) = a.breed # color of agents\nas = 20 # size of agents\nam = '✿' # marker of agents\nscatterkwargs = (strokewidth = 1.0,) # add stroke around each agent\nfig, ax, abmobs = abmplot(model; ac = daisycolor, as, am, scatterkwargs)\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"To this, we can also plot the temperature of the planet by providing the access field as a heat array:","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"heatarray = :temperature\nheatkwargs = (colorrange = (-20, 60), colormap = :thermal)\nplotkwargs = (;\n    ac = daisycolor, as, am,\n    scatterkwargs = (strokewidth = 1.0,),\n    heatarray, heatkwargs\n)\n\nfig, ax, abmobs = abmplot(model; plotkwargs...)\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"abmplot","category":"page"},{"location":"agents_visualizations/#InteractiveDynamics.abmplot","page":"Plotting and Interactivity","title":"InteractiveDynamics.abmplot","text":"abmplot(model::ABM; kwargs...) → fig, ax, abmobs\nabmplot!(ax::Axis/Axis3, model::ABM; kwargs...) → abmobs\n\nPlot an agent based model by plotting each individual agent as a marker and using the agent's position field as its location on the plot. The same function is used to make custom composite plots and interactive applications for the model evolution using the returned abmobs. abmplot is also used to launch interactive GUIs for evolving agent based models, see \"Interactivity\" below.\n\nRequires Agents. See also abmvideo and abmexploration.\n\nKeyword arguments\n\nAgent related\n\nac, as, am : These three keywords decide the color, size, and marker, that each agent will be plotted as. They can each be either a constant or a function, which takes as an input a single agent and outputs the corresponding value.\nUsing constants: ac = \"#338c54\", as = 15, am = :diamond\nUsing functions:\nac(a) = a.status == :S ? \"#2b2b33\" : a.status == :I ? \"#bf2642\" : \"#338c54\"\nas(a) = 10rand()\nam(a) = a.status == :S ? :circle : a.status == :I ? :diamond : :rect\nNotice that for 2D models, am can be/return a Polygon instance, which plots each agent as an arbitrary polygon. It is assumed that the origin (0, 0) is the agent's position when creating the polygon. In this case, the keyword as is meaningless, as each polygon has its own size. Use the functions scale, rotate2D to transform this polygon.\n3D models currently do not support having different markers. As a result, am cannot be a function. It should be a Mesh or 3D primitive (such as Sphere or Rect3D).\noffset = nothing : If not nothing, it must be a function taking as an input an agent and outputting an offset position tuple to be added to the agent's position (which matters only if there is overlap).\nscatterkwargs = () : Additional keyword arguments propagated to the scatter! call.\n\nPreplot related\n\nheatarray = nothing : A keyword that plots a heatmap over the space. Its values can be standard data accessors given to functions like run!, i.e. either a symbol (directly obtain model property) or a function of the model. The returned data must be a matrix of the same size as the underlying space. For example heatarray = :temperature is used in the Daisyworld example. But you could also define f(model) = create_matrix_from_model... and set heatarray = f. The heatmap will be updated automatically during model evolution in videos and interactive applications.\nIt is strongly recommended to use abmplot instead of the abmplot! method if you use heatarray, so that a colorbar can be placed naturally.\nheatkwargs = NamedTuple() : Keywords given to Makie.heatmap function if heatarray is not nothing.\nadd_colorbar = true : Whether or not a Colorbar should be added to the right side of the heatmap if heatarray is not nothing.\nstatic_preplot! : A function f(ax, model) that plots something after the heatmap but before the agents.\nosmkwargs = NamedTuple() : keywords directly passed to osmplot! from OSMMakie.jl if model space is OpenStreetMapSpace.\n\nThe stand-alone function abmplot also takes two optional NamedTuples named figure and axis which can be used to change the automatically created Figure and Axis objects.\n\nInteractivity\n\nEvolution related\n\nagent_step!, model_step! = Agents.dummystep: Stepping functions to pass to ABMObservable which itself passes to Agents.step!.\nadd_controls::Bool: If true, abmplot switches to \"interactive application\" mode. This is by default true if either agent_step! or model_step! keywords are provided. These stepping functions are used to evolve the model interactively using Agents.step!. The application has the following interactive elements:\n\"step\": advances the simulation once for spu steps.\n\"run\": starts/stops the continuous evolution of the model.\n\"reset model\": resets the model to its initial state from right after starting the interactive application.\nTwo sliders control the animation speed: \"spu\" decides how many model steps should be done before the plot is updated, and \"sleep\" the sleep() time between updates.\nenable_inspection = add_controls: If true, enables agent inspection on mouse hover.\nspu = 1:50: The values of the \"spu\" slider.\nparams = Dict() : This is a dictionary which decides which parameters of the model will be configurable from the interactive application. Each entry of params is a pair of Symbol to an AbstractVector, and provides a range of possible values for the parameter named after the given symbol (see example online). Changing a value in the parameter slides is only propagated to the actual model after a press of the \"update\" button.\n\nData collection related\n\nadata, mdata, when: Same as the keyword arguments of Agents.run!. If either or both adata, mdata are given, data are collected and stored in the abmobs, see ABMObservable. The same keywords provide the data plots of abmexploration. This also adds the button \"clear data\" which deletes previously collected agent and model data by emptying the underlying DataFrames adf/mdf. Reset model and clear data are independent processes.\n\nSee the documentation string of ABMObservable for custom interactive plots.\n\n\n\n\n\n","category":"function"},{"location":"agents_visualizations/#Interactive-ABM-Applications-1","page":"Plotting and Interactivity","title":"Interactive ABM Applications","text":"","category":"section"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Continuing from the Daisyworld plots above, we can turn them into interactive applications straightforwardly, simply by providing the stepping functions as illustrated in the documentation of abmplot. Note that GLMakie should be used instead of CairoMakie when wanting to use the interactive aspects of the plots.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"fig, ax, abmobs = abmplot(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!,\n    plotkwargs...)\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"One could click the run button and see the model evolve. Furthermore, one can add more sliders that allow changing the model parameters.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"params = Dict(\n    :surface_albedo => 0:0.01:1,\n    :solar_change => -0.1:0.01:0.1,\n)\nfig, ax, abmobs = abmplot(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!,\n    params, plotkwargs...)\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"One can furthermore collect data while the model evolves and visualize them using the convenience function abmexploration","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"using Statistics: mean\nblack(a) = a.breed == :black\nwhite(a) = a.breed == :white\nadata = [(black, count), (white, count)]\ntemperature(model) = mean(model.temperature)\nmdata = [temperature, :solar_luminosity]\nfig, abmobs = abmexploration(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!, params, plotkwargs...,\n    adata, alabels = [\"Black daisys\", \"White daisys\"], mdata, mlabels = [\"T\", \"L\"]\n)\nnothing # hide","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"abmexploration","category":"page"},{"location":"agents_visualizations/#InteractiveDynamics.abmexploration","page":"Plotting and Interactivity","title":"InteractiveDynamics.abmexploration","text":"abmexploration(model::ABM; alabels, mlabels, kwargs...)\n\nOpen an interactive application for exploring an agent based model and the impact of changing parameters on the time evolution. Requires Agents.\n\nThe application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below). The agent based model is plotted and animated exactly as in abmplot, and the model argument as well as splatted kwargs are propagated there as-is. This convencience function only works for aggregated agent data.\n\nCalling abmexploration returns: fig::Figure, p::_ABMPlot. So you can save and/or further modify the figure. But it is also possible to access the collected data (if any) via the plot object, just like in the case of using abmplot directly.\n\nClicking the \"reset\" button will add a red vertical line to the data plots for visual guidance.\n\nKeywords arguments (in addition to those in abmplot)\n\nalabels, mlabels: If data are collected from agents or the model with adata, mdata, the corresponding plots' y-labels are automatically named after the collected data. It is also possible to provide alabels, mlabels (vectors of strings with exactly same length as adata, mdata), and these labels will be used instead.\nfigure = NamedTuple(): Keywords to customize the created Figure.\naxis = NamedTuple(): Keywords to customize the created Axis.\nplotkwargs = NamedTuple(): Keywords to customize the styling of the resulting scatterlines plots.\n\n\n\n\n\n","category":"function"},{"location":"agents_visualizations/#ABM-Videos-1","page":"Plotting and Interactivity","title":"ABM Videos","text":"","category":"section"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"abmvideo","category":"page"},{"location":"agents_visualizations/#InteractiveDynamics.abmvideo","page":"Plotting and Interactivity","title":"InteractiveDynamics.abmvideo","text":"abmvideo(file, model, agent_step! [, model_step!]; kwargs...)\n\nThis function exports the animated time evolution of an agent based model into a video saved at given path file, by recording the behavior of the interactive version of abmplot (without sliders). The plotting is identical as in abmplot and applicable keywords are propagated.\n\nKeywords\n\nspf = 1: Steps-per-frame, i.e. how many times to step the model before recording a new frame.\nframerate = 30: The frame rate of the exported video.\nframes = 300: How many frames to record in total, including the starting frame.\ntitle = \"\": The title of the figure.\nshowstep = true: If current step should be shown in title.\nfigure = NamedTuple(): Figure related keywords (e.g. resolution, backgroundcolor).\naxis = NamedTuple(): Axis related keywords (e.g. aspect).\nrecordkwargs = NamedTuple(): Keyword arguments given to Makie.record. You can use (compression = 1, profile = \"high\") for a higher quality output, and prefer the CairoMakie backend. (compression 0 results in videos that are not playable by some software)\nkwargs...: All other keywords are propagated to abmplot.\n\n\n\n\n\n","category":"function"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"E.g., continuing from above,","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"model, daisy_step!, daisyworld_step! = daisyworld()\nabmvideo(\n    \"daisyworld.mp4\",\n    model,  daisy_step!, daisyworld_step!;\n    title = \"Daisy World\", frames = 150,\n    plotkwargs...\n)","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../daisyworld.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"agents_visualizations/#Agent-inspection-1","page":"Plotting and Interactivity","title":"Agent inspection","text":"","category":"section"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"It is possible to inspect agents at a given position by hovering the mouse cursor over the scatter points in the agent plot. Inspection is automatically enabled for interactive applications (i.e. when either agent or model stepping functions are provided). To manually enable this functionality, simply add enable_inspection = true as an additional keyword argument to the abmplot/abmplot! call. A tooltip will appear which by default provides the name of the agent type, its id, pos, and all other fieldnames together with their current values. This is especially useful for interactive exploration of micro data on the agent level.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"(Image: RabbitFoxHawk inspection example)","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"The tooltip can be customized by extending InteractiveDynamics.agent2string.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"InteractiveDynamics.agent2string","category":"page"},{"location":"agents_visualizations/#InteractiveDynamics.agent2string","page":"Plotting and Interactivity","title":"InteractiveDynamics.agent2string","text":"agent2string(agent::A)\n\nConvert agent data into a string which is used to display all agent variables and their values in the tooltip on mouse hover. Concatenates strings if there are multiple agents at one position. Custom tooltips for agents can be implemented by adding a specialised method for agent2string. Example:\n\nfunction InteractiveDynamics.agent2string(agent::SpecialAgent)\n    \"\"\"\n    ✨ SpecialAgent ✨\n    ID = $(agent.id)\n    Main weapon = $(agent.charisma)\n    Side weapon = $(agent.pistol)\n    \"\"\"\nend\n\n\n\n\n\n","category":"function"},{"location":"agents_visualizations/#Creating-custom-ABM-plots-1","page":"Plotting and Interactivity","title":"Creating custom ABM plots","text":"","category":"section"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"The existing convenience function abmexploration will always display aggregated collected data as scatterpoints connected with lines. In cases where more granular control over the displayed plots is needed, we need to take a few extra steps and utilize the ABMObservable returned by abmplot.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"ABMObservable","category":"page"},{"location":"agents_visualizations/#InteractiveDynamics.ABMObservable","page":"Plotting and Interactivity","title":"InteractiveDynamics.ABMObservable","text":"ABMObservable(model; agent_step!, model_step!, adata, mdata, when) → abombs\n\nabmobs contains all information necessary to step an agent based model interactively. It is also returned by abmplot.\n\nCalling Agents.step!(abmobs, n) will step the model for n using the provided agent_step!, model_step!, n as in Agents.step!.\n\nThe fields abmobs.model, abmobs.adf, abmobs.mdf are observables that contain the AgentBasedModel, and the agent and model dataframes with collected data. Data are collected as described in Agents.run! using the adata, mdata, when keywords. All three observables are updated on stepping (when it makes sense). The field abmobs.s is also an observable containing the current step number.\n\nAll plotting and interactivity should be defined by lifting these observables.\n\n\n\n\n\n","category":"type"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"To do custom animations you need to have a good idea of how Makie's animation system works. Have a look at this tutorial if you are not familiar yet.","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"create a basic abmplot with controls and sliders","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"model, = daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)\nfig, ax, abmobs = abmplot(model;\n    agent_step! = daisy_step!, model_step! = daisyworld_step!, params, plotkwargs...,\n    adata, mdata, figure = (; resolution = (1600,800))\n)\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"abmobs","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"# create a new layout to add new plots to to the right of the abmplot\nplot_layout = fig[:,end+1] = GridLayout()\n\n# create a sublayout on its first row and column\ncount_layout = plot_layout[1,1] = GridLayout()\n\n# collect tuples with x and y values for black and white daisys\nblacks = @lift(Point2f.($(p.adf).step, $(p.adf).count_black))\nwhites = @lift(Point2f.($(p.adf).step, $(p.adf).count_white))\n\n# create an axis to plot into and style it to our liking\nax_counts = Axis(count_layout[1,1];\n    backgroundcolor = :lightgrey, ylabel = \"Number of daisies by color\")\n\n# plot the data as scatterlines and color them accordingly\nscatterlines!(ax_counts, blacks; color = :black, label = \"black\")\nscatterlines!(ax_counts, whites; color = :white, label = \"white\")\n\n# add a legend to the right side of the plot\nLegend(count_layout[1,2], ax_counts; bgcolor = :lightgrey)\n\n# and another plot, written in a more condensed format\nax_hist = Axis(plot_layout[2,1];\n    ylabel = \"Distribution of mean temperatures\\nacross all time steps\")\nhist!(ax_hist, @lift($(p.mdf).temperature);\n    bins = 50, color = :red,\n    strokewidth = 2, strokecolor = (:black, 0.5),\n)\n\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Now, once we step the p::ABMObservable, the whole plot will be updated","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Agents.step!(p, 1)\nAgents.step!(p, 1)\nfig","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Of course, you need to actually adjust axis limits given that the plot is interactive","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"autolimits!(ax_counts)\nautolimits!(ax_hist)","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"Or, simply trigger them on any update to the model observable:","category":"page"},{"location":"agents_visualizations/#","page":"Plotting and Interactivity","title":"Plotting and Interactivity","text":"on(p.model) do m\n    autolimits!(ax_counts)\n    autolimits!(ax_hist)\nend\n\nfor i in 1:100; step!(p, 1); end\nfig","category":"page"},{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The API of Agents.jl is defined on top of the fundamental structures AgentBasedModel, Space, AbstractAgent which are described in the Tutorial page. In this page we list the remaining API functions, which constitute the bulk of Agents.jl functionality.","category":"page"},{"location":"api/#Agent/model-retrieval-and-access-1","page":"API","title":"Agent/model retrieval and access","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"getindex(::ABM, ::Integer)\ngetproperty(::ABM, ::Symbol)\nseed!\nrandom_agent\nnagents\nallagents\nallids","category":"page"},{"location":"api/#Base.getindex-Tuple{AgentBasedModel, Integer}","page":"API","title":"Base.getindex","text":"model[id]\ngetindex(model::ABM, id::Integer)\n\nReturn an agent given its ID.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.getproperty-Tuple{AgentBasedModel, Symbol}","page":"API","title":"Base.getproperty","text":"model.prop\ngetproperty(model::ABM, :prop)\n\nReturn a property with name :prop from the current model, assuming the model properties are either a dictionary with key type Symbol or a Julia struct. For example, if a model has the set of properties Dict(:weight => 5, :current => false), retrieving these values can be obtained via model.weight.\n\nThe property names :agents, :space, :scheduler, :properties, :maxid are internals and should not be accessed by the user.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agents.seed!","page":"API","title":"Agents.seed!","text":"seed!(model [, seed])\n\nReseed the random number pool of the model with the given seed or a random one, when using a pseudo-random number generator like MersenneTwister.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_agent","page":"API","title":"Agents.random_agent","text":"random_agent(model) → agent\n\nReturn a random agent from the model.\n\n\n\n\n\nrandom_agent(model, condition) → agent\n\nReturn a random agent from the model that satisfies condition(agent) == true. The function generates a random permutation of agent IDs and iterates through them. If no agent satisfies the condition, nothing is returned instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nagents","page":"API","title":"Agents.nagents","text":"nagents(model::ABM)\n\nReturn the number of agents in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allagents","page":"API","title":"Agents.allagents","text":"allagents(model)\n\nReturn an iterator over all agents of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allids","page":"API","title":"Agents.allids","text":"allids(model)\n\nReturn an iterator over all agent IDs of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Available-spaces-1","page":"API","title":"Available spaces","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Here we list the spaces that are available \"out of the box\" from Agents.jl. To create your own, see Creating a new space type.","category":"page"},{"location":"api/#Discrete-spaces-1","page":"API","title":"Discrete spaces","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"GraphSpace\nGridSpace\nGridSpaceSingle","category":"page"},{"location":"api/#Agents.GraphSpace","page":"API","title":"Agents.GraphSpace","text":"GraphSpace(graph::AbstractGraph)\n\nCreate a GraphSpace instance that is underlined by an arbitrary graph from Graphs.jl. GraphSpace represents a space where each node (i.e. position) of a graph can hold an arbitrary amount of agents, and each agent can move between the nodes of the graph. The position type for this space is Int, use GraphAgent for convenience.\n\nGraphs.nv and Graphs.ne can be used in a model with a GraphSpace to obtain the number of nodes or edges in the graph. The underlying graph can be altered using add_node! and rem_node!.\n\nAn example using GraphSpace is SIR model for the spread of COVID-19.\n\nIf you want to model social networks, where each agent is equivalent with a node of a graph, you're better of using nothing as the model space, and using a graph from Graphs.jl directly in the model parameters, as shown in the Social networks with Graphs.jl integration example.\n\nDistance specification\n\nIn functions like nearby_ids, distance for GraphSpace means the degree of neighbors in the graph (thus distance is always an integer). For example, for r=2 includes first and second degree neighbors. For 0 distance, the search occurs only on the origin node.\n\nIn functions like nearby_ids the keyword neighbor_type=:default can be used to select differing neighbors depending on the underlying graph directionality type.\n\n:default returns neighbors of a vertex (position). If graph is directed, this is equivalent to :out. For undirected graphs, all options are equivalent to :out.\n:all returns both :in and :out neighbors.\n:in returns incoming vertex neighbors.\n:out returns outgoing vertex neighbors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.GridSpace","page":"API","title":"Agents.GridSpace","text":"GridSpace(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)\n\nCreate a GridSpace that has size given by the tuple d, having D ≥ 1 dimensions. Optionally decide whether the space will be periodic and what will be the distance metric. The position type for this space is NTuple{D, Int}, use GridAgent for convenience. Valid positions have indices in the range 1:d[i] for the i-th dimension.\n\nAn example using GridSpace is Schelling's segregation model.\n\nDistance specification\n\nThe typical terminology when searching neighbors in agent based modelling is \"Von Neumann\" neighborhood or \"Moore\" neighborhoods. However, because Agents.jl provides a much more powerful infastructure for finding neighbors, both in arbitrary dimensions but also of arbitrary neighborhood size, this established terminology is no longer appropriate. Instead, distances that define neighborhoods are specified according to a proper metric space, that is both well defined for any distance, and applicable to any dimensionality.\n\nThe allowed metrics are (and see docs online for a plotted example):\n\n:chebyshev metric means that the r-neighborhood of a position are all positions within the hypercube having side length of 2*floor(r) and being centered in the origin position. This is similar to \"Moore\" for r = 1 and two dimensions.\n:manhattan metric means that the r-neighborhood of a position are all positions whose cartesian indices have Manhattan distance ≤ r from the cartesian index of the origin position. This similar to \"Von Neumann\" for r = 1 and two dimensions.\n:euclidean metric means that the r-neighborhood of a position are all positions whose cartesian indices have Euclidean distance ≤ r from the cartesian index of the origin position.\n\nAdvanced dimension-dependent distances in Chebyshev metric\n\nIf metric = :chebyshev, some advanved specification of distances is allowed when providing r to functions like nearby_ids.\n\nr::NTuple{D,Int} such as r = (5, 2). This would mean a distance of 5 in the first dimension and 2 in the second. This can be useful when different coordinates in the space need to be searched with different ranges, e.g., if the space corresponds to a full building, with the third dimension the floor number.\nr::Vector{Tuple{Int,UnitRange{Int}}} such as r = [(1, -1:1), (3, 1:2)]. This allows explicitly specifying the difference between position indices in each specified dimension. The example r = [(1, -1:1), (3, 1:2)] when given to e.g., nearby_ids, would search dimension 1 one step of either side of the current position (as well as the current position since 0 ∈ -1:1) and would search the third dimension one and two positions above current. Unspecified dimensions (like the second in this example) are searched throughout all their possible ranges.\n\nSee the Battle Royale example for usage of this advanced specification of dimension-dependent distances where one dimension is used as a categorical one.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.GridSpaceSingle","page":"API","title":"Agents.GridSpaceSingle","text":"GridSpaceSingle(d::NTuple{D, Int}; periodic = true, metric = :chebyshev)\n\nThis is a specialized version of GridSpace that allows only one agent per position, and utilizes this knowledge to offer significant performance gains versus GridSpace.\n\nThis space reserves agent ID = 0 for internal usage. Agents should be initialized with non-zero IDs, either positive or negative. This is not checked internally.\n\nAll arguments and keywords behave exactly as in GridSpace.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Here is a specification of how the metrics look like:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"include(\"distances_example_plot.jl\") # hide","category":"page"},{"location":"api/#Continuous-spaces-1","page":"API","title":"Continuous spaces","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"ContinuousSpace\nOpenStreetMapSpace","category":"page"},{"location":"api/#Agents.ContinuousSpace","page":"API","title":"Agents.ContinuousSpace","text":"ContinuousSpace(extent::NTuple{D, <:Real}; kwargs...)\n\nCreate a D-dimensional ContinuousSpace in range 0 to (but not including) extent. Your agent positions (field pos) must be of type NTuple{D, <:Real}, and it is strongly recommend that agents also have a field vel::NTuple{D, <:Real} to use in conjunction with move_agent!. Use ContinuousAgent for convenience.\n\nContinuousSpace is a representation of agent dynamics on a continuous medium where agent position, orientation, and speed, are true floats. In addition, support is provided for representing spatial properties in a model that contains a ContinuousSpace. Spatial properties (which typically are contained in the model properties) can either be functions of the position vector, f(pos) = value, or AbstractArrays, representing discretizations of spatial data that may not be available in analytic form. In the latter case, the position is automatically mapped into the discretization represented by the array. Use get_spatial_property to access spatial properties in conjuction with ContinuousSpace.\n\nSee also Continuous space exclusives on the online docs for more functionality. An example using continuous space is the Flocking model.\n\nDistance specification\n\nDistances specified by r in functions like nearby_ids are always based on the Euclidean distance between two points in ContinuousSpace.\n\nIn ContinuousSpace nearby_* searches are accelerated using a grid system, see discussion around the keyword spacing below. nearby_ids is not an exact search, but can be a possible over-estimation, including agent IDs whose distance slightly exceeds r with \"slightly\" being as much as spacing. If you want exact searches use the slower nearby_ids_exact.\n\nKeywords\n\nperiodic = true: Whether the space is periodic or not. If set to false an error will occur if an agent's position exceeds the boundary.\nspacing::Real = minimum(extent)/20: Configures an internal compartment spacing that is used to accelerate nearest neighbor searches like nearby_ids. The compartments are actually a full instance of GridSpace in which agents move. All dimensions in extent must be completely divisible by spacing. There is no best choice for the value of spacing and if you need optimal performance it's advised to set up a benchmark over a range of choices. The finer the spacing, the faster and more accurate the inexact version of nearby_ids becomes. However, a finer spacing also means slower move_agent!, as agents change compartments more often.\nupdate_vel!: A function, update_vel!(agent, model) that updates the agent's velocity before the agent has been moved, see move_agent!. You can of course change the agents' velocities during the agent interaction, the update_vel! functionality targets spatial force fields acting on the agents individually (e.g. some magnetic field). If you use update_vel!, the agent type must have a field vel::NTuple{D, <:Real}.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.OpenStreetMapSpace","page":"API","title":"Agents.OpenStreetMapSpace","text":"OpenStreetMapSpace(path::AbstractString; kwargs...)\n\nCreate a space residing on the Open Street Map (OSM) file provided via path. This space represents the underlying map as a continuous entity choosing accuracy over performance. The map is represented as a graph, consisting of nodes connected by edges. Nodes are not necessarily intersections, and there may be multiple nodes on a road joining two intersections. Agents move along the available roads of the map using routing, see below.\n\nThe functionality related to Open Street Map spaces is in the submodule OSM. An example of its usage can be found in Zombie Outbreak in a City.\n\nThe OSMAgent\n\nThe base properties for an agent residing on an OSMSpace are as follows:\n\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int,Float64}\nend\n\nCurrent position tuple is represented as (first intersection index, second intersection index, distance travelled). The indices are the indices of the nodes of the graph that internally represents the map. Functions like OSM.nearest_node or OSM.nearest_road can help find those node indices from a (lon, lat) real world coordinate. The distance travelled is in the units of weight_type. This ensures that the map is a continuous kind of space, as an agent can truly be at any possible point on an existing road.\n\nUse OSMAgent for convenience.\n\nObtaining map files\n\nMaps files can be downloaded using the functions provided by LightOSM.jl. Agents.jl also re-exports OSM.download_osm_network, the main function used to download maps and provides a test map in OSM.test_map. An example usage to download the map of London to \"london.json\":\n\nOSM.download_osm_network(\n    :place_name;\n    place_name = \"London\",\n    save_to_file_location = \"london.json\"\n)\n\nThe length of an edge between two nodes is specified in the units of the map's weight_type as listed in the documentation for LightOSM.OSMGraph. The possible weight_types are:\n\n:distance: The distance in kilometers of an edge\n:time: The time in hours to travel along an edge at the maximum speed allowed on that road\n:lane_efficiency: Time scaled by number of lanes\n\nThe default weight_type used is :distance.\n\nAll kwargs are propagated to LightOSM.graph_from_file.\n\nRouting with OSM\n\nYou can use plan_route! or plan_random_route!. To actually move along a planned route use move_along_route!.\n\n\n\n\n\n","category":"type"},{"location":"api/#Adding-agents-1","page":"API","title":"Adding agents","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"add_agent!\nadd_agent_pos!\nnextid\nrandom_position","category":"page"},{"location":"api/#Agents.add_agent!","page":"API","title":"Agents.add_agent!","text":"add_agent!(agent::AbstractAgent [, pos], model::ABM) → agent\n\nAdd the agent to the model in the given position. If pos is not given, the agent is added to a random position. The agent's position is always updated to match position, and therefore for add_agent! the position of the agent is meaningless. Use add_agent_pos! to use the agent's position.\n\nThe type of pos must match the underlying space position type.\n\n\n\n\n\nadd_agent!([pos,] model::ABM, args...; kwargs...) → newagent\n\nCreate and add a new agent to the model using the constructor of the agent type of the model. Optionally provide a position to add the agent to as first argument, which must match the space position type.\n\nThis function takes care of setting the agent's id and position. The extra provided args... and kwargs... are propagated to other fields of the agent constructor (see example below).\n\nadd_agent!([pos,] A::Type, model::ABM, args...; kwargs...) → newagent\n\nUse this version for mixed agent models, with A the agent type you wish to create (to be called as A(id, pos, args...; kwargs...)), because it is otherwise not possible to deduce a constructor for A.\n\nExample\n\nusing Agents\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::Int\n    w::Float64\n    k::Bool\nend\nAgent(id, pos; w=0.5, k=false) = Agent(id, pos, w, k) # keyword constructor\nmodel = ABM(Agent, GraphSpace(complete_digraph(5)))\n\nadd_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally\nadd_agent!(model, 0.5, true) # correct: w becomes 0.5\nadd_agent!(5, model, 0.5, true) # add at position 5, w becomes 0.5\nadd_agent!(model; w = 0.5) # use keywords: w becomes 0.5, k becomes false\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_pos!","page":"API","title":"Agents.add_agent_pos!","text":"add_agent_pos!(agent::AbstractAgent, model::ABM) → agent\n\nAdd the agent to the model at the agent's own position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nextid","page":"API","title":"Agents.nextid","text":"nextid(model::ABM) → id\n\nReturn a valid id for creating a new agent with it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_position","page":"API","title":"Agents.random_position","text":"random_position(model) → pos\n\nReturn a random position in the model's space (always with appropriate Type).\n\n\n\n\n\n","category":"function"},{"location":"api/#Moving-agents-1","page":"API","title":"Moving agents","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"move_agent!\nwalk!\nget_direction","category":"page"},{"location":"api/#Agents.move_agent!","page":"API","title":"Agents.move_agent!","text":"move_agent!(agent [, pos], model::ABM) → agent\n\nMove agent to the given position, or to a random one if a position is not given. pos must have the appropriate position type depending on the space type.\n\nThe agent's position is updated to match pos after the move.\n\n\n\n\n\nmove_agent!(agent::A, model::ABM{<:ContinuousSpace,A}, dt::Real)\n\nPropagate the agent forwards one step according to its velocity, after updating the agent's velocity (if configured using update_vel!, see ContinuousSpace).\n\nFor this continuous space version of move_agent!, the \"time evolution\" is a trivial Euler scheme with dt the step size, i.e. the agent position is updated as agent.pos += agent.vel * dt.\n\nUnlike move_agent!(agent, [pos,] model), this function respects the space size. For non-periodic spaces, agents will walk up to, but not reach, the space extent. For periodic spaces movement properly wraps around the extent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.walk!","page":"API","title":"Agents.walk!","text":"walk!(agent, direction::NTuple, model; ifempty = false)\n\nMove agent in the given direction respecting periodic boundary conditions. For non-periodic spaces, agents will walk to, but not exceed the boundary value. Available for both AbstractGridSpace and ContinuousSpaces.\n\nThe type of direction must be the same as the space position. AbstractGridSpace asks for Int, and ContinuousSpace for Float64 tuples, describing the walk distance in each direction. direction = (2, -3) is an example of a valid direction on a AbstractGridSpace, which moves the agent to the right 2 positions and down 3 positions. Agent velocity is ignored for this operation in ContinuousSpace.\n\nKeywords\n\nifempty will check that the target position is unoccupied and only move if that's true. Available only on AbstractGridSpace.\n\nExample usage in Battle Royale.\n\n\n\n\n\nwalk!(agent, rand, model)\n\nInvoke a random walk by providing the rand function in place of direction. For AbstractGridSpace, the walk will cover ±1 positions in all directions, ContinuousSpace will reside within [-1, 1].\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_direction","page":"API","title":"Agents.get_direction","text":"get_direction(from, to, model::ABM)\n\nReturn the direction vector from the position from to position to taking into account periodicity of the space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Movement-with-paths-1","page":"API","title":"Movement with paths","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"For OpenStreetMapSpace, and GridSpace/ContinuousSpace using Pathfinding.Pathfinder, a special movement method is available.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"plan_route!\nplan_best_route!\nmove_along_route!\nis_stationary","category":"page"},{"location":"api/#Agents.plan_route!","page":"API","title":"Agents.plan_route!","text":"plan_route!(agent, dest, pathfinder::AStar{D})\n\nCalculate and store the shortest path to move the agent from its current position to dest (a position e.g. (1, 5) or (1.3, 5.2)) using the provided pathfinder.\n\nUse this method in conjuction with move_along_route!.\n\n\n\n\n\nplan_route!(agent, dest, model::ABM{<:OpenStreetMapSpace};\n            return_trip = false, kwargs...) → success\n\nPlan a route from the current position of agent to the location specified in dest, which can be an intersection or a point on a road. Overwrite any existing route.\n\nIf return_trip = true, a route will be planned from start ⟶ finish ⟶ start. All other keywords are passed to LightOSM.shortest_path.\n\nReturn true if a path to dest exists, and hence the route planning was successful. Otherwise return false. Specifying return_trip = true also requires the existence of a return path for a route to be planned.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.plan_best_route!","page":"API","title":"Agents.plan_best_route!","text":"plan_best_route!(agent, dests, pathfinder::AStar{D}; kwargs...)\n\nCalculate, store, and return the best path to move the agent from its current position to a chosen destination taken from dests using pathfinder.\n\nThe condition = :shortest keyword retuns the shortest path which is shortest out of the possible destinations. Alternatively, the :longest path may also be requested.\n\nReturn the position of the chosen destination. Return nothing if none of the supplied destinations are reachable.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_along_route!","page":"API","title":"Agents.move_along_route!","text":"move_along_route!(agent, model::ABM{<:GridSpace{D}}, pathfinder::AStar{D})\n\nMove agent for one step along the route toward its target set by plan_route!\n\nFor pathfinding in models with GridSpace.\n\nIf the agent does not have a precalculated path or the path is empty, it remains stationary.\n\n\n\n\n\nmove_along_route!(agent, model::ABM{<:ContinuousSpace{D}}, pathfinder::AStar{D}, speed, dt = 1.0)\n\nMove agent for one step along the route toward its target set by plan_route! at the given speed and timestep dt.\n\nFor pathfinding in models with ContinuousSpace\n\nIf the agent does not have a precalculated path or the path is empty, it remains stationary.\n\n\n\n\n\nmove_along_route!(agent, model::ABM{<:OpenStreetMapSpace}, distance::Real) → remaining\n\nMove an agent by distance along its planned route. Units of distance are as specified by the underlying graph's weight_type. If the provided distance is greater than the distance to the end of the route, return the remaining distance. Otherwise, return 0. 0 is also returned if is_stationary(agent, model).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.is_stationary","page":"API","title":"Agents.is_stationary","text":"is_stationary(agent, model)\n\nReturn true if agent has reached the end of its route, or no route has been set for it. Used in setups where using move_along_route! is valid.\n\n\n\n\n\nis_stationary(agent, astar::AStar)\n\nSame, but for pathfinding with A*.\n\n\n\n\n\n","category":"function"},{"location":"api/#Removing-agents-1","page":"API","title":"Removing agents","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"kill_agent!\ngenocide!\nsample!","category":"page"},{"location":"api/#Agents.kill_agent!","page":"API","title":"Agents.kill_agent!","text":"kill_agent!(agent::AbstractAgent, model::ABM)\nkill_agent!(id::Int, model::ABM)\n\nRemove an agent from the model.\n\n\n\n\n\nPathfinding.kill_agent!(agent, model, pathfinder)\n\nThe same as kill_agent!(agent, model), but also removes the agent's path data from pathfinder.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.genocide!","page":"API","title":"Agents.genocide!","text":"genocide!(model::ABM)\n\nKill all the agents of the model.\n\n\n\n\n\ngenocide!(model::ABM, n::Int)\n\nKill the agents whose IDs are larger than n.\n\n\n\n\n\ngenocide!(model::ABM, IDs)\n\nKill the agents with the given IDs.\n\n\n\n\n\ngenocide!(model::ABM, f::Function)\n\nKill all agents where the function f(agent) returns true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.sample!","page":"API","title":"Agents.sample!","text":"sample!(model::ABM, n [, weight]; kwargs...)\n\nReplace the agents of the model with a random sample of the current agents with size n.\n\nOptionally, provide a weight: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the weight of the agent, the higher the probability that this agent will be chosen in the new sampling.\n\nKeywords\n\nreplace = true : whether sampling is performed with replacement, i.e. all agents can\n\nbe chosen more than once.\n\nExample usage in Wright-Fisher model of evolution.\n\n\n\n\n\n","category":"function"},{"location":"api/#Space-utility-functions-1","page":"API","title":"Space utility functions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"normalize_position\nspacesize","category":"page"},{"location":"api/#Agents.normalize_position","page":"API","title":"Agents.normalize_position","text":"normalize_position(pos, model::ABM{<:Union{AbstractGridSpace,ContinuousSpace}})\n\nReturn the position pos normalized for the extents of the space of the given model. For periodic spaces, this wraps the position along each dimension, while for non-periodic spaces this clamps the position to the space extent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.spacesize","page":"API","title":"Agents.spacesize","text":"spacesize(model::ABM)\n\nReturn the size of the model's space. Works for AbstractGridSpace and ContinuousSpace.\n\n\n\n\n\n","category":"function"},{"location":"api/#Discrete-space-exclusives-1","page":"API","title":"Discrete space exclusives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"positions\nids_in_position\nid_in_position\nagents_in_position\nfill_space!\nhas_empty_positions\nempty_positions\nrandom_empty\nadd_agent_single!\nmove_agent_single!\nisempty(::Integer, ::ABM)","category":"page"},{"location":"api/#Agents.positions","page":"API","title":"Agents.positions","text":"positions(model::ABM{<:DiscreteSpace}) → ns\n\nReturn an iterator over all positions of a model with a discrete space.\n\npositions(model::ABM{<:DiscreteSpace}, by::Symbol) → ns\n\nReturn all positions of a model with a discrete space, sorting them using the argument by which can be:\n\n:random - randomly sorted\n:population - positions are sorted depending on how many agents they accommodate. The more populated positions are first.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.ids_in_position","page":"API","title":"Agents.ids_in_position","text":"ids_in_position(position, model::ABM{<:DiscreteSpace})\nids_in_position(agent, model::ABM{<:DiscreteSpace})\n\nReturn the ids of agents in the position corresponding to position or position of agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.id_in_position","page":"API","title":"Agents.id_in_position","text":"id_in_position(pos, model::ABM{<:GridSpaceSingle}) → id\n\nReturn the agent ID in the given position. This will be 0 if there is no agent in this position.\n\nThis is similar to ids_in_position, but specialized for GridSpaceSingle. See also isempty.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.agents_in_position","page":"API","title":"Agents.agents_in_position","text":"agents_in_position(position, model::ABM{<:DiscreteSpace})\nagents_in_position(agent, model::ABM{<:DiscreteSpace})\n\nReturn the agents in the position corresponding to position or position of agent.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.fill_space!","page":"API","title":"Agents.fill_space!","text":"fill_space!([A ,] model::ABM{<:DiscreteSpace,A}, args...; kwargs...)\nfill_space!([A ,] model::ABM{<:DiscreteSpace,A}, f::Function; kwargs...)\n\nAdd one agent to each position in the model's space. Similarly with add_agent!, the function creates the necessary agents and the args...; kwargs... are propagated into agent creation. If instead of args... a function f is provided, then args = f(pos) is the result of applying f where pos is each position (tuple for grid, integer index for graph).\n\nAn optional first argument is an agent type to be created, and targets mixed agent models where the agent constructor cannot be deduced (since it is a union).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.has_empty_positions","page":"API","title":"Agents.has_empty_positions","text":"has_empty_positions(model::ABM{<:DiscreteSpace})\n\nReturn true if there are any positions in the model without agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.empty_positions","page":"API","title":"Agents.empty_positions","text":"empty_positions(model)\n\nReturn a list of positions that currently have no agents on them.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_empty","page":"API","title":"Agents.random_empty","text":"random_empty(model::ABM{<:DiscreteSpace}, cutoff = 0.998)\n\nReturn a random position without any agents, or nothing if no such positions exist. cutoff switches the search algorithm from probabalistic to a filter. Specifically, when clamp(nagents(model)/total_positions, 0.0, 1.0) < cutoff, then the algorithm is probabilistic.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_single!","page":"API","title":"Agents.add_agent_single!","text":"add_agent_single!(agent, model::ABM{<:DiscreteSpace}) → agent\n\nAdd the agent to a random position in the space while respecting a maximum of one agent per position, updating the agent's position to the new one.\n\nThis function does nothing if there aren't any empty positions.\n\n\n\n\n\nadd_agent_single!(model::ABM{<:DiscreteSpace}, properties...; kwargs...)\n\nSame as add_agent!(model, properties...; kwargs...) but ensures that it adds an agent into a position with no other agents (does nothing if no such position exists).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_agent_single!","page":"API","title":"Agents.move_agent_single!","text":"move_agent_single!(agent, model::ABM{<:DiscreteSpace}; cutoff) → agent\n\nMove agent to a random position while respecting a maximum of one agent per position. If there are no empty positions, the agent won't move.\n\nThe keyword cutoff = 0.998 is sent to random_empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isempty-Tuple{Integer, AgentBasedModel}","page":"API","title":"Base.isempty","text":"isempty(position, model::ABM{<:DiscreteSpace})\n\nReturn true if there are no agents in position.\n\n\n\n\n\n","category":"method"},{"location":"api/#GraphSpace-exclusives-1","page":"API","title":"GraphSpace exclusives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"add_edge!\nadd_node!\nrem_node!","category":"page"},{"location":"api/#Graphs.SimpleGraphs.add_edge!","page":"API","title":"Graphs.SimpleGraphs.add_edge!","text":"add_edge!(model::ABM{<: GraphSpace}, n::Int, m::Int)\n\nAdd a new edge (relationship between two positions) to the graph. Returns a boolean, true if the operation was succesful.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_node!","page":"API","title":"Agents.add_node!","text":"add_node!(model::ABM{<: GraphSpace})\n\nAdd a new node (i.e. possible position) to the model's graph and return it. You can connect this new node with existing ones using add_edge!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.rem_node!","page":"API","title":"Agents.rem_node!","text":"rem_node!(model::ABM{<: GraphSpace}, n::Int)\n\nRemove node (i.e. position) n from the model's graph. All agents in that node are killed.\n\nWarning: Graphs.jl (and thus Agents.jl) swaps the index of the last node with that of the one to be removed, while every other node remains as is. This means that when doing rem_node!(n, model) the last node becomes the n-th node while the previous n-th node (and all its edges and agents) are deleted.\n\n\n\n\n\n","category":"function"},{"location":"api/#ContinuousSpace-exclusives-1","page":"API","title":"ContinuousSpace exclusives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"nearby_ids_exact\nnearest_neighbor\nget_spatial_property\nget_spatial_index\ninteracting_pairs\nelastic_collision!\neuclidean_distance\nmanhattan_distance","category":"page"},{"location":"api/#Agents.nearby_ids_exact","page":"API","title":"Agents.nearby_ids_exact","text":"nearby_ids_exact(x, model, r = 1)\n\nReturn an iterator over agent IDs nearby x (a position or an agent). Only valid for ContinuousSpace models. Use instead of nearby_ids for a slower, but 100% accurate version. See ContinuousSpace for more details.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearest_neighbor","page":"API","title":"Agents.nearest_neighbor","text":"nearest_neighbor(agent, model::ABM{<:ContinuousSpace}, r) → nearest\n\nReturn the agent that has the closest distance to given agent. Return nothing if no agent is within distance r.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_spatial_property","page":"API","title":"Agents.get_spatial_property","text":"get_spatial_property(pos::NTuple{D, Float64}, property::AbstractArray, model::ABM)\n\nConvert the continuous agent position into an appropriate index of property, which represents some discretization of a spatial field over a ContinuousSpace. Then, return property[index]. To get the index directly, for e.g. mutating the property in-place, use get_spatial_index.\n\n\n\n\n\nget_spatial_property(pos::NTuple{D, Float64}, property::Function, model::ABM)\n\nLiterally equivalent with property(pos, model), provided just for syntax consistency.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_spatial_index","page":"API","title":"Agents.get_spatial_index","text":"get_spatial_index(pos, property::AbstractArray, model::ABM)\n\nConvert the continuous agent position into an appropriate index of property, which represents some discretization of a spatial field over a ContinuousSpace.\n\nThe dimensionality of property and the continuous space do not have to match. If property has lower dimensionalty than the space (e.g. representing some surface property in 3D space) then the front dimensions of pos will be used to index.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.interacting_pairs","page":"API","title":"Agents.interacting_pairs","text":"interacting_pairs(model, r, method; scheduler = model.scheduler) → piter\n\nReturn an iterator that yields unique pairs of agents (a, b) that are close neighbors to each other, within some interaction radius r.\n\nThis function is usefully combined with model_step!, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with a and with b, which would be unavoidable when using agent_step!). This means, that if a pair (a, b) exists, the pair (b, a) is not included in the iterator!\n\nUse piter.pairs to get a vector of pair IDs from the iterator.\n\nThe argument method provides three pairing scenarios\n\n:all: return every pair of agents that are within radius r of each other, not only the nearest ones.\n:nearest: agents are only paired with their true nearest neighbor (existing within radius r). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by distance, then by next id in scheduler) will be paired.\n:types: For mixed agent models only. Return every pair of agents within radius r (similar to :all), only capturing pairs of differing types. For example, a model of Union{Sheep,Wolf} will only return pairs of (Sheep, Wolf). In the case of multiple agent types, e.g. Union{Sheep, Wolf, Grass}, skipping pairings that involve Grass, can be achived by a scheduler that doesn't schedule Grass types, i.e.: scheduler(model) = (a.id for a in allagents(model) if !(a isa Grass)).\n\nThe following keywords can be used:\n\nscheduler = model.scheduler, which schedulers the agents during iteration for finding pairs. Especially in the :nearest case, this is important, as different sequencing for the agents may give different results (if b is the nearest agent for a, but a is not the nearest agent for b, whether you get the pair (a, b) or not depends on whether a was scheduelr first or not).\nnearby_f = nearby_ids_exact is the function that decides how to find nearby IDs in the :all, :types cases. Must be nearby_ids_exact or nearby_ids.\n\nExample usage in https://juliadynamics.github.io/AgentsExampleZoo.jl/dev/examples/growing_bacteria/.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.elastic_collision!","page":"API","title":"Agents.elastic_collision!","text":"elastic_collision!(a, b, f = nothing) → happened\n\nResolve a (hypothetical) elastic collision between the two agents a, b. They are assumed to be disks of equal size touching tangentially. Their velocities (field vel) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.\n\nIf f is a Symbol, then the agent property f, e.g. :mass, is taken as a mass to weight the two agents for the collision. By default no weighting happens.\n\nOne of the two agents can have infinite \"mass\", and then acts as an immovable object that specularly reflects the other agent. In this case momentum is not conserved, but kinetic energy is still conserved.\n\nReturn a boolean encoding whether the collision happened.\n\nExample usage in Continuous space social distancing.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.euclidean_distance","page":"API","title":"Agents.euclidean_distance","text":"euclidean_distance(a, b, model::ABM)\n\nReturn the euclidean distance between a and b (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently AbstractGridSpace and ContinuousSpace.\n\nExample usage in the Flocking model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.manhattan_distance","page":"API","title":"Agents.manhattan_distance","text":"manhattan_distance(a, b, model::ABM)\n\nReturn the manhattan distance between a and b (either agents or agent positions), respecting periodic boundary conditions (if in use). Works with any space where it makes sense: currently AbstractGridSpace and ContinuousSpace.\n\n\n\n\n\n","category":"function"},{"location":"api/#OpenStreetMapSpace-exclusives-1","page":"API","title":"OpenStreetMapSpace exclusives","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"OSM\nOSM.lonlat\nOSM.nearest_node\nOSM.nearest_road\nOSM.random_road_position\nOSM.plan_random_route!\nOSM.road_length\nOSM.route_length\nOSM.same_position\nOSM.same_road\nOSM.test_map\nOSM.download_osm_network","category":"page"},{"location":"api/#Agents.OSM","page":"API","title":"Agents.OSM","text":"OSM\n\nSubmodule for functionality related to OpenStreetMapSpace. See the docstring of the space for more info.\n\n\n\n\n\n","category":"module"},{"location":"api/#Agents.OSM.lonlat","page":"API","title":"Agents.OSM.lonlat","text":"OSM.lonlat(pos, model)\nOSM.lonlat(agent, model)\n\nReturn (longitude, latitude) of current road or intersection position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.nearest_node","page":"API","title":"Agents.OSM.nearest_node","text":"OSM.nearest_node(lonlat::Tuple{Float64,Float64}, model::ABM{<:OpenStreetMapSpace})\n\nReturn the nearest intersection position to (longitude, latitude). Quicker, but less precise than OSM.nearest_road.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.nearest_road","page":"API","title":"Agents.OSM.nearest_road","text":"OSM.nearest_road(lonlat::Tuple{Float64,Float64}, model::ABM{<:OpenStreetMapSpace})\n\nReturn a location on a road nearest to (longitude, latitude). Significantly slower, but more precise than OSM.nearest_node.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.random_road_position","page":"API","title":"Agents.OSM.random_road_position","text":"OSM.random_road_position(model::ABM{<:OpenStreetMapSpace})\n\nSimilar to random_position, but rather than providing only intersections, this method returns a location somewhere on a road heading in a random direction.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.plan_random_route!","page":"API","title":"Agents.OSM.plan_random_route!","text":"OSM.plan_random_route!(agent, model::ABM{<:OpenStreetMapSpace}; kwargs...) → success\n\nPlan a new random route for the agent, by selecting a random destination and planning a route from the agent's current position. Overwrite any existing route.\n\nThe keyword limit = 10 specifies the limit on the number of attempts at planning a random route, as no connection may be possible given the random destination. Return true if a route was successfully planned, false otherwise. All other keywords are passed to plan_route!\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.road_length","page":"API","title":"Agents.OSM.road_length","text":"OSM.road_length(start::Int, finish::Int, model)\nOSM.road_length(pos::Tuple{Int,Int,Float64}, model)\n\nReturn the road length between two intersections. This takes into account the direction of the road, so OSM.road_length(pos_1, pos_2, model) may not be the same as OSM.road_length(pos_2, pos_1, model). Units of the returned quantity are as specified by the underlying graph's weight_type. If start and finish are the same or pos[1] and pos[2] are the same, then return 0.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.route_length","page":"API","title":"Agents.OSM.route_length","text":"OSM.route_length(agent, model::ABM{<:OpenStreetMapSpace})\n\nReturn the length of the route planned for the given agent, correctly taking into account the amount of route already traversed by the agent. Return 0 if is_stationary(agent, model).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.same_position","page":"API","title":"Agents.OSM.same_position","text":"OSM.same_position(a::Tuple{Int,Int,Float64}, b::Tuple{Int,Int,Float64}, model::ABM{<:OpenStreetMapSpace})\n\nReturn true if the given positions a and b are (approximately) identical\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.same_road","page":"API","title":"Agents.OSM.same_road","text":"OSM.same_road(a::Tuple{Int,Int,Float64}, b::Tuple{Int,Int,Float64})\n\nReturn true if both points lie on the same road of the graph\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.OSM.test_map","page":"API","title":"Agents.OSM.test_map","text":"OSM.test_map()\n\nDownload a small test map of Göttingen as an artifact. Return a path to the downloaded file.\n\nUsing this map requires network_type = :none to be passed as a keyword to OSMSpace. The unit of distance used for this map is :time.\n\n\n\n\n\n","category":"function"},{"location":"api/#LightOSM.download_osm_network","page":"API","title":"LightOSM.download_osm_network","text":"download_osm_network(download_method::Symbol;\n                     network_type::Symbol=:drive,\n                     metadata::Bool=false,\n                     download_format::Symbol=:json,\n                     save_to_file_location::Union{String,Nothing}=nothing,\n                     download_kwargs...\n                     )::Union{XMLDocument,Dict{String,Any}}\n\nDownloads an OpenStreetMap network by querying with a place name, bounding box, or centroid point.\n\nArguments\n\ndownload_method::Symbol: Download method, choose from :place_name, :bbox or :point.\nnetwork_type::Symbol=:drive: Network type filter, pick from :drive, :drive_service, :walk, :bike, :all, :all_private, :none, :rail\nmetadata::Bool=false: Set true to return metadata.\ndownload_format::Symbol=:json: Download format, either :osm, :xml or json.\nsave_to_file_location::Union{String,Nothing}=nothing: Specify a file location to save downloaded data to disk.\n\nRequired Kwargs for each Download Method\n\ndownload_method=:place_name\n\nplace_name::String: Any place name string used as a search argument to the Nominatim API.\n\ndownload_method=:bbox\n\nminlat::AbstractFloat: Bottom left bounding box latitude coordinate.\nminlon::AbstractFloat: Bottom left bounding box longitude coordinate.\nmaxlat::AbstractFloat: Top right bounding box latitude coordinate.\nmaxlon::AbstractFloat: Top right bounding box longitude coordinate.\n\ndownload_method=:point\n\npoint::GeoLocation: Centroid point to draw the bounding box around.\nradius::Number: Distance (km) from centroid point to each bounding box corner.\n\ndownload_method=:polygon\n\npolygon::AbstractVector: Vector of longitude-latitude pairs.\n\nNetwork Types\n\n:drive: Motorways excluding private and service ways.\n:drive_service: Motorways including private and service ways.\n:walk: Walkways only.\n:bike: Cycleways only.\n:all: All motorways, walkways and cycleways excluding private ways.\n:all_private: All motorways, walkways and cycleways including private ways.\n:none: No network filters.\n:rail: Railways excluding proposed and platform.\n\nReturn\n\nUnion{XMLDocument,Dict{String,Any}}: OpenStreetMap network data parsed as either XML or Dictionary object depending on the download method.\n\n\n\n\n\n","category":"function"},{"location":"api/#Nearby-Agents-1","page":"API","title":"Nearby Agents","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"nearby_ids\nnearby_agents\nnearby_positions\nrandom_nearby_id\nrandom_nearby_agent","category":"page"},{"location":"api/#Agents.nearby_ids","page":"API","title":"Agents.nearby_ids","text":"nearby_ids(position, model::ABM, r = 1; kwargs...) → ids\n\nReturn an iterable over the IDs of the agents within distance r (inclusive) from the given position. The position must match type with the spatial structure of the model. The specification of what \"distance\" means depends on the space, hence it is explained in each space's documentation string. Keyword arguments are space-specific and also described in each space's documentation string.\n\nnearby_ids always includes IDs with 0 distance to position.\n\n\n\n\n\nnearby_ids(agent::AbstractAgent, model::ABM, r=1)\n\nSame as nearby_ids(agent.pos, model, r) but the iterable excludes the given agent's id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearby_agents","page":"API","title":"Agents.nearby_agents","text":"nearby_agents(agent, model::ABM, r = 1; kwargs...) -> agent\n\nReturn an iterable of the agents near the position of the given agent.\n\nThe value of the argument r and possible keywords operate identically to nearby_ids.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearby_positions","page":"API","title":"Agents.nearby_positions","text":"nearby_positions(position, model::ABM{<:DiscreteSpace}, r=1; kwargs...)\n\nReturn an iterable of all positions within \"radius\" r of the given position (which excludes given position). The position must match type with the spatial structure of the model.\n\nThe value of r and possible keywords operate identically to nearby_ids.\n\nThis function only exists for discrete spaces with a finite amount of positions.\n\nnearby_positions(position, model::ABM{<:OpenStreetMapSpace}; kwargs...) → positions\n\nFor OpenStreetMapSpace this means \"nearby intersections\" and operates directly on the underlying graph of the OSM, providing the intersection nodes nearest to the given position.\n\n\n\n\n\nnearby_positions(agent::AbstractAgent, model::ABM, r=1)\n\nSame as nearby_positions(agent.pos, model, r).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_nearby_id","page":"API","title":"Agents.random_nearby_id","text":"random_nearby_id(agent, model::ABM, r = 1; kwargs...) → id\n\nReturn the id of a random agent near the position of the given agent using an optimized algorithm from Reservoir sampling. Return nothing if no agents are nearby.\n\nThe value of the argument r and possible keywords operate identically to nearby_ids.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_nearby_agent","page":"API","title":"Agents.random_nearby_agent","text":"random_nearby_agent(agent, model::ABM, r = 1; kwargs...) → agent\n\nReturn the a random agent near the position of the given agent. Return nothing if no agent is nearby.\n\nThe value of the argument r and possible keywords operate identically to nearby_ids.\n\n\n\n\n\n","category":"function"},{"location":"api/#A-note-on-iteration-1","page":"API","title":"A note on iteration","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Most iteration in Agents.jl is dynamic and lazy, when possible, for performance reasons.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Dynamic means that when iterating over the result of e.g. the ids_in_position function, the iterator will be affected by actions that would alter its contents. Specifically, imagine the scenario","category":"page"},{"location":"api/#","page":"API","title":"API","text":"using Agents\n# We don't need to make a new agent type here,\n# we use the minimal agent for 4-dimensional grid spaces\nmodel = ABM(GridAgent{4}, GridSpace((5, 5, 5, 5)))\nadd_agent!((1, 1, 1, 1), model)\nadd_agent!((1, 1, 1, 1), model)\nadd_agent!((2, 1, 1, 1), model)\nfor id in ids_in_position((1, 1, 1, 1), model)\n    kill_agent!(id, model)\nend\ncollect(allids(model))","category":"page"},{"location":"api/#","page":"API","title":"API","text":"You will notice that only 1 agent got killed. This is simply because the final state of the iteration of ids_in_position was reached unnaturally, because the length of its output was reduced by 1 during iteration. To avoid problems like these, you need to collect the iterator to have a non dynamic version.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Lazy means that when possible the outputs of the iteration are not collected and instead are generated on the fly. A good example to illustrate this is nearby_ids, where doing something like","category":"page"},{"location":"api/#","page":"API","title":"API","text":"a = random_agent(model)\nsort!(nearby_ids(random_agent(model), model))","category":"page"},{"location":"api/#","page":"API","title":"API","text":"leads to error, since you cannot sort! the returned iterator. This can be easily solved by adding a collect in between:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"a = random_agent(model)\nsort!(collect(nearby_agents(a, model)))","category":"page"},{"location":"api/#Higher-order-interactions-1","page":"API","title":"Higher-order interactions","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"There may be times when pair-wise, triplet-wise or higher interactions need to be accounted for across most or all of the model's agent population. The following methods provide an interface for such calculation.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"These methods follow the conventions outlined above in A note on iteration.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"iter_agent_groups\nmap_agent_groups\nindex_mapped_groups","category":"page"},{"location":"api/#Agents.iter_agent_groups","page":"API","title":"Agents.iter_agent_groups","text":"iter_agent_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)\n\nReturn an iterator over all agents of the model, grouped by order. When order = 2, the iterator returns agent pairs, e.g (agent1, agent2) and when order = 3: agent triples, e.g. (agent1, agent7, agent8). order must be larger than 1 but has no upper bound.\n\nIndex order is provided by the model scheduler by default, but can be altered with the scheduler keyword.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.map_agent_groups","page":"API","title":"Agents.map_agent_groups","text":"map_agent_groups(order::Int, f::Function, model::ABM; kwargs...)\nmap_agent_groups(order::Int, f::Function, model::ABM, filter::Function; kwargs...)\n\nApplies function f to all grouped agents of an iter_agent_groups iterator. kwargs are passed to the iterator method. f must take the form f(NTuple{O,AgentType}), where the dimension O is equal to order.\n\nOptionally, a filter function that accepts an iterable and returns a Bool can be applied to remove unwanted matches from the results. Note: This option cannot keep matrix order, so should be used in conjuction with index_mapped_groups to associate agent ids with the resultant data.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.index_mapped_groups","page":"API","title":"Agents.index_mapped_groups","text":"index_mapped_groups(order::Int, model::ABM; scheduler = Schedulers.by_id)\nindex_mapped_groups(order::Int, model::ABM, filter::Function; scheduler = Schedulers.by_id)\n\nReturn an iterable of agent ids in the model, meeting the filter criteria if used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Minimal-agent-types-1","page":"API","title":"Minimal agent types","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The @agent macro can be used to define new agent types from the minimal agent types that are listed below:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"NoSpaceAgent\nGraphAgent\nGridAgent\nContinuousAgent\nOSMAgent","category":"page"},{"location":"api/#Agents.NoSpaceAgent","page":"API","title":"Agents.NoSpaceAgent","text":"NoSpaceAgent <: AbstractAgent\n\nThe minimal agent struct for usage with nothing as space (i.e., no space). It has the field id::Int, and potentially other internal fields that are not documentated as part of the public API. See also @agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.GraphAgent","page":"API","title":"Agents.GraphAgent","text":"GraphAgent <: AbstractAgent\n\nThe minimal agent struct for usage with GraphSpace. It has an additional pos::Int field. See also @agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.GridAgent","page":"API","title":"Agents.GridAgent","text":"GridAgent{D} <: AbstractAgent\n\nThe minimal agent struct for usage with D-dimensional GridSpace. It has an additional pos::NTuple{D,Int} field. See also @agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.ContinuousAgent","page":"API","title":"Agents.ContinuousAgent","text":"ContinuousAgent{D} <: AbstractAgent\n\nThe minimal agent struct for usage with D-dimensional ContinuousSpace. It has the additoinal fields pos::NTuple{D,Float64}, vel::NTuple{D,Float64}. See also @agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.OSMAgent","page":"API","title":"Agents.OSMAgent","text":"OSMAgent <: AbstractAgent\n\nThe minimal agent struct for usage with OpenStreetMapSpace. It has an additional field pos::Tuple{Int,Int,Float64}. See also @agent.\n\n\n\n\n\n","category":"type"},{"location":"api/#Parameter-scanning-1","page":"API","title":"Parameter scanning","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"paramscan","category":"page"},{"location":"api/#Agents.paramscan","page":"API","title":"Agents.paramscan","text":"paramscan(parameters, initialize; kwargs...) → adf, mdf\n\nPerform a parameter scan of a ABM simulation output by collecting data from all parameter combinations into dataframes (one for agent data, one for model data). The dataframes columns are both the collected data (as in run!) but also the input parameter values used.\n\nparameters is a dictionary with key type Symbol which contains various parameters that will be scanned over (as well as other parameters that remain constant). This function uses DrWatson's dict_list convention. This means that every entry of parameters that is a Vector contains many parameters and thus is scanned. All other entries of parameters that are not Vectors are not expanded in the scan.\n\nThe second argument initialize is a function that creates an ABM and returns it. It must accept keyword arguments which are the keys of the parameters dictionary. Since the user decides how to use input arguments to make an ABM, parameters can be used to affect model properties, space type and creation as well as agent properties, see the example below.\n\nKeywords\n\nThe following keywords modify the paramscan function:\n\ninclude_constants::Bool = false: by default, only the varying parameters (Vector in parameters) will be included in the output DataFrame. If true, constant parameters (non-Vector in parameteres) will also be included.\nparallel::Bool = false whether Distributed.pmap is invoked to run simulations in parallel. This must be used in conjunction with @everywhere (see Performance Tips).\nshowprogress::Bool = false whether a progressbar will be displayed to indicate % runs finished.\n\nAll other keywords are propagated into run!. Furthermore, agent_step!, model_step!, n are also keywords here, that are given to run! as arguments. Naturally, stepping functions and the number of time steps (agent_step!, model_step!, and n) and at least one of adata, mdata are mandatory. The adata, mdata lists shouldn't contain the parameters that are already in the parameters dictionary to avoid duplication.\n\nExample\n\nA runnable example that uses paramscan is shown in Schelling's segregation model. There, we define\n\nfunction initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)\n    space = GridSpaceSingle(griddims, periodic = false)\n    properties = Dict(:min_to_be_happy => min_to_be_happy)\n    model = ABM(SchellingAgent, space;\n                properties = properties, scheduler = Schedulers.randomly)\n    for n in 1:numagents\n        agent = SchellingAgent(n, (1, 1), false, n < numagents / 2 ? 1 : 2)\n        add_agent_single!(agent, model)\n    end\n    return model\nend\n\nand do a parameter scan by doing:\n\nhappyperc(moods) = count(moods) / length(moods)\nadata = [(:mood, happyperc)]\n\nparameters = Dict(\n    :min_to_be_happy => collect(2:5), # expanded\n    :numagents => [200, 300],         # expanded\n    :griddims => (20, 20),            # not Vector = not expanded\n)\n\nadf, _ = paramscan(parameters, initialize; adata, agent_step!, n = 3)\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-collection-1","page":"API","title":"Data collection","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"The central simulation function is run!, which is mentioned in our Tutorial. But there are other functions that are related to simulations listed here. Specifically, these functions aid in making custom data collection loops, instead of using the run! function.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"For example, the core loop of run! is just","category":"page"},{"location":"api/#","page":"API","title":"API","text":"df_agent = init_agent_dataframe(model, adata)\ndf_model = init_model_dataframe(model, mdata)\n\ns = 0\nwhile until(s, n, model)\n  if should_we_collect(s, model, when)\n      collect_agent_data!(df_agent, model, adata, s)\n  end\n  if should_we_collect(s, model, when_model)\n      collect_model_data!(df_model, model, mdata, s)\n  end\n  step!(model, agent_step!, model_step!, 1)\n  s += 1\nend\nreturn df_agent, df_model","category":"page"},{"location":"api/#","page":"API","title":"API","text":"(here until and should_we_collect are internal functions)","category":"page"},{"location":"api/#","page":"API","title":"API","text":"run! uses the following functions:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"init_agent_dataframe\ncollect_agent_data!\ninit_model_dataframe\ncollect_model_data!\ndataname","category":"page"},{"location":"api/#Agents.init_agent_dataframe","page":"API","title":"Agents.init_agent_dataframe","text":"init_agent_dataframe(model, adata) → agent_df\n\nInitialize a dataframe to add data later with collect_agent_data!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.collect_agent_data!","page":"API","title":"Agents.collect_agent_data!","text":"collect_agent_data!(df, model, properties, step = 0; obtainer = identity)\n\nCollect and add agent data into df (see run! for the dispatch rules of properties and obtainer). step is given because the step number information is not known.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.init_model_dataframe","page":"API","title":"Agents.init_model_dataframe","text":"init_model_dataframe(model, mdata) → model_df\n\nInitialize a dataframe to add data later with collect_model_data!. mdata can be a Vector or generator Function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.collect_model_data!","page":"API","title":"Agents.collect_model_data!","text":"collect_model_data!(df, model, properties, step = 0, obtainer = identity)\n\nSame as collect_agent_data! but for model data instead. properties can be a Vector or generator Function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.dataname","page":"API","title":"Agents.dataname","text":"dataname(k) → name\n\nReturn the name of the column of the i-th collected data where k = adata[i] (or mdata[i]). dataname also accepts tuples with aggregate and conditional values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Schedulers-1","page":"API","title":"Schedulers","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Schedulers","category":"page"},{"location":"api/#Agents.Schedulers","page":"API","title":"Agents.Schedulers","text":"Schedulers\n\nSubmodule containing all predefined schedulers of Agents.jl and the scheduling API. Schedulers have a very simple interface. They are functions that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a \"true\" iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an AgentBasedModel. You can also use the function schedule(model) to obtain the scheduled ID list, if you prefer to write your own step!-like loop.\n\nSee also Advanced scheduling for making more advanced schedulers.\n\nNotice that schedulers can be given directly to model creation, and thus become the \"default\" scheduler a model uses, but they can just as easily be incorporated in a model_step! function as shown in Advanced stepping.\n\n\n\n\n\n","category":"module"},{"location":"api/#Predefined-schedulers-1","page":"API","title":"Predefined schedulers","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Some useful schedulers are available below as part of the Agents.jl API:","category":"page"},{"location":"api/#","page":"API","title":"API","text":"Schedulers.fastest\nSchedulers.ByID\nSchedulers.Randomly\nSchedulers.Partially\nSchedulers.ByProperty\nSchedulers.ByType","category":"page"},{"location":"api/#Agents.Schedulers.fastest","page":"API","title":"Agents.Schedulers.fastest","text":"Schedulers.fastest\n\nA scheduler that activates all agents once per step in the order dictated by the agent's container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.Schedulers.ByID","page":"API","title":"Agents.Schedulers.ByID","text":"Schedulers.ByID()\n\nA non-allocating scheduler that activates all agents agents at each step according to their id.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Schedulers.Randomly","page":"API","title":"Agents.Schedulers.Randomly","text":"Schedulers.Randomly()\n\nA non-allocating scheduler that activates all agents once per step in a random order. Different random ordering is used at each different step.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Schedulers.Partially","page":"API","title":"Agents.Schedulers.Partially","text":"Schedulers.Partially(p)\n\nA non-allocating scheduler that at each step activates only p percentage of randomly chosen agents.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Schedulers.ByProperty","page":"API","title":"Agents.Schedulers.ByProperty","text":"Schedulers.ByProperty(property)\n\nA non-allocating scheduler that at each step activates the agents in an order dictated by their property, with agents with greater property acting first. property can be a Symbol, which just dictates which field of the agents to compare, or a function which inputs an agent and outputs a real number.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Schedulers.ByType","page":"API","title":"Agents.Schedulers.ByType","text":"Schedulers.ByType(shuffle_types::Bool, shuffle_agents::Bool, agent_union)\n\nA non-allocating scheduler useful only for mixed agent models using Union types.\n\nSetting shuffle_types = true groups by agent type, but randomizes the type order.\n\nOtherwise returns agents grouped in order of appearance in the Union.\n\nshuffle_agents = true randomizes the order of agents within each group, false returns\n\nthe default order of the container (equivalent to Schedulers.fastest).\n\nagent_union is a Union of all valid agent types (as passed to ABM)\n\n\n\n\n\nSchedulers.ByType((C, B, A), shuffle_agents::Bool)\n\nA non-allocating scheduler that activates agents by type in specified order (since Unions are not order preserving). shuffle_agents = true randomizes the order of agents within each group.\n\n\n\n\n\n","category":"type"},{"location":"api/#Advanced-scheduling-1","page":"API","title":"Advanced scheduling","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"You can use Function-like objects to make your scheduling possible of arbitrary events. For example, imagine that after the n-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define","category":"page"},{"location":"api/#","page":"API","title":"API","text":"mutable struct MyScheduler\n    n::Int # step number\n    w::Float64\nend","category":"page"},{"location":"api/#","page":"API","title":"API","text":"and then define a calling method for it like so","category":"page"},{"location":"api/#","page":"API","title":"API","text":"function (ms::MyScheduler)(model::ABM)\n    ms.n += 1 # increment internal counter by 1 each time its called\n              # be careful to use a *new* instance of this scheduler when plotting!\n    if ms.n < 10\n        return allids(model) # order doesn't matter in this case\n    else\n        ids = collect(allids(model))\n        # filter all ids whose agents have `w` less than some amount\n        filter!(id -> model[id].w < ms.w, ids)\n        return ids\n    end\nend","category":"page"},{"location":"api/#","page":"API","title":"API","text":"and pass it to e.g. step! by initializing it","category":"page"},{"location":"api/#","page":"API","title":"API","text":"ms = MyScheduler(100, 0.5)\nstep!(model, agentstep, modelstep, 100; scheduler = ms)","category":"page"},{"location":"api/#Ensemble-runs-and-Parallelization-1","page":"API","title":"Ensemble runs and Parallelization","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"ensemblerun!","category":"page"},{"location":"api/#Agents.ensemblerun!","page":"API","title":"Agents.ensemblerun!","text":"ensemblerun!(models::Vector, agent_step!, model_step!, n; kwargs...)\n\nPerform an ensemble simulation of run! for all model ∈ models. Each model should be a (different) instance of an AgentBasedModel but probably initialized with a different random seed or different initial agent distribution. All models obey the same rules agent_step!, model_step! and are evolved for n.\n\nSimilarly to run! this function will collect data. It will furthermore add one additional column to the dataframe called :ensemble, which has an integer value counting the ensemble member. The function returns agent_df, model_df, models.\n\nIf you want to scan parameters and at the same time run multiple simulations at each parameter combination, simply use seed as a parameter, and use that parameter to tune the model's initial random seed and/or agent distribution.\n\nSee example usage in Schelling's segregation model.\n\nKeywords\n\nThe following keywords modify the ensemblerun! function:\n\nparallel::Bool = false whether Distributed.pmap is invoked to run simulations in parallel. This must be used in conjunction with @everywhere (see Performance Tips).\nshowprogress::Bool = false whether a progressbar will be displayed to indicate % runs finished.\n\nAll other keywords are propagated to run! as-is.\n\n\n\n\n\nensemblerun!(generator, agent_step!, model_step!, n; kwargs...)\n\nGenerate many ABMs and propagate them into ensemblerun!(models, ...) using the provided generator which is a one-argument function whose input is a seed.\n\nThis method has additional keywords ensemble = 5, seeds = rand(UInt32, ensemble).\n\n\n\n\n\n","category":"function"},{"location":"api/#How-to-use-Distributed-1","page":"API","title":"How to use Distributed","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"To use the parallel=true option of ensemblerun! you need to load Agents and define your fundamental types at all processors. How to do this is shown in Ensembles and distributed computing section of Schelling's Segregation Model example. See also the Performance Tips page for parallelization.","category":"page"},{"location":"api/#Path-finding-1","page":"API","title":"Path-finding","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Pathfinding\nPathfinding.AStar\nPathfinding.penaltymap\nPathfinding.nearby_walkable\nPathfinding.random_walkable","category":"page"},{"location":"api/#Agents.Pathfinding","page":"API","title":"Agents.Pathfinding","text":"Pathfinding\n\nSubmodule containing functionality for path-finding based on the A* algorithm. Currently available for GridSpace and ContinuousSpace. Discretization of ContinuousSpace is taken care of internally.\n\nYou can enable path-finding and set its options by creating an instance of a Pathfinding.AStar struct. This must be passed to the relevant pathfinding functions during the simulation. Call plan_route! to set the destination for an agent. This triggers the algorithm to calculate a path from the agent's current position to the one specified. You can alternatively use plan_best_route! to choose the best target from a list. Once a target has been set, you can move an agent one step along its precalculated path using the move_along_route! function.\n\nRefer to the Maze Solver, Mountain Runners and Rabbit, Fox, Hawk examples using path-finding and see the available functions below as well.\n\n\n\n\n\n","category":"module"},{"location":"api/#Agents.Pathfinding.AStar","page":"API","title":"Agents.Pathfinding.AStar","text":"Pathfinding.AStar(space; kwargs...)\n\nEnables pathfinding for agents in the provided space (which can be a GridSpace or ContinuousSpace) using the A* algorithm. This struct must be passed into any pathfinding functions.\n\nFor ContinuousSpace, a walkmap or instance of PenaltyMap must be provided to specify the level of discretisation of the space.\n\nKeywords\n\ndiagonal_movement = true specifies if movement can be to diagonal neighbors of a tile, or only orthogonal neighbors. Only available for GridSpace\nadmissibility = 0.0 allows the algorithm to aprroximate paths to speed up pathfinding. A value of admissibility allows paths with at most (1+admissibility) times the optimal length.\nwalkmap = trues(size(space)) specifies the (un)walkable positions of the space. If specified, it should be a BitArray of the same size as the corresponding GridSpace. By default, agents can walk anywhere in the space.\ncost_metric = DirectDistance{D}() is an instance of a cost metric and specifies the metric used to approximate the distance between any two points.\n\nUtilization of all features of AStar occurs in the 3D Mixed-Agent Ecosystem with Pathfinding example.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Pathfinding.penaltymap","page":"API","title":"Agents.Pathfinding.penaltymap","text":"Pathfinding.penaltymap(pathfinder)\n\nReturn the penalty map of a Pathfinding.AStar if the Pathfinding.PenaltyMap metric is in use, nothing otherwise.\n\nIt is possible to mutate the map directly, for example Pathfinding.penaltymap(pathfinder)[15, 40] = 115 or Pathfinding.penaltymap(pathfinder) .= rand(50, 50). If this is mutated, a new path needs to be planned using plan_route!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.Pathfinding.nearby_walkable","page":"API","title":"Agents.Pathfinding.nearby_walkable","text":"Pathfinding.nearby_walkable(position, model::ABM{<:GridSpace{D}}, pathfinder::AStar{D}, r = 1)\n\nReturn an iterator over all nearby_positions within \"radius\" r of the given position (excluding position), which are walkable as specified by the given pathfinder.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.Pathfinding.random_walkable","page":"API","title":"Agents.Pathfinding.random_walkable","text":"Pathfinding.random_walkable(model, pathfinder::AStar{D})\n\nReturn a random position in the given model that is walkable as specified by the given pathfinder.\n\n\n\n\n\nPathfinding.random_walkable(pos, model::ABM{<:ContinuousSpace{D}}, pathfinder::AStar{D}, r = 1.0)\n\nReturn a random position within radius r of pos which is walkable, as specified by pathfinder. Return pos if no such position exists.\n\n\n\n\n\n","category":"function"},{"location":"api/#Pathfinding-Metrics-1","page":"API","title":"Pathfinding Metrics","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Pathfinding.DirectDistance\nPathfinding.MaxDistance\nPathfinding.PenaltyMap","category":"page"},{"location":"api/#Agents.Pathfinding.DirectDistance","page":"API","title":"Agents.Pathfinding.DirectDistance","text":"Pathfinding.DirectDistance{D}([direction_costs::Vector{Int}]) <: CostMetric{D}\n\nDistance is approximated as the shortest path between the two points, provided the walkable property of Pathfinding.AStar allows. Optionally provide a Vector{Int} that represents the cost of going from a tile to the neighboring tile on the i dimensional diagonal (default is 10√i).\n\nIf diagonal_movement=false in Pathfinding.AStar, neighbors in diagonal positions will be excluded. Cost defaults to the first value of the provided vector.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Pathfinding.MaxDistance","page":"API","title":"Agents.Pathfinding.MaxDistance","text":"Pathfinding.MaxDistance{D}() <: CostMetric{D}\n\nDistance between two tiles is approximated as the maximum of absolute difference in coordinates between them.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.Pathfinding.PenaltyMap","page":"API","title":"Agents.Pathfinding.PenaltyMap","text":"Pathfinding.PenaltyMap(pmap::Array{Int,D} [, base_metric::CostMetric]) <: CostMetric{D}\n\nDistance between two positions is the sum of the shortest distance between them and the absolute difference in penalty.\n\nA penalty map (pmap) is required. For pathfinding in GridSpace, this should be the same dimensions as the space. For pathfinding in ContinuousSpace, the size of this map determines the granularity of the underlying grid, and should agree with the size of the walkable map.\n\nDistance is calculated using Pathfinding.DirectDistance by default, and can be changed by specifying base_metric.\n\nAn example usage can be found in Mountain Runners.\n\n\n\n\n\n","category":"type"},{"location":"api/#","page":"API","title":"API","text":"Building a custom metric is straightforward, if the provided ones do not suit your purpose. See the Developer Docs for details.","category":"page"},{"location":"api/#Save,-Load,-Checkpoints-1","page":"API","title":"Save, Load, Checkpoints","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"There may be scenarios where interacting with data in the form of files is necessary. The following functions provide an interface to save/load data to/from files.","category":"page"},{"location":"api/#","page":"API","title":"API","text":"AgentsIO.save_checkpoint\nAgentsIO.load_checkpoint\nAgentsIO.populate_from_csv!\nAgentsIO.dump_to_csv","category":"page"},{"location":"api/#Agents.AgentsIO.save_checkpoint","page":"API","title":"Agents.AgentsIO.save_checkpoint","text":"AgentsIO.save_checkpoint(filename, model::ABM)\n\nWrite the entire model to file specified by filename. The following points should be considered before using this functionality:\n\nOpenStreetMap data is not saved. The path to the map should be specified when loading the model using the map keyword of AgentsIO.load_checkpoint.\nFunctions are not saved, including stepping functions, schedulers, and update_vel!. The last two can be provided to AgentsIO.load_checkpoint using the appropriate keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.AgentsIO.load_checkpoint","page":"API","title":"Agents.AgentsIO.load_checkpoint","text":"AgentsIO.load_checkpoint(filename; kwargs...)\n\nLoad the model saved to the file specified by filename.\n\nKeywords\n\nscheduler = Schedulers.fastest specifies what scheduler should be used for the model.\nwarn = true can be used to disable warnings from type checks on the   agent type.\n\nContinuousSpace specific:\n\nupdate_vel! specifies a function that should be used to update each agent's velocity before it is moved. Refer to ContinuousSpace for details.\n\nOpenStreetMapSpace specific:\n\nmap is a path to the OpenStreetMap to be used for the space. This is a required parameter if the space is OpenStreetMapSpace.\nuse_cache = false, trim_to_connected_graph = true refer to OpenStreetMapSpace\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.AgentsIO.populate_from_csv!","page":"API","title":"Agents.AgentsIO.populate_from_csv!","text":"AgentsIO.populate_from_csv!(model, filename [, agent_type, col_map]; row_number_is_id, kwargs...)\n\nPopulate the given model using CSV data contained in filename. Use agent_type to specify the type of agent to create (In the case of multi-agent models) or a function that returns an agent to add to the model. The CSV row is splatted into the agent_type constructor/function.\n\ncol_map is a Dict{Symbol,Int} specifying a mapping of keyword-arguments to row number. If col_map is specified, the specified data is splatted as keyword arguments.\n\nThe keyword row_number_is_id = false specifies whether the row number will be passed as the first argument (or as id keyword) to agent_type.\n\nAny other keyword arguments are forwarded to CSV.Rows. If the types keyword is not specified and agent_type is a struct, then the mapping from struct field to type will be used. Tuple{...} fields will be suffixed with _1, _2, ... similarly to AgentsIO.dump_to_csv\n\nFor example,\n\nstruct Foo <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Int}\n    foo::Tuple{Int,String}\nend\n\nmodel = ABM(Foo, ...)\nAgentsIO.populate_from_csv!(model, \"test.csv\")\n\nHere, types will be inferred to be\n\nDict(\n    :id => Int,\n    :pos_1 => Int,\n    :pos_2 => Int,\n    :foo_1 => Int,\n    :foo_2 => String,\n)\n\nIt is not necessary for all these fields to be present as columns in the CSV. Any column names that match will be converted to the appropriate type. There should exist a constructor for Foo taking the appropriate combination of fields as parameters.\n\nIf \"test.csv\" contains the following columns: pos_1, pos_2, foo_1, foo_2, then model can be populated as AgentsIO.populate_from_csv!(model, \"test.csv\"; row_number_is_id = true).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.AgentsIO.dump_to_csv","page":"API","title":"Agents.AgentsIO.dump_to_csv","text":"AgentsIO.dump_to_csv(filename, agents [, fields]; kwargs...)\n\nDump agents to the CSV file specified by filename. agents is any iterable sequence of types, such as from allagents. fields is an iterable sequence of Symbols specifying which fields of each agent are dumped. If not explicitly specified, it is automatically inferred using eltype(agents). All kwargs... are forwarded to CSV.write.\n\nAll Tuple{...} fields are flattened to multiple columns suffixed by _1, _2... similarly to AgentsIO.populate_from_csv!\n\nFor example,\n\nstruct Foo <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Int}\n    foo::Tuple{Int,String}\nend\n\nmodel = ABM(Foo, ...)\n...\nAgentsIO.dump_to_csv(\"test.csv\", allagents(model))\n\nThe resultant \"test.csv\" file will contain the following columns: id, pos_1, pos_2, foo_1, foo_2.\n\n\n\n\n\n","category":"function"},{"location":"api/#","page":"API","title":"API","text":"In case you require custom serialization for model properties, refer to the Developer Docs for details.","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/flock.jl\"","category":"page"},{"location":"examples/flock/#Flocking-model-1","page":"Flocking model","title":"Flocking model","text":"","category":"section"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../flocking.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"The flock model illustrates how flocking behavior can emerge when each bird follows three simple rules:","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"maintain a minimum distance from other birds to avoid collision\nfly towards the average position of neighbors\nfly in the average direction of neighbors","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"It is also available from the Models module as Models.flocking.","category":"page"},{"location":"examples/flock/#Defining-the-core-structures-1","page":"Flocking model","title":"Defining the core structures","text":"","category":"section"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"We begin by calling the required packages and defining an agent type representing a bird.","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"using Agents, LinearAlgebra\nusing Random # hide\n\n@agent Bird ContinuousAgent{2} begin\n    speed::Float64\n    cohere_factor::Float64\n    separation::Float64\n    separate_factor::Float64\n    match_factor::Float64\n    visual_distance::Float64\nend","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"The fields id and pos, which are required for agents on ContinuousSpace, are part of the struct. The field vel, which is also added by using ContinuousAgent is required for using move_agent! in ContinuousSpace with a time-stepping method. speed defines how far the bird travels in the direction defined by vel per step. seperation defines the minimum distance a bird must maintain from its neighbors. visual_distance refers to the distance a bird can see and defines a radius of neighboring birds. The contribution of each rule defined above recieves an importance weight: cohere_factor is the importance of maintaining the average position of neighbors, match_factor is the importance of matching the average trajectory of neighboring birds, and separate_factor is the importance of maining the minimum distance from neighboring birds.","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"The function initialize_model generates birds and returns a model object using default values.","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"function initialize_model(;\n    n_birds = 100,\n    speed = 1.0,\n    cohere_factor = 0.25,\n    separation = 4.0,\n    separate_factor = 0.25,\n    match_factor = 0.01,\n    visual_distance = 5.0,\n    extent = (100, 100),\n)\n    space2d = ContinuousSpace(extent; spacing = visual_distance/1.5)\n    model = ABM(Bird, space2d, scheduler = Schedulers.Randomly())\n    for _ in 1:n_birds\n        vel = Tuple(rand(model.rng, 2) * 2 .- 1)\n        add_agent!(\n            model,\n            vel,\n            speed,\n            cohere_factor,\n            separation,\n            separate_factor,\n            match_factor,\n            visual_distance,\n        )\n    end\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/flock/#Defining-the-agent_step!-1","page":"Flocking model","title":"Defining the agent_step!","text":"","category":"section"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"agent_step! is the primary function called for each step and computes velocity according to the three rules defined above.","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"function agent_step!(bird, model)\n    # Obtain the ids of neighbors within the bird's visual distance\n    neighbor_ids = nearby_ids(bird, model, bird.visual_distance)\n    N = 0\n    match = separate = cohere = (0.0, 0.0)\n    # Calculate behaviour properties based on neighbors\n    for id in neighbor_ids\n        N += 1\n        neighbor = model[id].pos\n        heading = neighbor .- bird.pos\n\n        # `cohere` computes the average position of neighboring birds\n        cohere = cohere .+ heading\n        if euclidean_distance(bird.pos, neighbor, model) < bird.separation\n            # `separate` repels the bird away from neighboring birds\n            separate = separate .- heading\n        end\n        # `match` computes the average trajectory of neighboring birds\n        match = match .+ model[id].vel\n    end\n    N = max(N, 1)\n    # Normalise results based on model input and neighbor count\n    cohere = cohere ./ N .* bird.cohere_factor\n    separate = separate ./ N .* bird.separate_factor\n    match = match ./ N .* bird.match_factor\n    # Compute velocity based on rules defined above\n    bird.vel = (bird.vel .+ cohere .+ separate .+ match) ./ 2\n    bird.vel = bird.vel ./ norm(bird.vel)\n    # Move bird according to new velocity and speed\n    move_agent!(bird, model, bird.speed)\nend","category":"page"},{"location":"examples/flock/#Plotting-the-flock-1","page":"Flocking model","title":"Plotting the flock","text":"","category":"section"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"using InteractiveDynamics\nusing CairoMakie\nCairoMakie.activate!() # hide","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"The great thing about abmplot is its flexibility. We can incorporate the direction of the birds when plotting them, by making the \"marker\" function am create a Polygon: a triangle with same orientation as the bird's velocity. It is as simple as defining the following function:","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"const bird_polygon = Polygon(Point2f[(-0.5, -0.5), (1, 0), (-0.5, 0.5)])\nfunction bird_marker(b::Bird)\n    φ = atan(b.vel[2], b.vel[1]) #+ π/2 + π\n    scale(rotate2D(bird_polygon, φ), 2)\nend","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"Where we have used the utility functions scale and rotate2D to act on a predefined polygon. We now give bird_marker to abmplot, and notice how the as keyword is meaningless when using polygons as markers.","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"model = initialize_model()\nfigure, = abmplot(model; am = bird_marker)\nfigure","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"And let's also do a nice little video for it:","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"abmvideo(\n    \"flocking.mp4\", model, agent_step!;\n    am = bird_marker,\n    framerate = 20, frames = 100,\n    title = \"Flocking\"\n)","category":"page"},{"location":"examples/flock/#","page":"Flocking model","title":"Flocking model","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../flocking.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/measurements.jl\"","category":"page"},{"location":"examples/measurements/#Providing-uncertainty-with-Measurements.jl-1","page":"Measurements.jl","title":"Providing uncertainty with Measurements.jl","text":"","category":"section"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Measurements.jl provides automatic error propagation, and integrates seamlessly with much of the Julia ecosystem.","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Here, we'll slightly modify the Daisyworld example, to simulate some measurement uncertainty in our world's parameters.","category":"page"},{"location":"examples/measurements/#Setup-1","page":"Measurements.jl","title":"Setup","text":"","category":"section"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"First we'll construct our agents.","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"using Agents\nusing Measurements\n\n@agent Daisy GridAgent{2} begin\n    breed::Symbol\n    age::Int\n    albedo::AbstractFloat # Allow Measurements\nend\n\n@agent Land GridAgent{2} begin\n    temperature::AbstractFloat # Allow Measurements\nend","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Notice that there is only one small difference between this version and the original example model: the use of AbstractFloat instead of Float64 for the albedo and temperature parameters. Behaviour between these two types is practically equivalent from our perspective, but it allows us to use an uncertain value for our two parameters. 1.0 ± 0.1 rather than 1.0 for example. We could also be specific here and bind the parameters with type Measurement{Float64} as well.","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Next, we'll implement all the important functions for DaisyWorld. If you want to know what each of these functions do, see the Daisyworld example, as they are copied directly from there.","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"using CairoMakie\nusing Statistics: mean\nimport DrWatson: @dict\nimport StatsBase\nCairoMakie.activate!() # hide\nusing Random # hide\n\nconst DaisyWorld = ABM{<:GridSpace,Union{Daisy,Land}}\n\nfunction update_surface_temperature!(pos::Dims{2}, model::DaisyWorld)\n    ids = ids_in_position(pos, model)\n    absorbed_luminosity = if length(ids) == 1\n        (1 - model.surface_albedo) * model.solar_luminosity\n    else\n        (1 - model[ids[2]].albedo) * model.solar_luminosity\n    end\n    local_heating = absorbed_luminosity > 0 ? 72 * log(absorbed_luminosity) + 80 : 80\n    T0 = model[ids[1]].temperature\n    model[ids[1]].temperature = (T0 + local_heating) / 2\nend\n\nfunction diffuse_temperature!(pos::Dims{2}, model::DaisyWorld)\n    ratio = get(model.properties, :ratio, 0.5)\n    ids = nearby_ids(pos, model)\n    meantemp = sum(model[i].temperature for i in ids if model[i] isa Land) / 8\n    land = model[ids_in_position(pos, model)[1]]\n    land.temperature = (1 - ratio) * land.temperature + ratio * meantemp\nend\n\nfunction propagate!(pos::Dims{2}, model::DaisyWorld)\n    ids = ids_in_position(pos, model)\n    if length(ids) > 1\n        daisy = model[ids[2]]\n        temperature = model[ids[1]].temperature\n        seed_threshold = (0.1457 * temperature - 0.0032 * temperature^2) - 0.6443\n        if rand(model.rng) < seed_threshold\n            empty_neighbors = Tuple{Int,Int}[]\n            neighbors = nearby_positions(pos, model)\n            for n in neighbors\n                if length(ids_in_position(n, model)) == 1\n                    push!(empty_neighbors, n)\n                end\n            end\n            if !isempty(empty_neighbors)\n                seeding_place = rand(model.rng, empty_neighbors)\n                a = Daisy(nextid(model), seeding_place, daisy.breed, 0, daisy.albedo)\n                add_agent_pos!(a, model)\n            end\n        end\n    end\nend\n\nfunction agent_step!(agent::Daisy, model::DaisyWorld)\n    agent.age += 1\n    agent.age >= model.max_age && kill_agent!(agent, model)\nend\n\nagent_step!(agent::Land, model::DaisyWorld) = nothing\n\nfunction model_step!(model)\n    for p in positions(model)\n        update_surface_temperature!(p, model)\n        diffuse_temperature!(p, model)\n        propagate!(p, model)\n    end\n    model.tick += 1\n    solar_activity!(model)\nend\n\nfunction solar_activity!(model::DaisyWorld)\n    if model.scenario == :ramp\n        if model.tick > 200 && model.tick <= 400\n            model.solar_luminosity += model.solar_change\n        end\n        if model.tick > 500 && model.tick <= 750\n            model.solar_luminosity -= model.solar_change / 2\n        end\n    elseif model.scenario == :change\n        model.solar_luminosity += model.solar_change\n    end\nend","category":"page"},{"location":"examples/measurements/#Adding-Uncertainty-1","page":"Measurements.jl","title":"Adding Uncertainty","text":"","category":"section"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Now, we can write a constructor function, and use uncertainly values which will propagate automatically through our model.","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"function daisyworld(;\n    griddims = (30, 30),\n    max_age = 25,\n    init_white = 0.2,\n    init_black = 0.2,\n    albedo_white = 0.75,\n    albedo_black = 0.25,\n    # Surface albedo measurements are complicated for our satellites perhaps\n    surface_albedo = 0.4 ± 0.15,\n    # Measurements from the sun are generally stable, but fluctuate around 10%\n    solar_change = 0.005 ± 0.002,\n    solar_luminosity = 1.0 ± 0.1,\n    scenario = :default,\n)\n\n    space = GridSpace(griddims)\n    properties = @dict max_age surface_albedo solar_luminosity solar_change scenario\n    properties[:tick] = 0\n    daisysched(model) = [a.id for a in allagents(model) if a isa Daisy]\n    model = ABM(\n        Union{Daisy,Land},\n        space;\n        scheduler = daisysched,\n        properties = properties,\n        warn = false,\n    )\n\n    # An uncertain initial temperature, solely for type stability\n    fill_space!(Land, model, 0.0 ± 0.0)\n    grid = collect(positions(model))\n    num_positions = prod(griddims)\n    white_positions =\n        StatsBase.sample(grid, Int(init_white * num_positions); replace = false)\n    for wp in white_positions\n        wd = Daisy(nextid(model), wp, :white, rand(model.rng, 0:max_age), albedo_white)\n        add_agent_pos!(wd, model)\n    end\n    allowed = setdiff(grid, white_positions)\n    black_positions =\n        StatsBase.sample(allowed, Int(init_black * num_positions); replace = false)\n    for bp in black_positions\n        wd = Daisy(nextid(model), bp, :black, rand(model.rng, 0:max_age), albedo_black)\n        add_agent_pos!(wd, model)\n    end\n\n    return model\nend","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"You see we've included uncertainty in four places: surface albedo and initial temperature, and the two solar luminosity values. We do not require changes to any model code, nor handle these parameters in any special way; for example 2.0 * surface_albedo is a regular operation. Errors will be propagated under the hood automatically.","category":"page"},{"location":"examples/measurements/#Visualizing-the-Result-1","page":"Measurements.jl","title":"Visualizing the Result","text":"","category":"section"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Similar to the Daisyworld example, we will now check out how the surface temperature and daisy count fares when solar luminosity ramps up.","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"First, some helper functions","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"black(a) = a.breed == :black\nwhite(a) = a.breed == :white\ndaisies(a) = a isa Daisy\n\nland(a) = a isa Land\nadata = [(black, count, daisies), (white, count, daisies), (:temperature, mean, land)]\n\nmdata = [:solar_luminosity]","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"And now the simulation","category":"page"},{"location":"examples/measurements/#","page":"Measurements.jl","title":"Measurements.jl","text":"Random.seed!(19) # hide\nmodel = daisyworld(scenario = :ramp)\nagent_df, model_df =\n    run!(model, agent_step!, model_step!, 1000; adata = adata, mdata = mdata)\n\nf = Figure(resolution = (600, 800))\nax = f[1, 1] = Axis(f, ylabel = \"Daisy count\", title = \"Daisyworld Analysis\")\nlb = lines!(ax, agent_df.step, agent_df.count_black_daisies, linewidth = 2, color = :blue)\nlw = lines!(ax, agent_df.step, agent_df.count_white_daisies, linewidth = 2, color = :red)\nleg =\n    f[1, 1] = Legend(\n        f,\n        [lb, lw],\n        [\"black\", \"white\"],\n        tellheight = false,\n        tellwidth = false,\n        halign = :right,\n        valign = :top,\n        margin = (10, 10, 10, 10),\n    )\n\nax2 = f[2, 1] = Axis(f, ylabel = \"Temperature\")\nhighband =\n    Measurements.value.(agent_df[!, dataname(adata[3])]) +\n    Measurements.uncertainty.(agent_df[!, dataname(adata[3])])\nlowband =\n    Measurements.value.(agent_df[!, dataname(adata[3])]) -\n    Measurements.uncertainty.(agent_df[!, dataname(adata[3])])\nband!(ax2, agent_df.step, lowband, highband, color = (:steelblue, 0.5))\nlines!(\n    ax2,\n    agent_df.step,\n    Measurements.value.(agent_df[!, dataname(adata[3])]),\n    linewidth = 2,\n    color = :blue,\n)\n\nax3 = f[3, 1] = Axis(f, ylabel = \"Luminosity\")\nhighband =\n    Measurements.value.(model_df.solar_luminosity) +\n    Measurements.uncertainty.(model_df.solar_luminosity)\nlowband =\n    Measurements.value.(model_df.solar_luminosity) -\n    Measurements.uncertainty.(model_df.solar_luminosity)\nband!(ax3, agent_df.step, lowband, highband, color = (:steelblue, 0.5))\nlines!(\n    ax3,\n    agent_df.step,\n    Measurements.value.(model_df.solar_luminosity),\n    linewidth = 2,\n    color = :blue,\n)\nf","category":"page"},{"location":"devdocs/#Developer-Docs-1","page":"Developer Docs","title":"Developer Docs","text":"","category":"section"},{"location":"devdocs/#Cloning-the-repository-1","page":"Developer Docs","title":"Cloning the repository","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Since we include documentation with many animated gifs and videos in the repository, a standard clone can be larger than expected. If you wish to do any development work, it is better to use","category":"page"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"git clone https://github.com/JuliaDynamics/Agents.jl.git --single-branch","category":"page"},{"location":"devdocs/#Creating-a-new-space-type-1","page":"Developer Docs","title":"Creating a new space type","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Creating a new space type within Agents.jl is quite simple and requires the extension of only 5 methods to support the entire Agents.jl API. The exact specifications on how to create a new space type are contained within the source file: src/core/space_interaction_API.jl.","category":"page"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"In principle, the following should be done:","category":"page"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Think about what the agent position type should be.\nThink about how the space type will keep track of the agent positions, so that it is possible to implement the function nearby_ids.\nImplement the struct that represents your new space, while making it a subtype of AbstractSpace.\nExtend random_position(model).\nExtend add_agent_to_space!(agent, model), remove_agent_from_space!(agent, model). This already provides access to add_agent!, kill_agent! and move_agent!.\nExtend nearby_ids(position, model, r).\nCreate a new \"minimal\" agent type to be used with @agent (see the source code of GraphAgent for an example).","category":"page"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"And that's it! Every function of the main API will now work. In some situations you might want to explicitly extend other functions such as move_agent! for performance reasons.","category":"page"},{"location":"devdocs/#Designing-a-new-Pathfinder-Cost-Metric-1","page":"Developer Docs","title":"Designing a new Pathfinder Cost Metric","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"To define a new cost metric, simply make a struct that subtypes CostMetric and provide a delta_cost function for it. These methods work solely for A* at present, but will be available for other pathfinder algorithms in the future.","category":"page"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Pathfinding.CostMetric\nPathfinding.delta_cost","category":"page"},{"location":"devdocs/#Agents.Pathfinding.CostMetric","page":"Developer Docs","title":"Agents.Pathfinding.CostMetric","text":"Pathfinding.CostMetric{D}\n\nAn abstract type representing a metric that measures the approximate cost of travelling between two points in a D dimensional grid.\n\n\n\n\n\n","category":"type"},{"location":"devdocs/#Agents.Pathfinding.delta_cost","page":"Developer Docs","title":"Agents.Pathfinding.delta_cost","text":"Pathfinding.delta_cost(pathfinder::GridPathfinder{D}, metric::M, from, to) where {M<:CostMetric}\n\nCalculate an approximation for the cost of travelling from from to to (both of type NTuple{N,Int}. Expects a return value of Float64.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#Implementing-custom-serialization-1","page":"Developer Docs","title":"Implementing custom serialization","text":"","category":"section"},{"location":"devdocs/#For-model-properties-1","page":"Developer Docs","title":"For model properties","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Custom serialization may be required if your properties contain non-serializable data, such as functions. Alternatively, if it is possible to recalculate some properties during deserialization it may be space-efficient to not save them. To implement custom serialization, define methods for the to_serializable and from_serializable functions:","category":"page"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"AgentsIO.to_serializable\nAgentsIO.from_serializable","category":"page"},{"location":"devdocs/#Agents.AgentsIO.to_serializable","page":"Developer Docs","title":"Agents.AgentsIO.to_serializable","text":"AgentsIO.to_serializable(t)\n\nReturn the serializable form of the passed value. This defaults to the value itself, unless a more specific method is defined. Define a method for this function and for AgentsIO.from_serializable if you need custom serialization for model properties. This also enables passing keyword arguments to AgentsIO.load_checkpoint and having access to them during deserialization of the properties. Some possible scenarios where this may be required are:\n\nYour properties contain functions (or any type not supported by JLD2.jl). These may not be (de)serialized correctly. This could result in checkpoint files that cannot be loaded back in, or contain reconstructed types that do not retain their data/functionality.\nYour properties contain data that can be recalculated during deserialization. Omitting such properties can reduce the size of the checkpoint file, at the expense of some extra computation at deserialization.\n\nIf your model properties do not fall in the above scenarios, you do not need to use this function.\n\nThis function, and AgentsIO.from_serializable is not called recursively on every type/value during serialization. The final serialization functionality is enabled by JLD2.jl. To define custom serialization for every occurence of a specific type (such as agent structs), refer to the Custom Serialization section of JLD2.jl documentation.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#Agents.AgentsIO.from_serializable","page":"Developer Docs","title":"Agents.AgentsIO.from_serializable","text":"AgentsIO.from_serializable(t; kwargs...)\n\nGiven a value in its serializable form, return the original version. This defaults to the value itself, unless a more specific method is defined. Define a method for this function and for AgentsIO.to_serializable if you need custom serialization for model properties. This also enables passing keyword arguments to AgentsIO.load_checkpoint and having access to them through kwargs.\n\nRefer to AgentsIO.to_serializable for more info.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#For-agent-structs-1","page":"Developer Docs","title":"For agent structs","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Similarly to model properties, you may need to implement custom serialization for agent structs. from_serializable and to_serializable are not called during (de)serialization of agent structs. Instead, JLD2's custom serialization functionality should be used. All instances of the agent struct will be converted to and from the specified type during serialization. For OpenStreetMap agents, the position, destination and route are saved separately. These values will be loaded back in during deserialization of the model and override any values in the agent structs. To save space, the agents in the serialized model will have empty route fields.","category":"page"},{"location":"devdocs/#OpenStreetMapSpace-internals-1","page":"Developer Docs","title":"OpenStreetMapSpace internals","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"Details about the internal details of the OSMSpace are discussed in the docstring of OSM.OpenStreetMapPath.","category":"page"},{"location":"devdocs/#Benchmarking-1","page":"Developer Docs","title":"Benchmarking","text":"","category":"section"},{"location":"devdocs/#","page":"Developer Docs","title":"Developer Docs","text":"As Agents.jl is developed we want to monitor code efficiency through benchmarks. A benchmark is a function or other bit of code whose execution is timed so that developers and users can keep track of how long different API functions take when used in various ways. Individual benchmarks can be organized into suites of benchmark tests. See the benchmark directory to view Agents.jl's benchmark suites. Follow these examples to add your own benchmarks for your Agents.jl contributions. See the BenchmarkTools quickstart guide, toy example benchmark suite, and the BenchmarkTools.jl manual for more information on how to write your own benchmarks.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/schoolyard.jl\"","category":"page"},{"location":"examples/schoolyard/#Social-networks-with-Graphs.jl-1","page":"Graphs.jl","title":"Social networks with Graphs.jl","text":"","category":"section"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../schoolyard.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"Many ABM frameworks provide graph infrastructure for analysing network properties of agents. Agents.jl is no different in that aspect, we have GraphSpace for when spatial structure is not important, but connections are.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"What if you wish to model something a little more complex? Perhaps a school yard full of students running around (in space), interacting via some social network. This is precisely the scenario that the MASON ABM framework uses as an introductory example in their documentation.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"Rather than implementing an Agents.jl⸺specific graph structure, we can interface with Graphs.jl: a high class library for managing and implementing graphs, which can be re-used to establish social networks within existing spaces.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"To begin, we load in some dependencies","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"using Agents\nusing SimpleWeightedGraphs: SimpleWeightedDiGraph # will make social network\nusing SparseArrays: findnz                        # for social network connections\nusing Random: MersenneTwister                     # reproducibility","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"And create an alias to ContinuousAgent{2}, as our agents don't need additional properties.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"const Student = ContinuousAgent{2}","category":"page"},{"location":"examples/schoolyard/#Rules-of-the-schoolyard-1","page":"Graphs.jl","title":"Rules of the schoolyard","text":"","category":"section"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"It's lunchtime, and the students are going out to play. We assume the school building is in the centre of our space, with some fences around the building. A teacher monitors the students, and makes sure they don't stray too far towards the fence. We use a teacher_attractor force to simulate a teacher's attentiveness. Students head out to the schoolyard in random directions, but adhere to some social norms.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"Each student has one friend and one foe. These are chosen at random in our model, so it's possible that for any pair of students, one likes the other but this feeling is not reciprocated. The bond between pairs is chosen at random between 0 and 1, with a bond of 1 being the strongest. If the bond is friendly, agents wish above all else to be near their friend. Bonds that are unfriendly see students moving as far away as possible from their foe.","category":"page"},{"location":"examples/schoolyard/#Initialising-the-model-1","page":"Graphs.jl","title":"Initialising the model","text":"","category":"section"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"function schoolyard(;\n    numStudents = 50,\n    teacher_attractor = 0.15,\n    noise = 0.1,\n    max_force = 1.7,\n    spacing = 4.0,\n    seed = 6998,\n)\n    model = ABM(\n        Student,\n        ContinuousSpace((100, 100), spacing; periodic = false);\n        properties = Dict(\n            :teacher_attractor => teacher_attractor,\n            :noise => noise,\n            :buddies => SimpleWeightedDiGraph(numStudents),\n            :max_force => max_force,\n        ),\n        rng = MersenneTwister(seed)\n    )\n    for student in 1:numStudents\n        # Students begin near the school building\n        add_agent!(model.space.extent .* 0.5 .+ Tuple(rand(model.rng, 2)) .- 0.5, model)\n\n        # Add one friend and one foe to the social network\n        friend = rand(model.rng, filter(s -> s != student, 1:numStudents))\n        add_edge!(model.buddies, student, friend, rand(model.rng))\n        foe = rand(model.rng, filter(s -> s != student, 1:numStudents))\n        add_edge!(model.buddies, student, foe, -rand(model.rng))\n    end\n    model\nend","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"Our model contains the buddies property, which is our Graphs.jl directed, weighted graph. As we can see in the loop, we choose one friend and one foe at random for each student and assign their relationship as a weighted edge on the graph.","category":"page"},{"location":"examples/schoolyard/#Movement-dynamics-1","page":"Graphs.jl","title":"Movement dynamics","text":"","category":"section"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"distance(pos) = sqrt(pos[1]^2 + pos[2]^2)\nscale(L, force) = (L / distance(force)) .* force\n\nfunction agent_step!(student, model)\n    # place a teacher in the center of the yard, so we don’t go too far away\n    teacher = (model.space.extent .* 0.5 .- student.pos) .* model.teacher_attractor\n\n    # add a bit of randomness\n    noise = model.noise .* (Tuple(rand(model.rng, 2)) .- 0.5)\n\n    # Adhere to the social network\n    network = model.buddies.weights[student.id, :]\n    tidxs, tweights = findnz(network)\n    network_force = (0.0, 0.0)\n    for (widx, tidx) in enumerate(tidxs)\n        buddiness = tweights[widx]\n        force = (student.pos .- model[tidx].pos) .* buddiness\n        if buddiness >= 0\n            # The further I am from them, the more I want to go to them\n            if distance(force) > model.max_force # I'm far enough away\n                force = scale(model.max_force, force)\n            end\n        else\n            # The further I am away from them, the better\n            if distance(force) > model.max_force # I'm far enough away\n                force = (0.0, 0.0)\n            else\n                L = model.max_force - distance(force)\n                force = scale(L, force)\n            end\n        end\n        network_force = network_force .+ force\n    end\n\n    # Add all forces together to assign the students next position\n    new_pos = student.pos .+ noise .+ teacher .+ network_force\n    move_agent!(student, new_pos, model)\nend","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"Applying the rules for movement is relatively simple. For the network specifically, we find the student's network and figure out how far apart they are. We scale this by the buddiness factor (how much force we should apply), then figure out if that force should be in a positive or negative direction (friend or foe?).","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"The findnz function is something that may require some further explanation. Graphs uses sparse vectors internally to efficiently represent data. When we find the network of our student, we want to convert the result to a dense representation by finding the non-zero (findnz) elements.","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"model = schoolyard()","category":"page"},{"location":"examples/schoolyard/#Visualising-the-system-1","page":"Graphs.jl","title":"Visualising the system","text":"","category":"section"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"Now, we can watch the dynamics of the social system unfold:","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"using InteractiveDynamics\nusing CairoMakie\nCairoMakie.activate!() # hide\n\nfunction static_preplot!(ax, model)\n    obj = CairoMakie.scatter!([50 50]; color = :red) # Show position of teacher\n    CairoMakie.hidedecorations!(ax) # hide tick labels etc.\n    CairoMakie.translate!(obj, 0, 0, 5) # be sure that the teacher will be above students\nend\n\nabmvideo(\n    \"schoolyard.mp4\", model, agent_step!, dummystep;\n    framerate = 15, frames = 40,\n    title = \"Playgound dynamics\",\n    static_preplot!,\n)","category":"page"},{"location":"examples/schoolyard/#","page":"Graphs.jl","title":"Graphs.jl","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../schoolyard.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/predator_prey.jl\"","category":"page"},{"location":"examples/predator_prey/#Predator-prey-dynamics-1","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"","category":"section"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../sheepwolf.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"The predator-prey model emulates the population dynamics of predator and prey animals who live in a common ecosystem and compete over limited resources. This model is an agent-based analog to the classic Lotka-Volterra differential equation model.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"This example illustrates how to develop models with heterogeneous agents (sometimes referred to as a mixed agent based model), incorporation of a spatial property in the dynamics (represented by a stanadard array, not an agent, as is done in most other ABM frameworks), and usage of GridSpace, which allows multiple agents per grid coordinate.","category":"page"},{"location":"examples/predator_prey/#Model-specification-1","page":"Predator-prey dynamics","title":"Model specification","text":"","category":"section"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"The environment is a two dimensional grid containing sheep, wolves and grass. In the model, wolves eat sheep and sheep eat grass. Their populations will oscillate over time if the correct balance of resources is achieved. Without this balance however, a population may become extinct. For example, if wolf population becomes too large, they will deplete the sheep and subsequently die of starvation.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"We will begin by loading the required packages and defining two subtypes of AbstractAgent: Sheep, Wolf. Grass will be a spatial property in the model.  All three agent types have id and pos properties, which is a requirement for all subtypes of AbstractAgent when they exist upon a GridSpace. Sheep and wolves have identical properties, but different behaviors as explained below. The property energy represents an animals current energy level. If the level drops below zero, the agent will die. Sheep and wolves reproduce asexually in this model, with a probability given by reproduction_prob. The property Δenergy controls how much energy is acquired after consuming a food source.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Grass is a replenishing resource that occupies every position in the grid space. Grass can be consumed only if it is fully_grown. Once the grass has been consumed, it replenishes after a delay specified by the property regrowth_time. The property countdown tracks the delay between being consumed and the regrowth time.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"It is also available from the Models module as Models.predator_prey.","category":"page"},{"location":"examples/predator_prey/#Making-the-model-1","page":"Predator-prey dynamics","title":"Making the model","text":"","category":"section"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"First we define the agent types (here you can see that it isn't really that much of an advantage to have two different agent types. Like in the Rabbit, Fox, Wolf example, we could have only one type and one additional filed to separate them. Nevertheless, for the sake of example, we will use two different types.)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"using Agents, Random\n\n@agent Sheep GridAgent{2} begin\n    energy::Float64\n    reproduction_prob::Float64\n    Δenergy::Float64\nend\n\n@agent Wolf GridAgent{2} begin\n    energy::Float64\n    reproduction_prob::Float64\n    Δenergy::Float64\nend","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"The function initialize_model returns a new model containing sheep, wolves, and grass using a set of pre-defined values (which can be overwritten). The environment is a two dimensional grid space, which enables animals to walk in all directions.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"function initialize_model(;\n        n_sheep = 100,\n        n_wolves = 50,\n        dims = (20, 20),\n        regrowth_time = 30,\n        Δenergy_sheep = 4,\n        Δenergy_wolf = 20,\n        sheep_reproduce = 0.04,\n        wolf_reproduce = 0.05,\n        seed = 23182,\n    )\n\n    rng = MersenneTwister(seed)\n    space = GridSpace(dims, periodic = true)\n    # Model properties contain the grass as two arrays: whether it is fully grown\n    # and the time to regrow. Also have static parameter `regrowth_time`.\n    # Notice how the properties are a `NamedTuple` to ensure type stability.\n    properties = (\n        fully_grown = falses(dims),\n        countdown = zeros(Int, dims),\n        regrowth_time = regrowth_time,\n    )\n    model = ABM(Union{Sheep, Wolf}, space;\n        properties, rng, scheduler = Schedulers.randomly, warn = false\n    )\n    # Add agents\n    for _ in 1:n_sheep\n        energy = rand(model.rng, 1:(Δenergy_sheep*2)) - 1\n        add_agent!(Sheep, model, energy, sheep_reproduce, Δenergy_sheep)\n    end\n    for _ in 1:n_wolves\n        energy = rand(model.rng, 1:(Δenergy_wolf*2)) - 1\n        add_agent!(Wolf, model, energy, wolf_reproduce, Δenergy_wolf)\n    end\n    # Add grass with random initial growth\n    for p in positions(model)\n        fully_grown = rand(model.rng, Bool)\n        countdown = fully_grown ? regrowth_time : rand(model.rng, 1:regrowth_time) - 1\n        model.countdown[p...] = countdown\n        model.fully_grown[p...] = fully_grown\n    end\n    return model\nend\n\nsheepwolfgrass = initialize_model()","category":"page"},{"location":"examples/predator_prey/#Defining-the-stepping-functions-1","page":"Predator-prey dynamics","title":"Defining the stepping functions","text":"","category":"section"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Sheep and wolves behave similarly: both lose 1 energy unit by moving to an adjacent position and both consume a food source if available. If their energy level is below zero, they die. Otherwise, they live and reproduce with some probability. They move to a random adjacent position with the walk! function.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Notice how the function sheepwolf_step!, which is our agent_step!, is dispatched to the appropriate agent type via Julia's Multiple Dispatch system.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"function sheepwolf_step!(sheep::Sheep, model)\n    walk!(sheep, rand, model)\n    sheep.energy -= 1\n    if sheep.energy < 0\n        kill_agent!(sheep, model)\n        return\n    end\n    eat!(sheep, model)\n    if rand(model.rng) ≤ sheep.reproduction_prob\n        reproduce!(sheep, model)\n    end\nend\n\nfunction sheepwolf_step!(wolf::Wolf, model)\n    walk!(wolf, rand, model)\n    wolf.energy -= 1\n    if wolf.energy < 0\n        kill_agent!(wolf, model)\n        return\n    end\n    # If there is any sheep on this grid cell, it's dinner time!\n    dinner = first_sheep_in_position(wolf.pos, model)\n    !isnothing(dinner) && eat!(wolf, dinner, model)\n    if rand(model.rng) ≤ wolf.reproduction_prob\n        reproduce!(wolf, model)\n    end\nend\n\nfunction first_sheep_in_position(pos, model)\n    ids = ids_in_position(pos, model)\n    j = findfirst(id -> model[id] isa Sheep, ids)\n    isnothing(j) ? nothing : model[ids[j]]::Sheep\nend","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Sheep and wolves have separate eat! functions. If a sheep eats grass, it will acquire additional energy and the grass will not be available for consumption until regrowth time has elapsed. If a wolf eats a sheep, the sheep dies and the wolf acquires more energy.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"function eat!(sheep::Sheep, model)\n    if model.fully_grown[sheep.pos...]\n        sheep.energy += sheep.Δenergy\n        model.fully_grown[sheep.pos...] = false\n    end\n    return\nend\n\nfunction eat!(wolf::Wolf, sheep::Sheep, model)\n    kill_agent!(sheep, model)\n    wolf.energy += wolf.Δenergy\n    return\nend","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Sheep and wolves share a common reproduction method. Reproduction has a cost of 1/2 the current energy level of the parent. The offspring is an exact copy of the parent, with exception of id.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"function reproduce!(agent::A, model) where {A}\n    agent.energy /= 2\n    id = nextid(model)\n    offspring = A(id, agent.pos, agent.energy, agent.reproduction_prob, agent.Δenergy)\n    add_agent_pos!(offspring, model)\n    return\nend","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"The behavior of grass function differently. If it is fully grown, it is consumable. Otherwise, it cannot be consumed until it regrows after a delay specified by regrowth_time. The dynamics of the grass is our model_step! function.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"function grass_step!(model)\n    @inbounds for p in positions(model) # we don't have to enable bound checking\n        if !(model.fully_grown[p...])\n            if model.countdown[p...] ≤ 0\n                model.fully_grown[p...] = true\n                model.countdown[p...] = model.regrowth_time\n            else\n                model.countdown[p...] -= 1\n            end\n        end\n    end\nend","category":"page"},{"location":"examples/predator_prey/#Running-the-model-1","page":"Predator-prey dynamics","title":"Running the model","text":"","category":"section"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"We will run the model for 500 steps and record the number of sheep, wolves and consumable grass patches after each step. First: initialize the model.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"using InteractiveDynamics\nusing CairoMakie\nCairoMakie.activate!() # hide","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"To view our starting population, we can build an overview plot using abmplot. We define the plotting details for the wolves and sheep:","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"offset(a) = a isa Sheep ? (-0.1, -0.1*rand()) : (+0.1, +0.1*rand())\nashape(a) = a isa Sheep ? :circle : :utriangle\nacolor(a) = a isa Sheep ? RGBAf(1.0, 1.0, 1.0, 0.8) : RGBAf(0.2, 0.2, 0.3, 0.8)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"and instruct abmplot how to plot grass as a heatmap:","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"grasscolor(model) = model.countdown ./ model.regrowth_time","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"and finally define a colormap for the grass:","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"heatkwargs = (colormap = [:brown, :green], colorrange = (0, 1))","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"and put everything together and give it to abmplot","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"plotkwargs = (;\n    ac = acolor,\n    as = 25,\n    am = ashape,\n    offset,\n    scatterkwargs = (strokewidth = 1.0, strokecolor = :black),\n    heatarray = grasscolor,\n    heatkwargs = heatkwargs,\n)\n\nsheepwolfgrass = initialize_model()\n\nfig, ax, abmobs = abmplot(sheepwolfgrass;\n    agent_step! = sheepwolf_step!,\n    model_step! = grass_step!,\nplotkwargs...)\nfig","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Now, lets run the simulation and collect some data. Define datacollection:","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"sheep(a) = a isa Sheep\nwolf(a) = a isa Wolf\ncount_grass(model) = count(model.fully_grown)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Run simulation:","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"sheepwolfgrass = initialize_model()\nsteps = 1000\nadata = [(sheep, count), (wolf, count)]\nmdata = [count_grass]\nadf, mdf = run!(sheepwolfgrass, sheepwolf_step!, grass_step!, steps; adata, mdata)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"The following plot shows the population dynamics over time. Initially, wolves become extinct because they consume the sheep too quickly. The few remaining sheep reproduce and gradually reach an equilibrium that can be supported by the amount of available grass.","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"function plot_population_timeseries(adf, mdf)\n    figure = Figure(resolution = (600, 400))\n    ax = figure[1, 1] = Axis(figure; xlabel = \"Step\", ylabel = \"Population\")\n    sheepl = lines!(ax, adf.step, adf.count_sheep, color = :cornsilk4)\n    wolfl = lines!(ax, adf.step, adf.count_wolf, color = RGBAf(0.2, 0.2, 0.3))\n    grassl = lines!(ax, mdf.step, mdf.count_grass, color = :green)\n    figure[1, 2] = Legend(figure, [sheepl, wolfl, grassl], [\"Sheep\", \"Wolves\", \"Grass\"])\n    figure\nend\n\nplot_population_timeseries(adf, mdf)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Altering the input conditions, we now see a landscape where sheep, wolves and grass find an equilibrium","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"stable_params = (;\n    n_sheep = 140,\n    n_wolves = 20,\n    dims = (30, 30),\n    Δenergy_sheep = 5,\n    sheep_reproduce = 0.31,\n    wolf_reproduce = 0.06,\n    Δenergy_wolf = 30,\n    seed = 71758,\n)\n\nsheepwolfgrass = initialize_model(;stable_params...)\nadf, mdf = run!(sheepwolfgrass, sheepwolf_step!, grass_step!, 2000; adata, mdata)\nplot_population_timeseries(adf, mdf)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Finding a parameter combination that leads to long-term coexistence was surprisingly difficult. It is for such cases that the Optimizing agent based models example is useful!","category":"page"},{"location":"examples/predator_prey/#Video-1","page":"Predator-prey dynamics","title":"Video","text":"","category":"section"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"Given that we have defined plotting functions, making a video is as simple as","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"sheepwolfgrass = initialize_model(;stable_params...)\n\nabmvideo(\n    \"sheepwolf.mp4\",\n    sheepwolfgrass,\n    sheepwolf_step!,\n    grass_step!;\n    frames = 100,\n    framerate = 8,\n    title = \"Sheep Wolf Grass\",\n    plotkwargs...,\n)","category":"page"},{"location":"examples/predator_prey/#","page":"Predator-prey dynamics","title":"Predator-prey dynamics","text":"<video width=\"auto\" controls autoplay loop>\n<source src=\"../sheepwolf.mp4\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/rabbit_fox_hawk.jl\"","category":"page"},{"location":"examples/rabbit_fox_hawk/#D-Mixed-Agent-Ecosystem-with-Pathfinding-1","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"","category":"section"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/agents/rabbit_fox_hawk.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"This model is much more advanced version of the Predator-prey dynamics example. It uses a 3-dimensional ContinuousSpace, a realistic terrain for the agents, and pathfinding (with multiple pathfinders). It should be considered an advanced example for showcasing pathfinding.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Agents in this model are one of three species of animals: rabbits, foxes and hawks. Rabbits eat grass, and are hunted by foxes and hawks. While rabbits and foxes are restricted to walk on suitable portions of the map, hawks are capable of flight and can fly over a much larger region of the map.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Similar to the Predator-prey dynamics example, agent types are distinguished using a type field. Agents also have an additional energy field, which is consumed to move around and reproduce. Eating food (grass or rabbits) replenishes energy by a fixed amount.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"using Agents, Agents.Pathfinding\nusing Random\nimport ImageMagick\nusing FileIO: load\n\n@agent Animal ContinuousAgent{3} begin\n    type::Symbol # one of :rabbit, :fox or :hawk\n    energy::Float64\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Some utility functions to create specific types of agents, and find the euclidean norm of a Vector","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"const v0 = (0.0, 0.0, 0.0) # we don't use the velocity field here\nRabbit(id, pos, energy) = Animal(id, pos, v0, :rabbit, energy)\nFox(id, pos, energy) = Animal(id, pos, v0, :fox, energy)\nHawk(id, pos, energy) = Animal(id, pos, v0, :hawk, energy)\neunorm(vec) = √sum(vec .^ 2)","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"The environment is generated from a heightmap: a 2D matrix, where each value denotes the height of the terrain at that point. We segregate the model into 4 regions based on the height:","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Anything below water_level is water and cannot be walked on\nThe region between water_level and grass_level is flatland, that can be walked on\nThe part of the map between grass_level and mountain_level is too high for animals to walk over, but it can be flown over\nThe terrain above mountain_level is completely inaccessible","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Grass is the food source for rabbits. It can grow anywhere from water_level to grass_level. The spread of grass across the terrain is specified using a BitArray. A value of 1 at a location indicates the presence of grass there, which can be consumed when it is eaten by a rabbit. The probability of grass growing is proportional to how close it is to the water.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"The initialize_model function takes in the URL to our heightmap, the thresholds for the 4 regions, and some additional parameters for the model. It then creates and returns a model with the specified heightmap and containing the specified number of rabbits, foxes and hawks.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function initialize_model(\n    heightmap_url =\n    \"https://raw.githubusercontent.com/JuliaDynamics/\" *\n    \"JuliaDynamics/master/videos/agents/rabbit_fox_hawk_heightmap.png\",\n    water_level = 8,\n    grass_level = 20,\n    mountain_level = 35;\n    n_rabbits = 160,  ## initial number of rabbits\n    n_foxes = 30,  ## initial number of foxes\n    n_hawks = 30,  ## initial number of hawks\n    Δe_grass = 25,  ## energy gained from eating grass\n    Δe_rabbit = 30,  ## energy gained from eating one rabbit\n    rabbit_repr = 0.06,  ## probability for a rabbit to (asexually) reproduce at any step\n    fox_repr = 0.03,  ## probability for a fox to (asexually) reproduce at any step\n    hawk_repr = 0.02, ## probability for a hawk to (asexually) reproduce at any step\n    rabbit_vision = 6,  ## how far rabbits can see grass and spot predators\n    fox_vision = 10,  ## how far foxes can see rabbits to hunt\n    hawk_vision = 15,  ## how far hawks can see rabbits to hunt\n    rabbit_speed = 1.3, ## movement speed of rabbits\n    fox_speed = 1.1,  ## movement speed of foxes\n    hawk_speed = 1.2, ## movement speed of hawks\n    regrowth_chance = 0.03,  ## probability that a patch of grass regrows at any step\n    dt = 0.1,   ## discrete timestep each iteration of the model\n    seed = 42,  ## seed for random number generator\n)\n\n    # Download and load the heightmap. The grayscale value is converted to `Float64` and\n    # scaled from 1 to 40\n    heightmap = floor.(Int, convert.(Float64, load(download(heightmap_url))) * 39) .+ 1\n    # The x and y dimensions of the pathfinder are that of the heightmap\n    dims = (size(heightmap)..., 50)\n    # The region of the map that is accessible to each type of animal (land-based or flying)\n    # is defined using `BitArrays`\n    land_walkmap = BitArray(falses(dims...))\n    air_walkmap = BitArray(falses(dims...))\n    for i in 1:dims[1], j in 1:dims[2]\n        # land animals can only walk on top of the terrain between water_level and grass_level\n        if water_level < heightmap[i, j] < grass_level\n            land_walkmap[i, j, heightmap[i, j]+1] = true\n        end\n        # air animals can fly at any height upto mountain_level\n        if heightmap[i, j] < mountain_level\n            air_walkmap[i, j, (heightmap[i, j]+1):mountain_level] .= true\n        end\n    end\n\n    # Generate the RNG for the model\n    rng = MersenneTwister(seed)\n\n    # Note that the dimensions of the space do not have to correspond to the dimensions\n    # of the pathfinder. Discretisation is handled by the pathfinding methods\n    space = ContinuousSpace((100., 100., 50.); periodic = false)\n\n    # Generate an array of random numbers, and threshold it by the probability of grass growing\n    # at that location. Although this causes grass to grow below `water_level`, it is\n    # effectively ignored by `land_walkmap`\n    grass = BitArray(\n        rand(rng, dims[1:2]...) .< ((grass_level .- heightmap) ./ (grass_level - water_level)),\n    )\n    properties = (\n        # The pathfinder for rabbits and foxes\n        landfinder = AStar(space; walkmap = land_walkmap),\n        # The pathfinder for hawks\n        airfinder = AStar(space; walkmap = air_walkmap, cost_metric = MaxDistance{3}()),\n        Δe_grass = Δe_grass,\n        Δe_rabbit = Δe_rabbit,\n        rabbit_repr = rabbit_repr,\n        fox_repr = fox_repr,\n        hawk_repr = hawk_repr,\n        rabbit_vision = rabbit_vision,\n        fox_vision = fox_vision,\n        hawk_vision = hawk_vision,\n        rabbit_speed = rabbit_speed,\n        fox_speed = fox_speed,\n        hawk_speed = hawk_speed,\n        heightmap = heightmap,\n        grass = grass,\n        regrowth_chance = regrowth_chance,\n        water_level = water_level,\n        grass_level = grass_level,\n        dt = dt,\n    )\n\n    model = ABM(Animal, space; rng, properties)\n\n    # spawn each animal at a random walkable position according to its pathfinder\n    for _ in 1:n_rabbits\n        add_agent_pos!(\n            Rabbit(\n                nextid(model), ## Using `nextid` prevents us from having to manually keep track\n                               # of animal IDs\n                random_walkable(model, model.landfinder),\n                rand(model.rng, Δe_grass:2Δe_grass),\n            ),\n            model,\n        )\n    end\n    for _ in 1:n_foxes\n        add_agent_pos!(\n            Fox(\n                nextid(model),\n                random_walkable(model, model.landfinder),\n                rand(model.rng, Δe_rabbit:2Δe_rabbit),\n            ),\n            model,\n        )\n    end\n    for _ in 1:n_hawks\n        add_agent_pos!(\n            Hawk(\n                nextid(model),\n                random_walkable(model, model.airfinder),\n                rand(model.rng, Δe_rabbit:2Δe_rabbit),\n            ),\n            model,\n        )\n    end\n\n    return model\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Passing in a sample heightmap to the initialize_model function we created returns the generated model.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"model = initialize_model()","category":"page"},{"location":"examples/rabbit_fox_hawk/#Stepping-functions-1","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"Stepping functions","text":"","category":"section"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"The animal_step! function dispatches to the proper function depending on the type of agent. The stepping functions for each type of agent are similar: They lose energy per step, and die if their energy ever reaches 0. They also have a random probability to reproduce at an iteration. Agents all move towards their food. In the case of rabbits, they also move away from any nearby predators.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function animal_step!(animal, model)\n    if animal.type == :rabbit\n        rabbit_step!(animal, model)\n    elseif animal.type == :fox\n        fox_step!(animal, model)\n    else\n        hawk_step!(animal, model)\n    end\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Rabbits eat grass at their position, if it exists. If they see a predator, they run away. The direction in which they flee is dependent on all predators in their vision, with closer ones contributing more to the chosen direction. If there are no predators to flee from, rabbits walk around randomly.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function rabbit_step!(rabbit, model)\n    # Eat grass at this position, if any\n    if get_spatial_property(rabbit.pos, model.grass, model) == 1\n        model.grass[get_spatial_index(rabbit.pos, model.grass, model)] = 0\n        rabbit.energy += model.Δe_grass\n    end\n\n    # The energy cost at each step corresponds to the amount of time that has passed\n    # since the last step\n    rabbit.energy -= model.dt\n    # All animals die if their energy reaches 0\n    if rabbit.energy <= 0\n        kill_agent!(rabbit, model, model.landfinder)\n        return\n    end\n\n    # Get a list of positions of all nearby predators\n    predators = [\n        x.pos for x in nearby_agents(rabbit, model, model.rabbit_vision) if\n            x.type == :fox || x.type == :hawk\n            ]\n    # If the rabbit sees a predator and isn't already moving somewhere\n    if !isempty(predators) && is_stationary(rabbit, model.landfinder)\n        # Try and get an ideal direction away from predators\n        direction = (0., 0., 0.)\n        for predator in predators\n            # Get the direction away from the predator\n            away_direction = (rabbit.pos .- predator)\n            # In case there is already a predator at our location, moving anywhere is\n            # moving away from it, so it doesn't contribute to `direction`\n            all(away_direction .≈ 0.) && continue\n            # Add this to the overall direction, scaling inversely with distance.\n            # As a result, closer predators contribute more to the direction to move in\n            direction = direction .+ away_direction ./ eunorm(away_direction) ^ 2\n        end\n        # If the only predator is right on top of the rabbit\n        if all(direction .≈ 0.)\n            # Move anywhere\n            chosen_position = random_walkable(rabbit.pos, model, model.landfinder, model.rabbit_vision)\n        else\n            # Normalize the resultant direction, and get the ideal position to move it\n            direction = direction ./ eunorm(direction)\n            # Move to a random position in the general direction of away from predators\n            position = rabbit.pos .+ direction .* (model.rabbit_vision / 2.)\n            chosen_position = random_walkable(position, model, model.landfinder, model.rabbit_vision / 2.)\n        end\n        plan_route!(rabbit, chosen_position, model.landfinder)\n    end\n\n    # Reproduce with a random probability, scaling according to the time passed each\n    # step\n    rand(model.rng) <= model.rabbit_repr * model.dt && reproduce!(rabbit, model)\n\n    # If the rabbit isn't already moving somewhere, move to a random spot\n    if is_stationary(rabbit, model.landfinder)\n        plan_route!(\n            rabbit,\n            random_walkable(rabbit.pos, model, model.landfinder, model.rabbit_vision),\n            model.landfinder\n        )\n    end\n\n    # Move along the route planned above\n    move_along_route!(rabbit, model, model.landfinder, model.rabbit_speed, model.dt)\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Foxes hunt for rabbits, and eat rabbits within a unit radius of its position.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function fox_step!(fox, model)\n    # Look for nearby rabbits that can be eaten\n    food = [x for x in nearby_agents(fox, model) if x.type == :rabbit]\n    if !isempty(food)\n        kill_agent!(rand(model.rng, food), model, model.landfinder)\n        fox.energy += model.Δe_rabbit\n    end\n\n\n    # The energy cost at each step corresponds to the amount of time that has passed\n    # since the last step\n    fox.energy -= model.dt\n    # All animals die once their energy reaches 0\n    if fox.energy <= 0\n        kill_agent!(fox, model, model.landfinder)\n        return\n    end\n\n    # Random chance to reproduce every step\n    rand(model.rng) <= model.fox_repr * model.dt && reproduce!(fox, model)\n\n    # If the fox isn't alreadu moving somewhere\n    if is_stationary(fox, model.landfinder)\n        # Look for any nearby rabbits\n        prey = [x for x in nearby_agents(fox, model, model.fox_vision) if x.type == :rabbit]\n        if isempty(prey)\n            # Move anywhere if no rabbits were found\n            plan_route!(\n                fox,\n                random_walkable(fox.pos, model, model.landfinder, model.fox_vision),\n                model.landfinder,\n            )\n            return\n        end\n        # Move toward a random rabbit\n        plan_route!(fox, rand(model.rng, map(x -> x.pos, prey)), model.landfinder)\n    end\n\n    move_along_route!(fox, model, model.landfinder, model.fox_speed, model.dt)\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Hawks function similarly to foxes, except they can also fly. They dive down for prey and fly back up after eating it.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function hawk_step!(hawk, model)\n    # Look for rabbits nearby\n    food = [x for x in nearby_agents(hawk, model) if x.type == :rabbit]\n    if !isempty(food)\n        # Eat (kill) the rabbit\n        kill_agent!(rand(model.rng, food), model, model.airfinder)\n        hawk.energy += model.Δe_rabbit\n        # Fly back up\n        plan_route!(hawk, hawk.pos .+ (0., 0., 7.), model.airfinder)\n    end\n\n    # The rest of the stepping function is similar to that of foxes, except hawks use a\n    # different pathfinder\n    hawk.energy -= model.dt\n    if hawk.energy <= 0\n        kill_agent!(hawk, model, model.airfinder)\n        return\n    end\n\n    rand(model.rng) <= model.hawk_repr * model.dt && reproduce!(hawk, model)\n\n    if is_stationary(hawk, model.airfinder)\n        prey = [x for x in nearby_agents(hawk, model, model.hawk_vision) if x.type == :rabbit]\n        if isempty(prey)\n            plan_route!(\n                hawk,\n                random_walkable(hawk.pos, model, model.airfinder, model.hawk_vision),\n                model.airfinder,\n            )\n        else\n            plan_route!(hawk, rand(model.rng, map(x -> x.pos, prey)), model.airfinder)\n        end\n    end\n\n    move_along_route!(hawk, model, model.airfinder, model.hawk_speed, model.dt)\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"This function is called when an animal reproduces. The animal loses half its energy, and a copy of it is created and added to the model.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function reproduce!(animal, model)\n    animal.energy = ceil(Int, animal.energy / 2)\n    add_agent_pos!(Animal(nextid(model), animal.pos, animal.type, animal.energy), model)\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"The model stepping function simulates the growth of grass","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function model_step!(model)\n    # To prevent copying of data, obtain a view of the part of the grass matrix that\n    # doesn't have any grass, and grass can grow there\n    growable = view(\n        model.grass,\n        model.grass .== 0 .& model.water_level .< model.heightmap .<= model.grass_level,\n    )\n    # Grass regrows with a random probability, scaling with the amount of time passing\n    # each step of the model\n    growable .= rand(model.rng, length(growable)) .< model.regrowth_chance * model.dt\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#Visualization-1","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"Visualization","text":"","category":"section"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"Now we use InteractiveDynamics to create a visualization of the model running in 3D space","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"The agents are color-coded according to their type, to make them easily identifiable in the visualization.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"using InteractiveDynamics\nusing GLMakie # CairoMakie doesn't do 3D plots","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"animalcolor(a) =\n    if a.type == :rabbit\n        :brown\n    elseif a.type == :fox\n        :orange\n    else\n        :blue\n    end","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"We use surface! to plot the terrain as a mesh, and colour it using the :terrain colormap. Since the heightmap dimensions don't correspond to the dimensions of the space, we explicitly provide ranges to specify where the heightmap should be plotted.","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"function static_preplot!(ax, model)\n    surface!(\n        ax,\n        (100/205):(100/205):100,\n        (100/205):(100/205):100,\n        model.heightmap;\n        colormap = :terrain\n    )\nend","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"abmvideo(\n    \"rabbit_fox_hawk.mp4\",\n    model, animal_step!, model_step!;\n    figure = (resolution = (800, 700),),\n    frames = 300,\n    framerate = 15,\n    ac = animalcolor,\n    as = 1.0,\n    static_preplot!,\n    title = \"Rabbit Fox Hawk with pathfinding\"\n)","category":"page"},{"location":"examples/rabbit_fox_hawk/#","page":"3D Mixed-Agent Ecosystem with Pathfinding","title":"3D Mixed-Agent Ecosystem with Pathfinding","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/agents/rabbit_fox_hawk.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/#More-Examples-for-Agents.jl-1","page":"More Examples for Agents.jl","title":"More Examples for Agents.jl","text":"","category":"section"},{"location":"examples/#","page":"More Examples for Agents.jl","title":"More Examples for Agents.jl","text":"In order to keep the documentation of Agents.jl lean and focused, the majority of model examples for Agents.jl are not hosted in this documentation, but rather in a different one: Agents.jl Example Zoo. Any kind of user-written example is welcomed to be contributed there as well!","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/optim.jl\"","category":"page"},{"location":"examples/optim/#Optimizing-agent-based-models-1","page":"BlackBoxOptim.jl","title":"Optimizing agent based models","text":"","category":"section"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Sometimes we need to fine-tune our ABMs parameters to a specific outcome. The brute-force solution can quickly become infeasible for even for a few different parameter settings over a number of valid scan ranges. Most of the time, ABMs are also stochastic, so the effect of a parameter setting should be derived from taking the average value only after running the model several times.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Here we show how to use the evolutionary algorithms in BlackBoxOptim.jl with Agents.jl, to optimize the parameters of an epidemiological model (SIR). We explain this model in detail in SIR model for the spread of COVID-19.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"For brevity here, we just import","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"include(\"siroptim.jl\") # From the examples directory","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"which provides us a model_initiation helper function to build a SIR model, and an agent_step! function.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"To look for optimal parameters, we need to define a cost function. The cost function takes as arguments the model parameters that we want to tune; in a SIR model, that would be the migration rate, death rate, transmission rate, when an infected person has been detected (β_det), or when the remain undetected (β_und), infection period, reinfection probability, and time until the infection is detected. The function returns an objective: this value takes the form one or more numbers, which the optimiser will attempt to minimize.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"using BlackBoxOptim, Random\nusing Statistics: mean\n\nfunction cost(x)\n    model, anget_step!,  = Models.sir(;\n        Ns = [500, 500, 500],\n        migration_rate = x[1],\n        death_rate = x[2],\n        β_det = x[3],\n        β_und = x[4],\n        infection_period = x[5],\n        reinfection_probability = x[6],\n        detection_time = x[7],\n    )\n\n    infected_fraction(model) =\n        count(a.status == :I for a in allagents(model)) / nagents(model)\n\n    _, mdf = run!(\n        model,\n        agent_step!,\n        50;\n        mdata = [infected_fraction],\n        when_model = [50],\n        replicates = 10,\n    )\n\n    return mean(mdf.infected_fraction)\nend","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"This cost function runs our model 10 times for 50 days, then returns the average number of infected people. When we pass this function to an optimiser, we will effectively be asking for a set of parameters that can reduce the number of infected people to the lowest possible number.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"We can now test the function cost with some reasonable parameter values.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Random.seed!(10)\n\nx0 = [\n    0.2,  # migration_rate\n    0.1,  # death_rate\n    0.05, # β_det\n    0.3,  # β_und\n    10,   # infection_period\n    0.1,  # reinfection_probability\n    5,    # detection_time\n]\ncost(x0)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">0.9059485530546623</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"With these initial values, 94% of the population is infected after the 50 day period.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"We now let the optimization algorithm change parameters to minimize the number of infected individuals. Complete details on how to use this optimiser can be found in the BlackBoxOptim readme. Here, we assign a range of possible parameter values we would like to test, and a cutoff time in the event that certain parameter sets are unfeasible and cause our model to never converge to a solution.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"result = bboptimize(\n    cost,\n    SearchRange = [\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (7.0, 13.0),\n        (0.0, 1.0),\n        (2.0, 6.0),\n    ],\n    NumDimensions = 7,\n    MaxTime = 20,\n)\nbest_fitness(result)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">0.0</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"With the new parameter values found in result, we find that the fraction of the infected population can be dropped down to 11%. These values of these parameters are now:","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"best_candidate(result)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">7-element Array{Float64,1}:\n 0.1545049978104396\n 0.886202142470518\n 0.8258299702140992\n 0.7411762981538305\n 9.172098752376595\n 0.17302035312870545\n 5.907046385323653\n</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Unfortunately we've not given the optimiser information we probably needed to. Notice that the death rate is 96%, with reinfection quite low. When all the infected individuals die, infection doesn't transmit - the optimiser has managed to reduce the infection rate by killing the infected.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"This is not the work of some sadistic AI, just an oversight in our instructions. Let's modify the cost function to also keep the mortality rate low.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"First, we'll run the model with our new-found parameters:","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"x = best_candidate(result)\n\nRandom.seed!(0)\n\nmodel = model_initiation(;\n    Ns = [500, 500, 500],\n    migration_rate = x[1],\n    death_rate = x[2],\n    β_det = x[3],\n    β_und = x[4],\n    infection_period = x[5],\n    reinfection_probability = x[6],\n    detection_time = x[7],\n)\n\n_, data =\n    run!(model, agent_step!, 50; mdata = [nagents], when_model = [50], replicates = 10)\n\nmean(data.nagents)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">2.0</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"About 10% of the population dies with these parameters over our 50 day window.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"We can define a multi-objective cost function that minimizes the number of infected and deaths by returning more than one value in our cost function.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"function cost_multi(x)\n    model = model_initiation(;\n        Ns = [500, 500, 500],\n        migration_rate = x[1],\n        death_rate = x[2],\n        β_det = x[3],\n        β_und = x[4],\n        infection_period = x[5],\n        reinfection_probability = x[6],\n        detection_time = x[7],\n    )\n\n    initial_size = nagents(model)\n\n    infected_fraction(model) =\n        count(a.status == :I for a in allagents(model)) / nagents(model)\n    n_fraction(model) = -1.0 * nagents(model) / initial_size\n\n    mdata = [infected_fraction, n_fraction]\n    _, data = run!(\n        model,\n        agent_step!,\n        50;\n        mdata,\n        when_model = [50],\n        replicates = 10,\n    )\n\n    return mean(data[!, dataname(mdata[1])), mean(data[!, dataname(mdata[2]))\nend","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Notice that our new objective n_fraction is negative. It would be simpler to state we'd like to 'maximise the living population', but the optimiser we're using here focuses on minimising objectives only, therefore we must 'minimise the number of agents dying.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"cost_multi(x0)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">(0.9812286689419796, -0.7813333333333333)</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The cost of our initial parameter values is high: most of the population (96%) is infected and 22% die.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Let's minimize this multi-objective cost function. There is more than one way to approach such an optimisation. Again, refer to the BlackBoxOptim.jl documentation for specifics.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"result = bboptimize(\n    cost_multi,\n    Method = :borg_moea,\n    FitnessScheme = ParetoFitnessScheme{2}(is_minimizing = true),\n    SearchRange = [\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (7.0, 13.0),\n        (0.0, 1.0),\n        (2.0, 6.0),\n    ],\n    NumDimensions = 7,\n    MaxTime = 55,\n)\nbest_fitness(result)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">(0.0047011417058428475, -0.9926666666666668)</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"best_candidate(result)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">7-element Array{Float64,1}:\n  0.8798741355149663\n  0.6703698358420607\n  0.07093587652308599\n  0.07760264834010584\n 10.65213641721431\n  0.9911248984077646\n  5.869646301829334\n</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"These parameters look better: about 0.3% of the population dies and 0.02% are infected:","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The algorithm managed to minimize the number of infected and deaths while still increasing death rate to 42%, reinfection probability to 53%, and migration rates to 33%. The most important change however, was decreasing the transmission rate when individuals are infected and undetected from 30% in our initial calculation, to 0.2%.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"Over a longer period of time than 50 days, that high death rate will take its toll though. Let's reduce that rate and check the cost.","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"x = best_candidate(result)\nx[2] = 0.02\ncost_multi(x)","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"<pre class=\"documenter-example-output\">(0.03933333333333333, -1.0)</pre>","category":"page"},{"location":"examples/optim/#","page":"BlackBoxOptim.jl","title":"BlackBoxOptim.jl","text":"The fraction of infected increases to 0.04%. This is an interesting result: since this virus model is not as deadly, the chances of re-infection increase. We now have a set of parameters to strive towards in the real world. Insights such as these assist us to enact countermeasures like social distancing to mitigate infection risks.","category":"page"},{"location":"tutorial/#Tutorial-1","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"tip: YouTube video\nThis Tutorial is also available as a YouTube video: https://youtu.be/fgwAfAa4kt0","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In Agents.jl a central structure called AgentBasedModel contains all data of a simulation and maps unique IDs (integers) to agent instances. During the simulation, the model evolves in discrete steps. During one step, the user decides which agents will act, how will they act, how many times, and whether any model-level properties will be adjusted. Once the time evolution is defined, collecting data during time evolution is straightforward by simply stating which data should be collected.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In the spirit of simple design, all of this is done by defining simple Julia data types, like basic functions, structs and dictionaries.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"To set up an ABM simulation in Agents.jl, a user only needs to follow these steps:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Choose in what kind of space the agents will live in, for example a graph, a grid, etc. Several spaces are provided by Agents.jl and can be initialized immediately.\nDefine the agent type (or types, for mixed models) that will populate the ABM. Agent types are standard Julia mutable struct that are created with @agent. The types must contain some mandatory fields, which is ensured by using @agent. The remaining fields of the agent type are up to user's choice.\nThe created agent type, the chosen space, optional additional model level properties, and other simulation tuning properties like schedulers or random number generators, are given to our universal structure AgentBasedModel. This instance defines the model within an Agents.jl simulation.\nProvide functions that govern the time evolution of the ABM. A user can provide an agent-stepping function, that acts on each agent one by one, and/or a model-stepping function, that steps the entire model as a whole. These functions are standard Julia functions that take advantage of the Agents.jl API. Once these functions are created, they are simply passed to step! to evolve the model.\n(Optional) Visualize the model and animate its time evolution. This can help checking that the model behaves as expected and there aren't any mistakes, or can be used in making figures for a paper/presentation.\nCollect data. To do this, specify which data should be collected, by providing one standard Julia Vector of data-to-collect for agents, for example [:mood, :wealth], and another one for the model. The agent data names are given as the keyword adata and the model as keyword mdata to the function run!. This function outputs collected data in the form of a DataFrame.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"If you're planning of running massive simulations, it might be worth having a look at the Performance Tips after familiarizing yourself with Agents.jl.","category":"page"},{"location":"tutorial/#Space-1","page":"Tutorial","title":"1. The space","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Agents.jl offers several possibilities for the space the agents live in. In addition, it is straightforward to implement a fundamentally new type of space, see Creating a new space type.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The available spaces are listed in the Available spaces part of the API. An example of a space is OpenStreetMapSpace. It is based on Open Street Map, where agents are confined to move along streets of the map, using real-world values for the length of each street.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After deciding on the space, one simply initializes an instance of a space, e.g. with grid = GridSpace((10, 10)) and passes that into AgentBasedModel. See each individual space for all its possible arguments.","category":"page"},{"location":"tutorial/#.-The-agent-type(s)-1","page":"Tutorial","title":"2. The agent type(s)","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"@agent\nAbstractAgent","category":"page"},{"location":"tutorial/#Agents.@agent","page":"Tutorial","title":"Agents.@agent","text":"@agent YourAgentType{X} AnotherAgentType [OptionalSupertype] begin\n    extra_property::X\n    other_extra_property::Int\n    # etc...\nend\n\nDefine an agent struct which includes all fields that AnotherAgentType has, as well as any additional ones the user may provide via the begin block. See below for examples.\n\nUsing @agent is the only supported way to create agent types for Agents.jl. Structs created with @agent by default subtype AbstractAgent. They cannot subtype each other, as all structs created from @agent are concrete types and AnotherAgentType itself is also concrete (only concrete types have fields). If you want YourAgentType to subtype something other than AbstractAgent, use the optional argument OptionalSupertype (which itself must then subtype AbstractAgent).\n\nThe macro @agent has two primary uses:\n\nTo include the mandatory fields for a particular space in your agent struct. In this case you would use one of the minimal agent types as AnotherAgentType.\nA convenient way to include fields from another, already existing struct.\n\nThe existing minimal agent types are:\n\nNoSpaceAgent\nGraphAgent\nGridAgent\nContinuousAgent\nOSMAgent\n\nAll will attribute an id::Int field, and besides NoSpaceAgent will also attribute a pos field. You should never directly manipulate the mandatory fields id, pos that the resulting new agent type will have. The id is an unchangable field (and in Julia versions ≥ v1.8 this is enforced). Use functions like move_agent! etc., to change the position.\n\nYou can use the @doc macro from Julia to document the generated struct if you wish so.\n\nExamples\n\nExample without optional hierarchy\n\nUsing\n\n@agent Person{T} GridAgent{2} begin\n    age::Int\n    moneyz::T\nend\n\nwill create an agent appropriate for using with 2-dimensional GridSpace\n\nmutable struct Person{T} <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Int}\n    age::Int\n    moneyz::T\nend\n\nand then, one can even do\n\n@agent Baker{T} Person{T} begin\n    breadz_per_day::T\nend\n\nwhich would make\n\nmutable struct Baker{T} <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Int}\n    age::Int\n    moneyz::T\n    breadz_per_day::T\nend\n\nExaple with optional hierachy\n\nAn alternative way to make the above structs, that also establishes a user-specific subtyping hierachy would be to do:\n\nabstract type AbstractHuman <: AbstractAgent end\n\n@agent Worker GridAgent{2} AbstractHuman begin\n    age::Int\n    moneyz::Float64\nend\n\n@agent Fisher Worker AbstractHuman begin\n    fish_per_day::Float64\nend\n\nwhich would now make both Human, Fisher subtypes of AbstractHuman.\n\nExample highlighting problems with parametric types\n\nNotice that in Julia parametric types are union types. Hence, the following cannot be used:\n\n@agent Dummy{T} GridAgent{2} begin\n    moneyz::T\nend\n\n@agent Fisherino{T} Dummy{T} begin\n    fish_per_day::T\nend\n\nYou will get an error in the definition of Fisherino, because the fields of Dummy{T} cannot be obtained, because it is a union type. Same with using Dummy. You can only use Dummy{Float64}.\n\nExample with common dispatch and no subtyping\n\nIt may be that you do not even need to create a subtyping relation if you want to utilize multiple dispatch. Consider the example:\n\n@agent CommonTraits GridSpace{2} begin\n    age::Int\n    speed::Int\n    energy::Int\nend\n\nand then two more structs are made from these traits:\n\n@agent Bird CommonTraits begin\n    height::Float64\nend\n\n@agent Rabbit CommonTraits begin\n    underground::Bool\nend\n\nIf you wanted a function that dispatches to both Rabbit, Bird, you only have to define:\n\nAnimal = Union{Bird, Rabbit}\nf(x::Animal) = ... # uses `CommonTraits` fields\n\nHowever, it should also be said, that there is no real reason here to explicitly type-annotate x::Animal in f. Don't annotate any type. Annotating a type only becomes useful if there are at least two \"abstract\" groups, like Animal, Person. Then it would make sense to define\n\nPerson = Union{Fisher, Baker}\nf(x::Animal) = ... # uses `CommonTraits` fields\nf(x::Person) = ... # uses fields that all \"persons\" have\n\n\n\n\n\n","category":"macro"},{"location":"tutorial/#Agents.AbstractAgent","page":"Tutorial","title":"Agents.AbstractAgent","text":"YourAgentType <: AbstractAgent\n\nAgents participating in Agents.jl simulations are instances of user-defined Types that are subtypes of AbstractAgent.\n\nYour agent type(s) must have the id::Int field as first field. In Julia versions ≥ v1.8, this must also be declared as a const field. If any space is used (see Available spaces), a pos field of appropriate type is also mandatory. The core model structure, and each space, may also require additional fields that may, or may not, be communicated as part of the public API.\n\nThe @agent macro ensures that all of these constrains are in place and hence it is the only officially supported way to generate new agent types.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#.-The-model-1","page":"Tutorial","title":"3. The model","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Once an agent is created (typically by instantiating a struct generated with @agent), it can be added to a model using add_agent!. Then, the agent can interact with the model and the space further by using e.g. move_agent! or kill_agent!. The \"model\" here stands for an instance of AgentBasedModel.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"AgentBasedModel","category":"page"},{"location":"tutorial/#Agents.AgentBasedModel","page":"Tutorial","title":"Agents.AgentBasedModel","text":"AgentBasedModel(AgentType [, space]; properties, kwargs...) → model\n\nCreate an agent-based model from the given agent type and space. You can provide an agent instance instead of type, and the type will be deduced. ABM is equivalent with AgentBasedModel.\n\nThe agents are stored in a dictionary that maps unique IDs (integers) to agents. Use model[id] to get the agent with the given id.\n\nspace is a subtype of AbstractSpace, see Space for all available spaces. If it is ommited then all agents are virtually in one position and there is no spatial structure.\n\nNote: Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.\n\nNote: Agents.jl supports multiple agent types by passing a Union of agent types as AgentType. However, please have a look at Performance Tips for potential drawbacks of this approach.\n\nKeywords\n\nproperties = nothing is additional model-level properties (typically a dictionary) that can be accessed as model.properties. If properties is a dictionary with key type Symbol, or if it is a struct, then the syntax model.name is shorthand for model.properties[:name] (or model.properties.name for structs). This syntax can't be used for name being agents, space, scheduler, properties, rng, maxid, which are the fields of AgentBasedModel.\n\nscheduler = Schedulers.fastest decides the order with which agents are activated (see e.g. Schedulers.by_id and the scheduler API). scheduler is only meaningful if an agent-stepping function is defined for step! or run!, otherwise a user decides a scheduler in the model-stepping function, as illustrated in the Advanced stepping part of the tutorial.\n\nrng = Random.default_rng() provides random number generation to the model. Accepts any subtype of AbstractRNG and is accessed by model.rng.\n\nwarn=true: Type tests for AgentType are done, and by default warnings are thrown when appropriate.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#.-Evolving-the-model-1","page":"Tutorial","title":"4. Evolving the model","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"In Agents.jl, an agent based model should be accompanied with least one and at most two stepping functions. An agent step function is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a model step function.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"An agent step function must accept two arguments: first, an agent instance, and second, a model instance.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The model step function must accept one argument, that is the model. To use only a model step function, users can use the built-in dummystep as the agent step function. This is typically the case for Advanced stepping.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The stepping functions are created using the API functions, and the Examples hosted in this documentation showcase several different variants.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"After you have defined the stepping functions functions, you can evolve your model with step!:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"step!\ndummystep","category":"page"},{"location":"tutorial/#Agents.step!","page":"Tutorial","title":"Agents.step!","text":"step!(model, agent_step!, n::Int = 1)\nstep!(model, agent_step!, model_step!, n::Int = 1, agents_first::Bool = true)\n\nUpdate agents n steps according to the stepping function agent_step!. Agents will be activated as specified by the model.scheduler. model_step! is triggered after every scheduled agent has acted, unless the argument agents_first is false (which then first calls model_step! and then activates the agents).\n\nstep! ignores scheduled IDs that do not exist within the model, allowing you to safely kill agents dynamically.\n\nstep!(model, agent_step!, model_step!, n::Function, agents_first::Bool = true)\n\nIn this version n is a function. Then step! runs the model until n(model, s) returns true, where s is the current amount of steps taken, starting from 0. For this method of step!, model_step! must be provided always (use dummystep if you have no model stepping dynamics).\n\nSee also Advanced stepping for stepping complex models where agent_step! might not be convenient.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Agents.dummystep","page":"Tutorial","title":"Agents.dummystep","text":"dummystep(model)\n\nUse instead of model_step! in step! if no function is useful to be defined.\n\n\n\n\n\ndummystep(agent, model)\n\nUse instead of agent_step! in step! if no function is useful to be defined.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Advanced-stepping-1","page":"Tutorial","title":"Advanced stepping","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"note: Current step number\nNotice that the current step number is not explicitly given to the model_step! function, because this is useful only for a subset of ABMs. If you need the step information, implement this by adding a counting parameter into the model properties, and incrementing it by 1 each time model_step! is called. An example can be seen in the model_step! function of Daisyworld, where a tick is increased at each step.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The interface of step!, which allows the option of both agent_step! and model_step! is driven mostly by convenience. In principle, the model_step! function by itself can perform all operations related with stepping the ABM. However, for many models, this simplified approach offers the benefit of not having to write an explicit loop over existing agents inside the model_step!. Most of the examples in our documentation can be expressed using an independent agent_step! and model_step! function.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"On the other hand, more advanced models require special handling for scheduling, or may need to schedule several times and act on different subsets of agents with different functions. In such a scenario, it is more sensible to provide only a model_step! function (and use dummystep as agent_step!), where all configuration is contained within. Notice that if you follow this road, the argument scheduler given to AgentBasedModel somewhat loses its meaning.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Here is an example:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function complex_step!(model)\n    for id in scheduler1(model)\n        agent_step1!(model[id], model)\n    end\n    intermediate_model_action!(model)\n    for id in scheduler2(model)\n        agent_step2!(model[id], model)\n    end\n    if model.step_counter % 100 == 0\n        model_action_every_100_steps!(model)\n    end\n    final_model_action!(model)\nend\n\nstep!(model, dummystep, complex_step!, n)","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"For defining your own schedulers, see Schedulers.","category":"page"},{"location":"tutorial/#.-Visualizations-1","page":"Tutorial","title":"5. Visualizations","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Once you have defined a model and the stepping functions you can visualize the model statically or animate its time evolution straightforwardly in ~5 lines of code. This is discussed in a different page: Plotting and interactive application. Furthermore, all models in the Examples showcase plotting.","category":"page"},{"location":"tutorial/#.-Collecting-data-1","page":"Tutorial","title":"6. Collecting data","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Running the model and collecting data while the model runs is done with the run! function. Besides run!, there is also the paramscan function that performs data collection while scanning ranges of the parameters of the model, and the ensemblerun! that performs ensemble simulations and data collection.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"run!","category":"page"},{"location":"tutorial/#Agents.run!","page":"Tutorial","title":"Agents.run!","text":"run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df\nrun!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df\n\nRun the model (step it with the input arguments propagated into step!) and collect data specified by the keywords, explained one by one below. Return the data as two DataFrames, one for agent-level data and one for model-level data.\n\nData-deciding keywords\n\nadata::Vector means \"agent data to collect\". If an entry is a Symbol, e.g. :weight, then the data for this entry is agent's field weight. If an entry is a Function, e.g. f, then the data for this entry is just f(a) for each agent a. The resulting dataframe columns are named with the input symbol (here :weight, :f).\nadata::Vector{<:Tuple}: if adata is a vector of tuples instead, data aggregation is done over the agent properties.\nFor each 2-tuple, the first entry is the \"key\" (any entry like the ones mentioned above, e.g. :weight, f). The second entry is an aggregating function that aggregates the key, e.g. mean, maximum. So, continuing from the above example, we would have adata = [(:weight, mean), (f, maximum)].\nIt's also possible to provide a 3-tuple, with the third entry being a conditional function (returning a Bool), which assesses if each agent should be included in the aggregate. For example: x_pos(a) = a.pos[1]>5 with (:weight, mean, x_pos) will result in the average weight of agents conditional on their x-position being greater than 5.\nThe resulting data name columns use the function dataname. They create something like :mean_weight or :maximum_f_x_pos. In addition, you can use anonymous functions in a list comprehension to assign elements of an array into different columns: adata = [(a)->(a.interesting_array[i]) for i=1:N]. Column names can also be renamed with DataFrames.rename! after data is collected.\nNotice: Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. E.g. instead of passing mean, pass mymean(a) = isempty(a) ? 0.0 : mean(a).\nmdata::Vector means \"model data to collect\" and works exactly like adata. For the model, no aggregation is possible (nothing to aggregate over).\nAlternatively, mdata can also be a function. This is a \"generator\" function, that accepts model as input and provides a Vector that represents mdata. Useful in combination with an ensemblerun! call that requires a generator function.\n\nBy default both keywords are nothing, i.e. nothing is collected/aggregated.\n\nMixed-Models\n\nFor mixed-models, the adata keyword has some additional options & properties. An additional column agent_type will be placed in the output dataframe.\n\nIn the case that data is needed for one agent type that does not exist in a second agent type, missing values will be added to the dataframe.\n\nWarning: Since this option is inherently type unstable, try to avoid this in a performance critical situation.\n\nAggregate functions will fail if missing values are not handled explicitly. If a1.weight but a2 (type: Agent2) has no weight, use a2(a) = a isa Agent2; adata = [(:weight, sum, a2)] to filter out the missing results.\n\nOther keywords\n\nwhen=true : at which steps s to perform the data collection and processing. A lot of flexibility is offered based on the type of when. If when::AbstractVector, then data are collected if s ∈ when. Otherwise data are collected if when(model, s) returns true. By default data are collected in every step.\nwhen_model = when : same as when but for model data.\nobtainer = identity : method to transfer collected data to the DataFrame. Typically only change this to copy if some data are mutable containers (e.g. Vector) which change during evolution, or deepcopy if some data are nested mutable containers. Both of these options have performance penalties.\nagents_first=true : Whether to update agents first and then the model, or vice versa.\nshowprogress=false : Whether to show a progress bar.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"The run! function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregated data, or arbitrary combinations.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Nevertheless, we also expose a simple data-collection API (see Data collection), that gives users even more flexibility, allowing them to make their own \"data collection loops\" arbitrarily calling step! and collecting data as, and when, needed.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"As your models become more complex, it may not be advantageous to use lots of helper functions in the global scope to assist with data collection. If this is the case in your model, here's a helpful tip to keep things clean: use a generator function to collect data as instructed in the documentation string of run!. For example:","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"function assets(model)\n    total_savings(model) = model.bank_balance + sum(model.assets)\n    function stategy(model)\n        if model.year == 0\n            return model.initial_strategy\n        else\n            return get_strategy(model)\n        end\n    end\n    return [:age, :details, total_savings, strategy]\nend\nrun!(model, agent_step!, model_step!, 10; mdata = assets)","category":"page"},{"location":"tutorial/#Seeding-and-Random-numbers-1","page":"Tutorial","title":"Seeding and Random numbers","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Each model created by AgentBasedModel provides a random number generator pool model.rng which by default coincides with the global RNG. For performance and reproducibility reasons, one should never use rand() without using a pool, thus throughout our examples we use rand(model.rng) or rand(model.rng, 1:10, 100), etc.","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Another benefit of this approach is deterministic models that can be run again and yield the same output. To do this, always pass a specifically seeded RNG to the model creation, e.g. rng = Random.MersenneTwister(1234).","category":"page"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"Passing RandomDevice() will use the system's entropy source (coupled with hardware like TrueRNG will invoke a true random source, rather than pseudo-random methods like MersenneTwister). Models using this method cannot be repeatable, but avoid potential biases of pseudo-randomness.","category":"page"},{"location":"tutorial/#An-educative-example-1","page":"Tutorial","title":"An educative example","text":"","category":"section"},{"location":"tutorial/#","page":"Tutorial","title":"Tutorial","text":"A simple, education-oriented example of using the basic Agents.jl API is given in Schelling's segregation model.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: Agents.jl)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agents.jl is a pure Julia framework for agent-based modeling (ABM). Agents.jl is part of JuliaDynamics. To get started, please read the Tutorial page.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Star us on GitHub!\nIf you have found this package useful, please consider starring it on GitHub. This gives us an accurate lower bound of the (satisfied) user count.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"tip: Latest news: Agents.jl v5.5\nNew minor release with a major change on creating agents!The @agent macro has been re-written and is now more general and more safe. It now also allows inhereting fields from any other type.\nThe @agent macro is now THE way to create agent types for Agents.jl simulations. Directly creating structs by hand is no longer mentioned in the documentation at all.\nIn the future, making agent types manually (without @agent) may be completely dissalowed, resulting in error. Therefore, making agent types manually is considered deprecated.\nThe minimal agent types like GraphAgent can be used normally as standard  types that only have the mandatory fields. This is now clear in the docs. (this was possible also before, just not clear)Please see the CHANGELOG.md for more details!","category":"page"},{"location":"#Features-1","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Free, open source and extremely transparent.\nIntuitive simple-to-learn software with high quality, extensive documentation.\nUniversal model structure where agents are identified by a unique id: AgentBasedModel.\nPowerful, feature-full and extendable API.\nModular, function-based design.\nSupport for many types of space: arbitrary graphs, regular grids, continuous space, or even instances of Open Street Map.\nMulti-agent support, for interactions between disparate agent species.\nScheduler interface (with default schedulers), making it easy to activate agents in a specific order (e.g. by the value of some property)\nAutomatic data collection in a DataFrame at desired intervals\nAggregating collected data during model evolution\nDistributed computing\nBatch running and batch data collection\nCustomizable visualization support for all kinds of models via the Makie ecosystem.\nInteractive applications for any agent based models, which are created with only 5 lines of code and look like this:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<video width=\"auto\" controls autoplay loop>\r\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\r\n</video>","category":"page"},{"location":"#Installation-1","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The package is in Julia's package list. Install it using this command:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"using Pkg; Pkg.add(\"Agents\")","category":"page"},{"location":"#Design-philosophy-of-Agents.jl-1","page":"Introduction","title":"Design philosophy of Agents.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agents.jl was designed with the following philosophy in mind:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Simple to learn and use, yet extendable, focusing on fast and scalable model creation and evolution.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(it should be said nevertheless, that when we have to make a choice between a simpler API or a more performant implementation, we tend to lean in favor of simplicity)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"There are multiple examples that highlight this core design principle, that one will quickly encounter when scanning through our API page. Here we just give two quick examples: first, there exists a universal function nearby_agents, which returns the agents nearby a given agent and within a given \"radius\". What is special for this function, which is allowed by Julia's Multiple Dispatch, is that nearby_agents will work for any space type the model has, reducing the learning curve of finding neighbors in ABMs made with Agents.jl. An even better example is perhaps our treatment of spaces. A user may create an entirely new kind of space (e.g. one representing a planet, or whatever else) by only extending 5 functions, as discussed in our Creating a new space type documentation.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Many other agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see e.g. here for an outdated review), spanning a varying degree of complexity. In the page ABM Framework Comparison we compare how our design philosophy puts us into comparison with other well accepted ABM software. Fascinatingly, even though the main focus of Agents.jl is simplicity and ease of use, it outperforms all software we compared it with.","category":"page"},{"location":"#Crash-course-on-agent-based-modeling-1","page":"Introduction","title":"Crash course on agent based modeling","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"An agent-based (or individual-based) model is a computational simulation of autonomous agents that react to their environment (including other agents) given a predefined set of rules [1]. ABMs have been adopted and studied in a variety of research disciplines. One reason for their popularity is that they enable a relaxation of many simplifying assumptions usually made by mathematical models. Relaxing such assumptions of a \"perfect world\" can change a model's behavior [2].","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Agent-based models are increasingly recognized as a useful approach for studying complex systems [3,4,5,6]. Complex systems cannot be fully understood using traditional mathematical tools which aggregate the behavior of elements in a system. The behavior of a complex system depends on both the behavior of and interactions between its elements (agents). Small changes in the input to complex systems or the behavior of its agents can lead to large changes in outcome. That is to say, a complex system's behavior is nonlinear, and that it is not only the sum of the behavior of its elements. Use of ABMs have become feasible after the availability of computers and has been growing ever since, especially in modeling biological and economic systems, and has extended to social studies and archaeology.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"An ABM consists of autonomous agents that behave given a set of rules. A classic example of an ABM is Schelling's segregation model, which we implement as an example here. This model uses a regular grid and defines agents at random positions on the grid. Agents can be from different social groups. Agents are happy/unhappy based on the fraction of their neighbors that belong to the same group as they are. If they are unhappy, they keep moving to new locations until they are happy. Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods. This is an example of emergent behavior from simple interactions of agents that can only be captured in an agent-based model.","category":"page"},{"location":"#Getting-help-1","page":"Introduction","title":"Getting help","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"You're looking for support for Agents.jl? Look no further! Here's some things you can do to resolve your questions about Agents.jl:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Read the online documentation! It is likely that the thing you want to know is already documented, so use the search bar and search away!\nChat with us in the channel #dynamics-bridged in the Julia Slack!\nPost a question in the Julia discourse in the category “Modelling and simulations”, using “agent” as a tag!\nIf you believe that you have encountered unexpected behavior or a bug in Agents.jl, then please do open an issue on our GitHub page providing a minimal working example!","category":"page"},{"location":"#Citation-1","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you use this package in work that leads to a publication, then please cite the paper below:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{Agents.jl,\r\n  doi = {10.1177/00375497211068820},\r\n  url = {https://doi.org/10.1177/00375497211068820},\r\n  year = {2022},\r\n  month = jan,\r\n  publisher = {{SAGE} Publications},\r\n  pages = {003754972110688},\r\n  author = {George Datseris and Ali R. Vahdati and Timothy C. DuBois},\r\n  title = {Agents.jl: a performant and feature-full agent-based modeling software of minimal code complexity},\r\n  journal = {{SIMULATION}},\r\n  volume = {0},\r\n  number = {0},\r\n}","category":"page"}]
}
