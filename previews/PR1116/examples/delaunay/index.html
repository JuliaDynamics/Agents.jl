<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DelaunayTriangulation.jl · Agents.jl</title><meta name="title" content="DelaunayTriangulation.jl · Agents.jl"/><meta property="og:title" content="DelaunayTriangulation.jl · Agents.jl"/><meta property="twitter:title" content="DelaunayTriangulation.jl · Agents.jl"/><meta name="description" content="Documentation for Agents.jl."/><meta property="og:description" content="Documentation for Agents.jl."/><meta property="twitter:description" content="Documentation for Agents.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Agents.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../flock/">Flocking model</a></li><li><a class="tocitem" href="../zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../event_rock_paper_scissors/">Spatial rock-paper-scissors (event based)</a></li><li><a class="tocitem" href="../">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li><li><a class="tocitem" href="../agents_visualizations/">Plotting and Interactivity</a></li><li><span class="tocitem">Ecosystem Integration</span><ul><li><a class="tocitem" href="../optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../celllistmap/">CellListMap.jl</a></li><li class="is-active"><a class="tocitem" href>DelaunayTriangulation.jl</a><ul class="internal"><li><a class="tocitem" href="#delaunay_model"><span>The model</span></a></li><li><a class="tocitem" href="#delaunay_model_implementation"><span>Implementation</span></a></li><li><a class="tocitem" href="#delaunay_model_running"><span>Running the model</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Ecosystem Integration</a></li><li class="is-active"><a href>DelaunayTriangulation.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DelaunayTriangulation.jl</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/main/examples/delaunay.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Integrating-Agents.jl-with-DelaunayTriangulation.jl"><a class="docs-heading-anchor" href="#Integrating-Agents.jl-with-DelaunayTriangulation.jl">Integrating Agents.jl with DelaunayTriangulation.jl</a><a id="Integrating-Agents.jl-with-DelaunayTriangulation.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Integrating-Agents.jl-with-DelaunayTriangulation.jl" title="Permalink"></a></h1><video width="auto" controls autoplay loop>
<source src="../delaunay_model.mp4" type="video/mp4">
</video><p>This example illustrates how to integrate Agents.jl with <a href="https://github.com/JuliaGeometry/DelaunayTriangulation.jl">DelaunayTriangulation.jl</a>, a Julia package for computing Delaunay triangulations and Voronoi tessellations in the plane. We consider a model based on those discussed in the paper <a href="https://doi.org/10.1371/journal.pcbi.1005387"><em>Comparing individual-based approaches to modelling the self-organization of multicellular tissues</em></a> by Osborne et al. (2017); other models, such as weighted Delaunay triangulation models as discussed in <a href="https://doi.org/10.1016/S0070-2153(07)81013-1">this paper</a>, are possible but are not considered here. For mathematical details about Delaunay triangulations and Voronoi tessellations, see the documentation for DelaunayTriangulation.jl. We emphasise that some parts of this example could be easily made more performant, but that is not the purpose of this exercise.</p><h2 id="delaunay_model"><a class="docs-heading-anchor" href="#delaunay_model">The model</a><a id="delaunay_model-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model" title="Permalink"></a></h2><p>The model we will be examining is a model of diffusion, proliferation, and death between three interacting species of cells.</p><p>Let the cell species be labelled <code>R</code>, <code>B</code>, and <code>O</code>, standing for red, blue, and orange cells, respectively. To each cell we associate some position <span>$\mathbf x_i(t)$</span>. Given a collection of cell positions <span>$\mathcal P(t) = \{\mathbf x_i(t)\}$</span>, let <span>$\mathcal V(\mathcal P(t))$</span> denote its Voronoi tessellation; to avoid issues with unbounded Voronoi cells on the boundary, we will clip the Voronoi cells to the convex hull of the points, <span>$\mathcal C\mathcal H(\mathcal P(t))$</span>; i.e., we are considering <span>$\mathcal V(\mathcal P(t)) \cap \mathcal C\mathcal H(\mathcal P(t))$</span> rather than <span>$\mathcal V(\mathcal P(t))$</span> itself. The Voronoi cell associated with the position <span>$\mathbf x_i(t)$</span> is denoted <span>$\mathcal V_i$</span>, and it is <span>$\mathcal V_i$</span> that we treat as the cell itself for the purpose of associating areas with cells.</p><h3 id="delaunay_model_diffusion"><a class="docs-heading-anchor" href="#delaunay_model_diffusion">Diffusion</a><a id="delaunay_model_diffusion-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_diffusion" title="Permalink"></a></h3><p>Now let&#39;s describe how the cells move in space and interact with eachother. We use a Hookean force law model for describing the interactions between cells, so that</p><p class="math-container">\[\eta\dfrac{\mathrm d\mathbf x_i}{\mathrm dt} = \mathbf F_i(t) = \sum_{j \in \mathcal N_i(t)} \mathbf F_{ij}(t) + \mathbf F^{\textrm{rand}}_i(t),\]</p><p>where <span>$\eta$</span> is a damping constant, <span>$\mathcal N_i(t)$</span> is the set of neighbours of <span>$\mathbf x_i(t)$</span> at time <span>$t$</span> in the Delaunay triangulation <span>$\mathcal D\mathcal T(\mathcal P(t))$</span>, <span>$\mathbf F_{ij}$</span> is the force on <span>$\mathbf x_i$</span> due to <span>$\mathbf x_j$</span>, and <span>$\mathbf F^{\textrm{rand}}_i$</span> is a random force applied to <span>$\mathbf x_i$</span>. The interaction forces <span>$\mathbf F_{ij}$</span> are given by</p><p class="math-container">\[\mathbf F_{ij}(t) = \mu_{ij}(t)\left(\|\mathbf x_{ij}\| - s_{ij}(t)\right)\hat{\mathbf x}_{ij},\]</p><p>where <span>$\mu_{ij}(t)$</span> is the spring constant, <span>$s_{ij}(t)$</span> is the resting spring length, <span>$\mathbf x_{ij} = \mathbf x_j - \mathbf x_i$</span>, and <span>$\hat{\mathbf x}_{ij} = \mathbf x_{ij}/\|\mathbf x_{ij}\|$</span>. To avoid issues with unduly long edges between cells along the boundary, whenever <span>$\|\mathbf x_{ij}\| &gt; \ell_{\max}$</span> we prevent the cells from interacting and declare <span>$\mathbf F_{ij} = \mathbf 0$</span>. The spring constant is given by <span>$\mu_{ij} = \mu$</span> when the cells interacting are of the same species, otherwise</p><p class="math-container">\[\mu_{ij}(t) = \begin{cases} \mu_{\textrm{het}}\mu &amp; \|\mathbf x_{ij}\| &gt; s_{ij}(t), \\ \mu &amp; \|\mathbf x_{ij}\| \leq s_{ij}(t), \end{cases}\]</p><p>where <span>$\mu_{\textrm{het}}$</span> is a heterotypic spring constant factor used to promote adhesion between cells of different species that are further apart than their resting spring length. For <span>$t &lt; 1$</span> we use <span>$\mu_{\textrm{het}} = 1$</span> to prevent this adhesion for the initial population of cells. The resting spring length is allowed to grow over the first hour of each cell&#39;s life, so that</p><p class="math-container">\[s_{ij}(t) = \min\{s, (s - \varepsilon)t + \varepsilon\},\]</p><p>where <span>$\varepsilon$</span> is an expansion rate and <span>$s$</span> is the mature resting spring length. With this definition, <span>$s_{ij}(t)$</span> evolves from <span>$\varepsilon$</span> to <span>$s$</span> over the first hour of the cell&#39;s life, and remains at <span>$s$</span> thereafter. The random force <span>$\mathbf F^{\textrm{rand}}_i$</span> is given by</p><p class="math-container">\[\mathbf F^{\textrm{rand}}_i(t) = \sqrt{\frac{2\xi}{\Delta t}}(\eta_1, \eta_2),\]</p><p>where <span>$\xi$</span> is a diffusivity parameter, <span>$\Delta t$</span> is the step size used in the simulation, and <span>$\eta_1$</span> and <span>$\eta_2$</span> are independent standard normal random variables.</p><p>To use these forces to evolve the cell positions, we use the forward Euler method to write</p><p class="math-container">\[\mathbf x_i(t + \Delta t) = \mathbf x_i(t) + \Delta t \dfrac{1}{\eta}\mathbf F_i(t).\]</p><p>If this computed <span>$\mathbf x_i(t + \Delta t)$</span> puts the cell position outside of some box <span>$[a, b] \times [c, d]$</span>, the step is rejected and the cell position remains at <span>$\mathbf x_i(t)$</span>. (Other choices such as restricting the cell position to the box and only allowing it to slide along the boundary are possible, but are not considered here.)</p><h3 id="delaunay_model_proliferation"><a class="docs-heading-anchor" href="#delaunay_model_proliferation">Proliferation</a><a id="delaunay_model_proliferation-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_proliferation" title="Permalink"></a></h3><p>Now we consider cell proliferation. Cells are assumed to only be allowed to proliferate if they are between the ages <span>$t_{\min}^k \leq t \leq t_{\max}^k$</span>, where <span>$k$</span> is the species of the cell so that the ages are species-dependent. Cells are assumed to proliferate according to a logistic proliferation law, and at most one cell may proliferation over a given interval <span>$[t, t + \Delta t)$</span> (meaning <span>$\Delta t$</span> should be chosen to be small enough that this is not an issue). Given that a cell does proliferate, the probability that it proliferates is given by <span>$G_i^k\Delta t$</span>, where</p><p class="math-container">\[G_i^k = \max\left\{0, \beta^k\left(1 - \frac{1}{KA_i}\right)\right\},\]</p><p>where <span>$\beta^k$</span> is the intrinsic proliferation rate, <span>$K$</span> is a cell carrying capacity density, and <span>$A_i$</span> is the area of <span>$\mathcal V_i$</span>. Thus, the probability that any proliferation event occurs in <span>$[t, t+\Delta t)$</span> is given by <span>$\sum_i G_i^k\Delta t$</span>, where the sum is over all alive cells. When a cell does proliferate, the daughter cell is placed at a random position in <span>$\mathcal V_i$</span> and is inserted into the tessellation. We also assume that cells that are too small cannot proliferate, and set <span>$G_i^k = 0$</span> whenever <span>$A_i &lt; A_{\min}$</span> for some minimum allowable area <span>$A_{\min}$</span>.</p><p>When a cell proliferates, we allow for a mutation event to occur so that the daughter cell is not necessarily of the same species as its parent. We define probabilities <span>$p_{\textrm{mut}}^k$</span> for each cell type, so that a red cell instead produces a blue cell with probability <span>$p^R$</span>, a blue cell instead produces an orange cell with probability <span>$p^B$</span>, and an orange cell instead produces a red cell with probability <span>$p^O$</span>.</p><h3 id="delaunay_model_death"><a class="docs-heading-anchor" href="#delaunay_model_death">Death</a><a id="delaunay_model_death-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_death" title="Permalink"></a></h3><p>The final component of the model is cell death. There are three possible ways for a cell to die. Firstly, it may be too old, in which case we simply kill the cell. These maximum ages are denoted <span>$d_{\max}^k$</span> for each species <span>$k$</span>. Secondly, a cell may get sick and die. For each cell over each time interval, there is a probability <span>$p_{\textrm{sick}}^k\Delta t$</span> that it will die over that interval. Lastly, it may be outside of <span>$[a, b] \times [c, d]$</span>, in which case we kill the cell; this might only occur for daughter cells randomly placed in <span>$\mathcal V_i$</span> and is done for simplicity.</p><h2 id="delaunay_model_implementation"><a class="docs-heading-anchor" href="#delaunay_model_implementation">Implementation</a><a id="delaunay_model_implementation-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_implementation" title="Permalink"></a></h2><p>Let&#39;s now get into the details of the implementation. Let us start by defining our agent type. The cell types are defined using an <code>@enum</code>.</p><pre><code class="language-julia hljs">using Agents, StaticArrays
@enum CellType begin
    Red
    Blue
    Orange
end
@agent struct Cell(ContinuousAgent{2,Float64})
    const color::CellType
    const birth::Float64
    death::Float64 = Inf
end</code></pre><h3 id="delaunay_model_parameters"><a class="docs-heading-anchor" href="#delaunay_model_parameters">Model parameters</a><a id="delaunay_model_parameters-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_parameters" title="Permalink"></a></h3><p>To now actually use these agents, we need to have a definition for the <code>model_step!</code> function; we don&#39;t use <code>agent_step!</code> since it&#39;s simpler to do everything within <code>model_step!</code>. Defining <code>model_step!</code> requires us to first define all the other components.</p><p>We need to make these agents compatible with the interface required for DelaunayTriangulation.jl so that we can directly provide <code>Cell</code>s into DelaunayTriangulation.jl. The functions we need to conform to this interface are minimal.</p><pre><code class="language-julia hljs">using DelaunayTriangulation
const DT = DelaunayTriangulation
DT.getx(cell::Cell) = cell.pos[1]
DT.gety(cell::Cell) = cell.pos[2]
DT.number_type(::Type{Cell}) = Float64
DT.number_type(::Type{Vector{Cell}}) = Float64
DT.is_point2(::Cell) = true</code></pre><p>To define the model parameters such as <span>$\mu$</span>, we use functions. An alternative is to just pass these as model parameters, but this is simpler for the purposes of this example.</p><pre><code class="language-julia hljs">spring_constant(p, q) = 20.0 # μ
heterotypic_spring_constant(p, q) = p.color == q.color ? 1.0 : 0.1 # μₕₑₜ
drag_coefficient(p) = 1 / 2 # η
mature_cell_spring_rest_length(p, q) = 1.0 # s
expansion_rate(p, q) = 0.05 * mature_cell_spring_rest_length(p, q) # ε
perturbation(p) = 0.01 # ξ
cutoff_distance(p, q) = 1.5 # ℓₘₐₓ
intrinsic_proliferation_rate(p) = p.color == Red ? 0.4 : p.color == Blue ? 0.5 : 0.8 # β
carrying_capacity_density(p) = 100.0^2 # K
min_division_age(p) = 1.0 # tₘᵢₙ
max_division_age(p) = p.color == Red ? 15.0 : p.color == Blue ? 20.0 : 3.0 # tₘₐₓ
max_age(p) = p.color == Red ? 10.0 : p.color == Blue ? 10.0 : 3.0 # dₘₐₓ
death_rate(p) = p.color == Red ? 0.001 : p.color == Blue ? 0.00005 : 0.0001 # psick
mutation_probability(p) = p.color == Red ? 0.3 : p.color == Blue ? 0.5 : 0.05 # pₘᵤₜ
min_area(p) = 1e-2 # Aₘᵢₙ</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">min_area (generic function with 1 method)</code></pre><p>Next, we need the functions that compute these parameters for a given time and for a given pair of cells. In these functions, the <code>model</code> parameter is the <code>StandardABM</code> we will define later.</p><pre><code class="language-julia hljs">using LinearAlgebra
spring_constant(model, i::Int, j::Int, t) = spring_constant(model, model[i], model[j], t)
function spring_constant(model, p, q, t)
    δ = norm(p.pos - q.pos)
    s = rest_length(model, p, q, t)
    μ = spring_constant(p, q)
    t &lt; 1 &amp;&amp; return μ # no adhesion for the initial population
    μₕₑₜ = heterotypic_spring_constant(p, q)
    if δ &gt; s
        return μₕₑₜ * μ
    else
        return μ
    end
end

rest_length(model, i::Int, j::Int, t) = rest_length(model, model[i], model[j]..., t)
function rest_length(model, p, q, t)
    s = mature_cell_spring_rest_length(p, q)
    ε = expansion_rate(p, q)
    return min(s, (s - ε) * t + ε)
end

function proliferation_rate(model, i::Int, t)
    p = model[i]
    age = t - p.birth
    tₘᵢₙ = min_division_age(p)
    tₘₐₓ = max_division_age(p)
    A = get_area(model.tessellation, i)
    if age ≤ tₘᵢₙ || age ≥ tₘₐₓ || A &lt; min_area(p)
        return 0.0
    end
    vorn = model.tessellation
    Aᵢ = get_area(vorn, i)
    β = intrinsic_proliferation_rate(p)
    K = carrying_capacity_density(p)
    return max(0.0, β * (1 - 1 / (K * Aᵢ)))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">proliferation_rate (generic function with 1 method)</code></pre><p>Now we need the function that computes the total force on a cell at each time.</p><pre><code class="language-julia hljs">force(model, i::Int, j::Int, t) = force(model, model[i], model[j], t)
function force(model, p, q, t)
    δ = norm(p.pos - q.pos)
    if δ &gt; cutoff_distance(p, q)
        return SVector(0.0, 0.0)
    end
    μ = spring_constant(model, p, q, t)
    s = rest_length(model, p, q, t)
    rᵢⱼ = q.pos - p.pos
    return μ * (norm(rᵢⱼ) - s) * rᵢⱼ / norm(rᵢⱼ)
end
function random_force(model, i)
    p = model[i]
    ξ = perturbation(p)
    η₁, η₂ = randn(), randn()
    Δt = model.dt
    return sqrt(2ξ / Δt) * SVector(η₁, η₂)
end
function force(model, i::Int, t)
    F = SVector(0.0, 0.0)
    for j in get_neighbours(model.triangulation, i)
        DT.is_ghost_vertex(j) &amp;&amp; continue
        F = F + force(model, i, j, t)
    end
    F = F + random_force(model, i)
    return F
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">force (generic function with 3 methods)</code></pre><p>In the last <code>force</code> function, the check for <code>is_ghost_vertex</code> is needed since DelaunayTriangulation.jl stores <em>ghost vertices</em> in the triangulation for representing boundary information; see <a href="https://juliageometry.github.io/DelaunayTriangulation.jl/stable/manual/ghost_triangles/">the documentation for DelaunayTriangulation.jl</a>. Note also that this <code>force</code> is not the velocity of the cell itself, but the force acting on the cell. To get the velocity, we must divide by the drag coefficient.</p><pre><code class="language-julia hljs">velocity(model, i, t) = force(model, i, t) / drag_coefficient(model[i])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">velocity (generic function with 1 method)</code></pre><h3 id="delaunay_model_model_step"><a class="docs-heading-anchor" href="#delaunay_model_model_step">Implementing <code>model_step!</code></a><a id="delaunay_model_model_step-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_model_step" title="Permalink"></a></h3><p>Migrating all the cells can now be done as follows. This is done in two stages, where we first compute the velocities and then move the cells. This is needed since, if we update the cell positions while updating the velocities, later cells will not be correct as they will be computed using the updated positions. The <code>each_solid_vertex</code> function iterates all over all the vertices in the triangulation, and thus the alive cells; the <code>solid</code> adjective is used to avoid iterating over the ghost vertices. (A more performant way to handle these updates would also be to iterate over edges rather than vertices, but this is not considered here.)</p><pre><code class="language-julia hljs">function update_velocities!(model, t)
    for i in each_solid_vertex(model.triangulation)
        model[i].vel = velocity(model, i, t)
    end
    return model
end
function new_position(model, i, t)
    xᵢ = model[i]
    vel = xᵢ.vel
    r = xᵢ.pos + model.dt * vel
    x, y = r
    xmax, ymax = spacesize(model)
    if x &lt; 0 || x &gt; xmax || y &lt; 0 || y &gt; ymax
        r = xᵢ.pos
    end
    return r
end
function update_positions!(model, t)
    update_velocities!(model, t)
    for i in each_solid_vertex(model.triangulation)
        model[i].pos = new_position(model, i, t)
    end
    return model
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">update_positions! (generic function with 1 method)</code></pre><p>The next component to implement is proliferation. This will be a bit complicated since we need to know how to sample from the Voronoi cell. Let&#39;s start by writing the function that allows us to identify the Voronoi cell to proliferate. Since the proliferation probabilities are <span>$G_i\Delta t$</span>, we can build a vector that gives the cumulative sum of these probabilities; note that the last entry in this vector will be the sum of all the probabilities, and thus the probability that any proliferation event occurs.</p><pre><code class="language-julia hljs">function proliferation_probability(model, t)
    Δt = model.dt
    probs = zeros(nagents(model)) # Technically nagents is not the number of alive agents, but with the way we are handling agents this is correct
    for i in allids(model)
        if !DT.has_vertex(model.triangulation, i) || i in model.dead_cells
            i &gt; 1 &amp;&amp; (probs[i] = probs[i-1])
            continue
        end
        Gᵢ = proliferation_rate(model, i, t)
        if i &gt; 1
            probs[i] = probs[i-1] + Gᵢ * Δt
        else
            probs[i] = Gᵢ * Δt
        end
    end
    return probs
end
function select_proliferative_cell(model, probs)
    E = probs[end]
    u = rand() * E
    i = searchsortedlast(probs, u) + 1 # searchsortedlast instead of searchsortedfirst since we skip over some agents in probs
    return i
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">select_proliferative_cell (generic function with 1 method)</code></pre><p>Since we will not be clearing agents from the model, and instead only marking them as dead, we use <code>has_vertex</code> on the triangulation rather than <code>hasid</code> on the model itself.</p><p>Now let&#39;s write the function for sampling from a Voronoi cell. First, for sampling from a triangle, we use the algorithm from <a href="https://blogs.sas.com/content/iml/2020/10/19/random-points-in-triangle.html">this article</a>.</p><pre><code class="language-julia hljs">function sample_triangle(tri::Triangulation, T)
    i, j, k = triangle_vertices(T)
    p, q, r = get_point(tri, i, j, k)
    px, py = getxy(p)
    qx, qy = getxy(q)
    rx, ry = getxy(r)
    a = (qx - px, qy - py)
    b = (rx - px, ry - py)
    u₁, u₂ = rand(), rand()
    if u₁ + u₂ &gt; 1
        u₁, u₂ = 1 - u₁, 1 - u₂
    end
    ax, ay = getxy(a)
    bx, by = getxy(b)
    wx, wy = u₁ * ax + u₂ * bx, u₁ * ay + u₂ * by
    return SVector(px + wx, py + wy)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sample_triangle (generic function with 1 method)</code></pre><p>Next, we need to know how to select a random triangle from a triangulation. This is done by using a weighted sample according to the triangle areas.</p><pre><code class="language-julia hljs">using StreamSampling
function random_triangle(tri::Triangulation)
    triangles = DT.each_solid_triangle(tri)
    area(T) = DT.triangle_area(get_point(tri, triangle_vertices(T)...)...)
    T = itsample(triangles, area)
    return T
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">random_triangle (generic function with 1 method)</code></pre><p>With these functions, sampling from a Voronoi cell is simple: First, triangulate the Voronoi cell. Then, sample a triangle from the triangulation, and finally sample a point from the triangle. The <code>triangulate_convex</code> function can efficiently triangulate the Voronoi cell, remembering that Voronoi cells are convex.</p><pre><code class="language-julia hljs">function triangulate_voronoi_cell(vorn::VoronoiTessellation, i)
    S = @view get_polygon(vorn, i)[1:end-1]
    points = DT.get_polygon_points(vorn)
    return triangulate_convex(points, S)
end
function sample_voronoi_cell(vorn::VoronoiTessellation, i)
    tri = triangulate_voronoi_cell(vorn, i)
    T = random_triangle(tri)
    return sample_triangle(tri, T)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">sample_voronoi_cell (generic function with 1 method)</code></pre><p>We can now finally write the functions for computing the daughter cell and performing the proliferation event.</p><pre><code class="language-julia hljs">function place_daughter_cell!(model, i, t)
    parent = model[i]
    daughter = sample_voronoi_cell(model.tessellation, i) # this is an SVector, not a Cell
    u = rand()
    clr = parent.color
    if u &lt; mutation_probability(parent)
        newclr = clr == Red ? Blue : clr == Blue ? Orange : Red
    else
        newclr = clr
    end
    add_agent!(daughter, model; color=newclr, birth=t, vel=SVector(0.0, 0.0))
    return daughter
end
function proliferate_cells!(model, t)
    probs = proliferation_probability(model, t)
    u = rand()
    event = u &lt; probs[end]
    !event &amp;&amp; return false
    i = select_proliferative_cell(model, probs)
    daughter = place_daughter_cell!(model, i, t)
    return true
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">proliferate_cells! (generic function with 1 method)</code></pre><p>Next, we need the functions for cell death. This is much simpler. Rather than deleting the agents directly, we only mark them as dead.</p><pre><code class="language-julia hljs">function cull_cell!(model, i, t)
    p = model[i]
    elder = t - p.birth &gt; max_age(p)
    sick = rand() &lt; model.dt * death_rate(p)
    xmax, ymax = spacesize(model)
    x, y = p.pos
    outside = x &lt; 0 || x &gt; xmax || y &lt; 0 || y &gt; ymax
    if elder || sick || outside
        push!(model.dead_cells, i)
        p.death = t
    end
    return model
end
function cull_cells!(model, t)
    for i in each_solid_vertex(model.triangulation)
        cull_cell!(model, i, t)
    end
    return model
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">cull_cells! (generic function with 1 method)</code></pre><p>We are finally in a position to define <code>model_step!</code>. In this function, for updating the Delaunay triangulation and the Voronoi tessellation, we simply recompute them from scratch. There could be more performant ways to do this, such as with <a href="https://doi.org/10.1145/1064092.1064129">Shewchuk&#39;s star-splaying algorithm</a> for recomputing the triangulation efficiently from the previous one, but we keep it simple here.</p><pre><code class="language-julia hljs">function model_step!(model)
    stepn = abmtime(model)
    t = stepn * model.dt
    cull_cells!(model, t)
    proliferate_cells!(model, t)
    update_positions!(model, t)
    model.triangulation = retriangulate(model.triangulation, allagents(model); skip_points=model.dead_cells)
    model.tessellation = voronoi(model.triangulation, clip=true)
    return model
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">model_step! (generic function with 1 method)</code></pre><h3 id="delaunay_model_initialisation"><a class="docs-heading-anchor" href="#delaunay_model_initialisation">Initialising the model</a><a id="delaunay_model_initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_initialisation" title="Permalink"></a></h3><p>Now with <code>model_step!</code> implemented, we are ready to actually work with our model. To start, we need a function that initialises our model. The initial population of cells is defined by placing random red cells in a circle centred at the centre of the box. The box <span>$[a, b] \times [c, d]$</span> is defined by the <code>sides</code> parameter, defaulting to <span>$[0, 20] \times [0, 20]$</span>. In this function, for type reasons, we pass to <code>triangulate</code> a vector of <code>Cell</code>s, rather than a vector of <code>SVector</code>s. This means we need a bit of duplication with <code>add_agent!</code> since <code>StandardABM</code> accepts the agent type rather than the agents themselves.</p><pre><code class="language-julia hljs">using Random
function initialize_cell_model(;
    ninit=50,
    radius=2.0,
    dt=0.01,
    sides=SVector(20.0, 20.0))
    Random.seed!(0)
    # Generate the initial random positions
    cent = SVector(sides[1] / 2, sides[2] / 2)
    cells = map(1:ninit) do i
        θ = 2π * rand()
        r = radius * sqrt(rand())
        pos = cent + SVector(r * cos(θ), r * sin(θ))
        cell = Cell(; id=i, pos=pos,
            color=Red, birth=0.0, vel=SVector(0.0, 0.0))
    end
    positions = [cell.pos for cell in cells]

    # Compute the triangulation and the tessellation
    triangulation = triangulate(cells)
    tessellation = voronoi(triangulation, clip=true)

    # Define the model parameters
    properties = Dict(
        :triangulation =&gt; triangulation,
        :tessellation =&gt; tessellation,
        :dt =&gt; dt,
        :dead_cells =&gt; Set{Int}()
    )

    # Define the space
    space = ContinuousSpace(sides; periodic=false)

    # Define the model
    model = StandardABM(Cell, space; model_step!, properties, container=Vector)

    # Add the agents
    for (id, pos) in pairs(positions)
        add_agent!(pos, model; color=Red, birth=0.0, vel=SVector(0.0, 0.0))
    end

    return model
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">initialize_cell_model (generic function with 1 method)</code></pre><h2 id="delaunay_model_running"><a class="docs-heading-anchor" href="#delaunay_model_running">Running the model</a><a id="delaunay_model_running-1"></a><a class="docs-heading-anchor-permalink" href="#delaunay_model_running" title="Permalink"></a></h2><p>Let&#39;s define the data collection functions. To avoid collecting to much data, we avoid collecting any data on the agents themselves, and only consider model-level data. We want a function to count the number of cell types.</p><pre><code class="language-julia hljs">function count_cell_type(model, type)
    stepn = abmtime(model)
    t = stepn * model.dt
    n = 0
    for i in each_solid_vertex(model.triangulation)
        n += model[i].color == type
    end
    return n
end
count_red(model) = count_cell_type(model, Red)
count_blue(model) = count_cell_type(model, Blue)
count_orange(model) = count_cell_type(model, Orange)
count_total(model) = num_solid_vertices(model.triangulation)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">count_total (generic function with 1 method)</code></pre><p>Let&#39;s also compute the average cell area and diameter, where the diameter of a cell is defined as the length of the longest line segment between any two vertices of the cell. We also consider the average spring length, i.e. the average length of the edges in the Delaunay triangulation.</p><pre><code class="language-julia hljs">using StatsBase
function average_cell_area(model)
    area_itr = (get_area(model.tessellation, i) for i in each_solid_vertex(model.triangulation))
    mean_area = mean(area_itr)
    return mean_area
end
function cell_diameter(vorn, i)
    S = get_polygon(vorn, i)
    # This is an O(|S|^2) method, but |S| is small so it is fine
    max_d = 0.0
    for i in S
        p = get_polygon_point(vorn, i)
        for j in S
            i == j &amp;&amp; continue
            q = get_polygon_point(vorn, j)
            d = norm(getxy(p) .- getxy(q))
            max_d = max(max_d, d)
        end
    end
    return max_d
end
function average_cell_diameter(model)
    diam_itr = (cell_diameter(model.tessellation, i) for i in each_solid_vertex(model.triangulation))
    mean_diam = mean(diam_itr)
    return mean_diam
end
function average_spring_length(model)
    spring_itr = (norm(model[i].pos - model[j].pos) for (i, j) in each_solid_edge(model.triangulation))
    mean_spring = mean(spring_itr)
    return mean_spring
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">average_spring_length (generic function with 1 method)</code></pre><p>Now let&#39;s simulate. We start by running the entire simulation and looking at the results.</p><pre><code class="language-julia hljs">finalT = 50.0
model = initialize_cell_model()
nsteps = Int(finalT / model.dt)
mdata = [count_red, count_blue, count_orange, count_total,
    average_cell_area, average_cell_diameter, average_spring_length]
agent_df, model_df = run!(model, nsteps; mdata);</code></pre><pre><code class="language-julia hljs">using CairoMakie
time = 0:model.dt:finalT
fig = Figure(fontsize=24)
ax = Axis(fig[1, 1], xlabel=&quot;Time&quot;, ylabel=&quot;Count&quot;, width=600, height=400)
lines!(ax, time, model_df[!, :count_red], color=:red, label=&quot;Red&quot;, linewidth=3)
lines!(ax, time, model_df[!, :count_blue], color=:blue, label=&quot;Blue&quot;, linewidth=3)
lines!(ax, time, model_df[!, :count_orange], color=:orange, label=&quot;Orange&quot;, linewidth=3)
lines!(ax, time, model_df[!, :count_total], color=:black, label=&quot;Total&quot;, linewidth=3)
axislegend(ax, position=:lt)
ax = Axis(fig[1, 2], xlabel=&quot;Time&quot;, ylabel=&quot;Average&quot;, width=600, height=400)
lines!(ax, time, model_df[!, :average_cell_area], color=:black, label=&quot;Cell area&quot;, linewidth=3)
lines!(ax, time, model_df[!, :average_cell_diameter], color=:magenta, label=&quot;Cell diameter&quot;, linewidth=3)
lines!(ax, time, model_df[!, :average_spring_length], color=:red, label=&quot;Spring length&quot;, linewidth=3)
axislegend(ax, position=:rb)
resize_to_layout!(fig)
fig</code></pre><img src="26359d87.png" alt="Example block output"/><p>Let&#39;s now animate the results. To visualise the results we make use of <code>abmplot</code>, which requires that we know how to make a marker for each agent. We define a function <code>voronoi_marker</code> that returns the vertices of the Voronoi cell associated with the agent, and a function <code>voronoi_color</code> that returns the color of the agent. Note that, when plotting polygons, <code>abmplot</code> internally assumes that the cells are positioned at the origin. Thus, when obtaining the Voronoi cells, we need to subtract the position of the cell from the vertices of the Voronoi cell. We will show the data at each step during the animation as well, which requires a bit more complexity than just simply using <code>abmvideo</code>. To avoid synchronisation issues, rather than using Makie.jl&#39;s <code>@lift</code> we use <code>Observable</code>s and update them directly.</p><pre><code class="language-julia hljs">voronoi_marker = (model, cell) -&gt; begin
    id = cell.id
    verts = get_polygon_coordinates(model.tessellation, id)
    return Makie.Polygon([Point2f(getxy(q) .- cell.pos) for q in verts])
end
voronoi_color(cell) = cell.color == Red ? :red : cell.color == Blue ? :blue : :orange
model = initialize_cell_model() # reinitialise the model for the animation
fig, ax, amobs = abmplot(model, agent_marker=cell -&gt; voronoi_marker(model, cell), agent_color=voronoi_color,
    agentsplotkwargs=(strokewidth=1,), figure=(; size=(1600, 800), fontsize=34), mdata=mdata,
    axis=(; width=800, height=800), when=10)
current_time = Observable(0.0)
t = Observable([0.0])
nred = Observable(amobs.mdf[][!, :count_red])
nblue = Observable(amobs.mdf[][!, :count_blue])
norange = Observable(amobs.mdf[][!, :count_orange])
ntotal = Observable(amobs.mdf[][!, :count_total])
avg_area = Observable(amobs.mdf[][!, :average_cell_area])
avg_diam = Observable(amobs.mdf[][!, :average_cell_diameter])
avg_spring = Observable(amobs.mdf[][!, :average_spring_length])
plot_layout = fig[:, end+1] = GridLayout()
count_layout = plot_layout[1, 1] = GridLayout()
ax_count = Axis(count_layout[1, 1], xlabel=&quot;Time&quot;, ylabel=&quot;Count&quot;, width=600, height=400)
lines!(ax_count, t, nred, color=:red, label=&quot;Red&quot;, linewidth=3)
lines!(ax_count, t, nblue, color=:blue, label=&quot;Blue&quot;, linewidth=3)
lines!(ax_count, t, norange, color=:orange, label=&quot;Orange&quot;, linewidth=3)
lines!(ax_count, t, ntotal, color=:black, label=&quot;Total&quot;, linewidth=3)
vlines!(ax_count, current_time, color=:grey, linestyle=:dash, linewidth=3)
xlims!(ax_count, 0, finalT)
ylims!(ax_count, 0, 800)
avg_layout = plot_layout[2, 1] = GridLayout()
ax_avg = Axis(avg_layout[1, 1], xlabel=&quot;Time&quot;, ylabel=&quot;Average&quot;, width=600, height=400)
lines!(ax_avg, t, avg_area, color=:black, label=&quot;Cell area&quot;, linewidth=3)
lines!(ax_avg, t, avg_diam, color=:magenta, label=&quot;Cell diameter&quot;, linewidth=3)
lines!(ax_avg, t, avg_spring, color=:red, label=&quot;Spring length&quot;, linewidth=3)
vlines!(ax_avg, current_time, color=:grey, linestyle=:dash, linewidth=3)
axislegend(ax_avg, position=:rt)
xlims!(ax_avg, 0, finalT)
ylims!(ax_avg, 0, 2)
resize_to_layout!(fig)
on(amobs.mdf) do mdf
    current_time[] = abmtime(amobs.model[]) * model.dt
    t.val = mdf[!, :time] .* model.dt
    nred[] = mdf[!, :count_red]
    nblue[] = mdf[!, :count_blue]
    norange[] = mdf[!, :count_orange]
    ntotal[] = mdf[!, :count_total]
    avg_area[] = mdf[!, :average_cell_area]
    avg_diam[] = mdf[!, :average_cell_diameter]
    avg_spring[] = mdf[!, :average_spring_length]
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ObserverFunction defined at delaunay.md:650 operating on Observable(<span class="sgr1">1×8 DataFrame
 Row │ time   count_red  count_blue  count_orange  count_total  average_cell_a ⋯
     │<span class="sgr90"> Int64  Int64      Int64       Int64         Int64        Float64        ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │     0         50           0             0           50           0.181 ⋯
</span><span class="sgr36">                                                               3 columns omitted)</span></span></code></pre><p>To now record, use <code>record</code> from Makie.</p><pre><code class="language-julia hljs">record(fig, &quot;delaunay_model.mp4&quot;, 1:(nsteps ÷ 10), framerate=24) do i
    step!(amobs, 10)
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;delaunay_model.mp4&quot;</code></pre><video width="auto" controls autoplay loop>
<source src="../delaunay_model.mp4" type="video/mp4">
</video></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../celllistmap/">« CellListMap.jl</a><a class="docs-footer-nextpage" href="../../performance_tips/">Performance Tips »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.0 on <span class="colophon-date" title="Sunday 15 December 2024 02:26">Sunday 15 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
