var documenterSearchIndex = {"docs":
[{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/hk.jl\"","category":"page"},{"location":"examples/hk/#HK-(Hegselmann-and-Krause)-opinion-dynamics-model","page":"Hegselmann-Krause opinion dynamics","title":"HK (Hegselmann and Krause) opinion dynamics model","text":"","category":"section"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"This example showcases","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"How to do synchronous updating of Agent properties (also know as Synchronous update schedule). In a Synchronous update schedule changes made to an agent are not seen by other agents until the next step, see also Wilensky 2015, p.286).\nHow to terminate the system evolution on demand according to a boolean function.\nHow to terminate the system evolution according to what happened on the previous step.","category":"page"},{"location":"examples/hk/#Model-overview","page":"Hegselmann-Krause opinion dynamics","title":"Model overview","text":"","category":"section"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"This is an implementation of a simple version of the Hegselmann and Krause (2002) model. It is a model of opinion formation with the question: which parameters' values lead to consensus, polarization or fragmentation? It models interacting groups of agents (as opposed to interacting pairs, typical in the literature) in which it is assumed that if an agent disagrees too much with the opinion of a source of influence, the source can no longer influence the agent's opinion. There is then a \"bound of confidence\". The model shows that the systemic configuration is heavily dependent on this parameter's value.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"The model has the following components:","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"A set of n Agents with opinions xᵢ in the range [0,1] as attribute\nA parameter ϵ called \"bound\" in (0, 0.3]\nThe update rule: at each step every agent adopts the mean of the opinions which are within the confidence bound ( |xᵢ - xⱼ| ≤ ϵ).","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"It is also available from the Models module as Models.hk.","category":"page"},{"location":"examples/hk/#Core-structures","page":"Hegselmann-Krause opinion dynamics","title":"Core structures","text":"","category":"section"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"We start by defining the Agent type and initializing the model. The Agent type has two fields so that we can implement the synchronous update.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"using Agents\nusing Statistics: mean\n\nmutable struct HKAgent <: AbstractAgent\n    id::Int\n    old_opinion::Float64\n    new_opinion::Float64\n    previous_opinon::Float64\nend","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"There is a reason the agent has three fields that are \"the same\". The old_opinion is used for the synchronous agent update, since we require access to a property's value at the start of the step and the end of the step. The previous_opinion is the opinion of the agent in the previous step, as the model termination requires access to a property's value at the end of the previous step, and the end of the current step.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"We could, alternatively, make the three opinions a single field with vector value.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function hk_model(; numagents = 100, ϵ = 0.2)\n    model = ABM(HKAgent, scheduler = fastest, properties = Dict(:ϵ => ϵ))\n    for i in 1:numagents\n        o = rand()\n        add_agent!(model, o, o, -1)\n    end\n    return model\nend\n\nmodel = hk_model()","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Add some helper functions for the update rule. As there is a filter in the rule we implement it outside the agent_step! method. Notice that the filter is applied to the :old_opinion field.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function boundfilter(agent, model)\n    filter(\n        j -> abs(agent.old_opinion - j) < model.ϵ,\n        [a.old_opinion for a in allagents(model)],\n    )\nend\nnothing # hide","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Now we implement the agent_step!","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function agent_step!(agent, model)\n    agent.previous_opinon = agent.old_opinion\n    agent.new_opinion = mean(boundfilter(agent, model))\nend\nnothing # hide","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"and model_step!","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function model_step!(model)\n    for a in allagents(model)\n        a.old_opinion = a.new_opinion\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"From this implementation we see that to implement synchronous scheduling we define an Agent type with old and new fields for attributes that are changed via the synchronous update. In agent_step! we use the old field then, after updating all the agents new fields, we use the model_step! to update the model for the next iteration.","category":"page"},{"location":"examples/hk/#Running-the-model","page":"Hegselmann-Krause opinion dynamics","title":"Running the model","text":"","category":"section"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"The parameter of interest is now :new_opinion, so we assign it to variable adata and pass it to the run! method to be collected in a DataFrame.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"In addition, we want to run the model only until all agents have converged to an opinion. From the documentation of step! one can see that instead of specifying the amount of steps we can specify a function instead.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function terminate(model, s)\n    if any(\n        !isapprox(a.previous_opinon, a.new_opinion; rtol = 1e-12) for a in allagents(model)\n    )\n        return false\n    else\n        return true\n    end\nend\n\nstep!(model, agent_step!, model_step!, terminate)\nmodel[1]","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Alright, let's wrap everything in a function and do some data collection using run!.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"function model_run(; kwargs...)\n    model = hk_model(; kwargs...)\n    agent_data, _ = run!(model, agent_step!, model_step!, terminate; adata = [:new_opinion])\n    return agent_data\nend\n\ndata = model_run(numagents = 100)\ndata[(end - 19):end, :]","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Notice that here we didn't speciy when to collect data, so this is done at every step. Instead, we could collect data only at the final step, by re-using the same function for the when argument:","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"model = hk_model()\nagent_data, _ = run!(\n    model,\n    agent_step!,\n    model_step!,\n    terminate;\n    adata = [:new_opinion],\n    when = terminate,\n)\nagent_data","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"Finally we run three scenarios, collect the data and plot it.","category":"page"},{"location":"examples/hk/","page":"Hegselmann-Krause opinion dynamics","title":"Hegselmann-Krause opinion dynamics","text":"using Plots\nusing Random # hide\ngr() # hide\n\nplotsim(data, ϵ) = plot(\n    data.step,\n    data.new_opinion,\n    leg = false,\n    group = data.id,\n    title = \"epsilon = $(ϵ)\",\n)\n\nRandom.seed!(42) # hide\n\nplt001, plt015, plt03 =\n    map(e -> (model_run(ϵ = e), e) |> t -> plotsim(t[1], t[2]), [0.05, 0.15, 0.3])\n\nplot(plt001, plt015, plt03, layout = (3, 1))","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/growing_bacteria.jl\"","category":"page"},{"location":"examples/growing_bacteria/#Bacterial-Growth","page":"Bacteria Growth","title":"Bacterial Growth","text":"","category":"section"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"(Image: )","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"Bacterial colonies are a prime example for growing active matter, where systems are driven out of equilibrium by proliferation. This model is a simplified version of unpublished work by Yoav G. Pollack and Philip Bittihn; similar models can be found in literature. Here, a bacterium is modelled by two soft disk \"nodes\" linked by a spring, whose rest length grows with a constant growth rate. When it has reached its full extension, the cell divides into two daughter cells with the same orientation.","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"This example is a showcase of a complex continuous system. Agents will be splitting into more agents, thus having agent generation in continuous space. The model also uses advanced agent movement in continuous space, where a specialized \"move_agent\" function is created. Advanced plotting is also done, since each agent is a specialized shape. It is also available from the Models module as Models.growing_bacteria.","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"using Agents, LinearAlgebra\n\nmutable struct SimpleCell <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Float64}\n    length::Float64\n    orientation::Float64\n    growthprog::Float64\n    growthrate::Float64\n\n    # node positions/forces\n    p1::NTuple{2,Float64}\n    p2::NTuple{2,Float64}\n    f1::NTuple{2,Float64}\n    f2::NTuple{2,Float64}\nend\n\nfunction SimpleCell(id, pos, l, φ, g, γ)\n    a = SimpleCell(id, pos, l, φ, g, γ, (0.0, 0.0), (0.0, 0.0), (0.0, 0.0), (0.0, 0.0))\n    update_nodes!(a)\n    return a\nend","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"In this model, the agents have to store their state in two redundant ways: the cell coordinates (position, length, orientation) are required for the equations of motion, while the positions of the disk-shaped nodes are necessary for calculating mechanical forces between cells. To transform from one set of coordinates to the other, we need to write a function","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"function update_nodes!(a::SimpleCell)\n    offset = 0.5 * a.length .* unitvector(a.orientation)\n    a.p1 = a.pos .+ offset\n    a.p2 = a.pos .- offset\nend\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"Some geometry convenience functions","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"unitvector(φ) = reverse(sincos(φ))\ncross2D(a, b) = a[1] * b[2] - a[2] * b[1]\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/#Stepping-functions","page":"Bacteria Growth","title":"Stepping functions","text":"","category":"section"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"function model_step!(model)\n    for a in allagents(model)\n        if a.growthprog ≥ 1\n            # When a cell has matured, it divides into two daughter cells on the\n            # positions of its nodes.\n            add_agent!(a.p1, model, 0.0, a.orientation, 0.0, 0.1 * rand() + 0.05)\n            add_agent!(a.p2, model, 0.0, a.orientation, 0.0, 0.1 * rand() + 0.05)\n            kill_agent!(a, model)\n        else\n            # The rest lengh of the internal spring grows with time. This causes\n            # the nodes to physically separate.\n            uv = unitvector(a.orientation)\n            internalforce = model.hardness * (a.length - a.growthprog) .* uv\n            a.f1 = -1 .* internalforce\n            a.f2 = internalforce\n        end\n    end\n    # Bacteria can interact with more than on other cell at the same time, therefore,\n    # we need to specify the option `:all` in `interacting_pairs`\n    for (a1, a2) in interacting_pairs(model, 2.0, :all)\n        interact!(a1, a2, model)\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"Here we use a custom move_agent! function, because the agents have several moving parts. Notice that the first derivatives of all degrees of freedom is directly proportional to the force applied to them. This overdamped approximation is valid for small length scales, where viscous forces dominate over inertia.","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"function agent_step!(agent::SimpleCell, model::ABM)\n    fsym, compression, torque = transform_forces(agent)\n    agent.pos = agent.pos .+ model.dt * model.mobility .* fsym\n    agent.length += model.dt * model.mobility .* compression\n    agent.orientation += model.dt * model.mobility .* torque\n    agent.growthprog += model.dt * agent.growthrate\n    update_nodes!(agent)\n    update_space!(model, agent)\n    return agent.pos\nend\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/#Helper-functions","page":"Bacteria Growth","title":"Helper functions","text":"","category":"section"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"function interact!(a1::SimpleCell, a2::SimpleCell, model)\n    n11 = noderepulsion(a1.p1, a2.p1, model)\n    n12 = noderepulsion(a1.p1, a2.p2, model)\n    n21 = noderepulsion(a1.p2, a2.p1, model)\n    n22 = noderepulsion(a1.p2, a2.p2, model)\n    a1.f1 = @. a1.f1 + (n11 + n12)\n    a1.f2 = @. a1.f2 + (n21 + n22)\n    a2.f1 = @. a2.f1 - (n11 + n21)\n    a2.f2 = @. a2.f2 - (n12 + n22)\nend\n\nfunction noderepulsion(p1::NTuple{2,Float64}, p2::NTuple{2,Float64}, model::ABM)\n    delta = p1 .- p2\n    distance = norm(delta)\n    if distance ≤ 1\n        uv = delta ./ distance\n        return (model.hardness * (1 - distance)) .* uv\n    end\n    return (0, 0)\nend\n\nfunction transform_forces(agent::SimpleCell)\n    # symmetric forces (CM movement)\n    fsym = agent.f1 .+ agent.f2\n    # antisymmetric forces (compression, torque)\n    fasym = agent.f1 .- agent.f2\n    uv = unitvector(agent.orientation)\n    compression = dot(uv, fasym)\n    torque = 0.5 * cross2D(uv, fasym)\n    return fsym, compression, torque\nend\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/#Animating-bacterial-growth","page":"Bacteria Growth","title":"Animating bacterial growth","text":"","category":"section"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"Okay, we can now initialize a model and see what it does.","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"space = ContinuousSpace(2, extend = (12, 12), periodic = false, metric = :euclidean)\nmodel = ABM(\n    SimpleCell,\n    space,\n    properties = Dict(:dt => 0.005, :hardness => 1e2, :mobility => 1.0),\n)","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"Let's start with just two agents.","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"add_agent!((5.0, 5.0), model, 0.0, 0.3, 0.0, 0.1)\nadd_agent!((6.0, 5.0), model, 0.0, 0.0, 0.0, 0.1)\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"The model has several parameters, and some of them are of interest. We could e.g. define","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"adata = [:pos, :length, :orientation, :growthprog, :p1, :p2, :f1, :f2]\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"and then run! the model. But we'll animate the model directly.","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"Here we once again use the huge flexibility provided by plotabm to plot the becteria cells. We define a function that creates a custom Shape based on the agent:","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"using AgentsPlots\ngr() # hide\n\nfunction cassini_oval(agent)\n    t = LinRange(0, 2π, 50)\n    a = agent.growthprog\n    b = 1\n    m = @. 2 * sqrt((b^4 - a^4) + a^4 * cos(2 * t)^2) + 2 * a^2 * cos(2 * t)\n    C = sqrt.(m / 2)\n\n    x = C .* cos.(t)\n    y = C .* sin.(t)\n\n    uv = reverse(sincos(agent.orientation))\n    θ = atan(uv[2], uv[1])\n    R = [cos(θ) -sin(θ); sin(θ) cos(θ)]\n\n    bacteria = R * permutedims([x y])\n    Shape(bacteria[1, :], bacteria[2, :])\nend\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"set up some nice colors","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"bacteria_colors(agent) =\n    HSV.(agent.id * 2.718 .% 1, agent.id * 3.14 .% 1, agent.id * 1.618 .% 1)\nnothing # hide","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"and proceed with the animation","category":"page"},{"location":"examples/growing_bacteria/","page":"Bacteria Growth","title":"Bacteria Growth","text":"e = model.space.extend\nanim = @animate for i in 0:50:5000\n    step!(model, agent_step!, model_step!, 100)\n    p1 = plotabm(\n        model,\n        am = cassini_oval,\n        as = 30,\n        ac = bacteria_colors,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n    title!(p1, \"n = $(i)\")\nend\n\ngif(anim, \"bacteria.gif\", fps = 25)","category":"page"},{"location":"mesa/#Agents.jl-vs-Mesa:-speed-comparison","page":"Comparison against Mesa (Python)","title":"Agents.jl vs Mesa: speed comparison","text":"","category":"section"},{"location":"mesa/","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Julia code can run much faster than Python. And since Agents.jl is a minimal  framework, an agent-based model written in Julia and using Agents.jl can be  much faster than the same algorithm written in Python and using the Mesa  package. Furthermore, Agents.jl has a considerably simpler API which reduces  the learning curve. Mesa, on the other hand, is much stronger in visualizing  the simulations.","category":"page"},{"location":"mesa/","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Here is a benchmark of two models, forest fire and boid flocking, implemented in Agents.jl and Mesa  (code is available in test/benchmark/mesa folder on Agents.jl's Github page). We took the Python implementations from Mesa's Github page. The Julia implementations follow the same logic as the Python implementations. We tested a range of grid sizes and population sizes for the forest fire the boid flocking models, respectively, hence the multiple points.","category":"page"},{"location":"mesa/","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"Figure below shows the ratio of the time it takes to run the models in Mesa over the time it takes to run them in Agents.jl. The model implemented in  Agents.jl is up to more than 14 times faster than the model implemented in Mesa for the forest fire model and about 9 times faster for the boid flocking.","category":"page"},{"location":"mesa/","page":"Comparison against Mesa (Python)","title":"Comparison against Mesa (Python)","text":"(Image: Speed comparison of a version of \"forest fire\" and \"boid flocking\" models in Agents.jl vs Mesa.)","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/diffeq.jl\"","category":"page"},{"location":"examples/diffeq/#Integrating-Agents.jl-with-DifferentialEquations.jl","page":"DifferentialEquations.jl","title":"Integrating Agents.jl with DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Leveraging other best-in-class packages from the Julia ecosystem is one of the many strengths Agents.jl provides over alternative ABMs.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The DifferentialEquations.jl package is one excellent example. Here, we provide a few ways of leveraging DifferentialEquations to solve agent based models in an efficient and performant manner, whilst mitigating stability issues one may encounter.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"It is common in discrete time step tools (such as Agents) to also discretise equations required for obtaining solutions. In the following example, we use the forward Euler method to discretise a logistic function","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"fracmathrmdsmathrmdt = s left(1-fracs120right) - h","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"into","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"s_t+1 = s_t + s_t (1-s_t120)-h","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"In this example, s denotes some fish stock that increases over time until a maximum population (e.g. 120 here) is met, with the additional property that a harvest (h) may also remove some population (we also assume a timestep of 1 normalised unit to simplify things).","category":"page"},{"location":"examples/diffeq/#Problem-setup","page":"DifferentialEquations.jl","title":"Problem setup","text":"","category":"section"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Let's build a fishing community with fishers, each with differing methods and experience, culminating in a variety of competence when it comes to actually catching fish.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"using Agents\nusing Distributions\nusing Plots\ngr() #hide\nusing Random #hide\n\nmutable struct Fisher <: AbstractAgent\n    id::Int\n    competence::Int\n    yearly_catch::Float64\nend\n\nfunction agent_step!(agent, model)\n    # Make sure we sample from the fish distribution\n    agent.yearly_catch = rand(Poisson(agent.competence))\nend\n\nfunction dstock(model)\n    # Only allow fishing if stocks are high enough\n    h = model.stock > model.min_threshold ? sum(a.yearly_catch for a in allagents(model)) :\n        0.0\n\n    model.stock * (1 - (model.stock / model.max_population)) - h\nend\n\nfunction model_step!(model)\n    model.stock += dstock(model)\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"These methods should be quite straightforward: each step of the model (agent_step!), every agent will catch some fish based on their competency. There are some safeguards in place to not allow fishers to totally deplete the stock, thus dstock checks the total yearly catch and only harvests if the population is above a minimal threshold (in a more complete example, one should set a flag to state that this year's catch exceeded the limit and regulate fishing next year, but we'll ignore this complexity for this example).","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Building this model is simple. Set some initial conditions for the stock, and add agents with some competence.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"function initialise(;\n    stock = 5.0, # Initial population of fish\n    max_population = 500.0, # Maximum value of fish stock\n    min_threshold = 60.0, # Regulate fishing if population drops below this value\n    nagents = 50,\n)\n    model = ABM(\n        Fisher;\n        properties = Dict(\n            :stock => stock,\n            :max_population => max_population,\n            :min_threshold => min_threshold,\n        ),\n    )\n    for _ in 1:nagents\n        add_agent!(\n            model,\n            # Competence level is a lognormal distribution between 1 and 5\n            floor(rand(truncated(LogNormal(), 1, 6))),\n            # Yearly catch can start at 0\n            0.0,\n        )\n    end\n    model\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"We can now run the model and see how the fishery fairs over the next 20 years.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\n\nmodel = initialise()\n_, results = run!(model, agent_step!, model_step!, 20; mdata = [:stock])\n\nplot(results.stock; legend = false, ylabel = \"Stock\", xlabel = \"Year\")","category":"page"},{"location":"examples/diffeq/#Add-in-some-bureaucracy","page":"DifferentialEquations.jl","title":"Add in some bureaucracy","text":"","category":"section"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"OK, so let's add in some annoyances for the fishers. Of course, they wish to go out and catch regularly, but regulators only want to do their job once a year! Since it's the regulators who will monitor the total stock condition and advise fishers as to whether or not they can continue fishing, a systematic blind spot is inadvertently introduced into the system. Yearly catch and regulation occur on one day a year, whilst the stock will of course grow on a daily basis.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"To achieve this, we extend the model like so:","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"function agent_step!(agent, model)\n    if model.tick % 365 == 0\n        agent.yearly_catch = rand(Poisson(agent.competence))\n    end\nend\n\nfunction dstock(model)\n    # Only allow fishing if stocks are high enough\n    # (monitored yearly, so this will return 0 364 days of the year)\n    h = model.tick % 365 == 0 && model.stock > model.min_threshold ?\n        sum(a.yearly_catch for a in allagents(model)) : 0.0\n\n    model.stock * (1 - (model.stock / model.max_population)) - h\nend\n\nfunction model_step!(model)\n    model.tick += 1\n    model.stock += dstock(model)\nend\n\nfunction initialise(;\n    stock = 400.0, # Initial population of fish (lets move to an equilibrium position)\n    max_population = 500.0, # Maximum value of fish stock\n    min_threshold = 60.0, # Regulate fishing if population drops below this value\n    nagents = 50,\n)\n    model = ABM(\n        Fisher;\n        properties = Dict(\n            :stock => stock,\n            :max_population => max_population,\n            :min_threshold => min_threshold,\n            :tick => 0, # Time keeper in units of days\n        ),\n    )\n    for _ in 1:nagents\n        add_agent!(model, floor(rand(truncated(LogNormal(), 1, 6))), 0.0)\n    end\n    model\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Now that our model is running with a daily timestep, we must extend the run length value, and we'll also start from a steady state population.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\nmodel = initialise()\nyearly(model, s) = s % 365 == 0\n_, results =\n    run!(model, agent_step!, model_step!, 20 * 365; mdata = [:stock], when = yearly)\n\nplot(results.stock; legend = false, ylabel = \"Stock\", xlabel = \"Year\")","category":"page"},{"location":"examples/diffeq/#Baseline-benchmark","page":"DifferentialEquations.jl","title":"Baseline benchmark","text":"","category":"section"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Lets get a baseline performance result for our model.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"using BenchmarkTools\n\nRandom.seed!(6549) #hide\n@btime Agents.step!(model, agent_step!, model_step!, 20 * 365) setup =\n    (model = initialise())","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"So this is fairly quick since the model is a simple one, but it's certainly not as efficient as it could be. We calculate the stock value every single day, since the forward Eulerian method requires us to, so it can evolve correctly. In addition to this, Eulerian expansion introduces uncertainty into our results, which is tied to the choice of step size. For accurate results, one should never really use this approximate method - although it is almost ubiquitous throughout contemporary research code. For a thorough exposé on this, have a read of Why you shouldn't use Eulers method to solve ODEs.","category":"page"},{"location":"examples/diffeq/#Coupling-DifferentialEquations.jl-to-Agents.jl","page":"DifferentialEquations.jl","title":"Coupling DifferentialEquations.jl to Agents.jl","text":"","category":"section"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Lets therefore modify our system to solve the logistic equation in a continuous context, but discretely monitor and harvest.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"import OrdinaryDiffEq\n\nfunction agent_diffeq_step!(agent, model)\n    agent.yearly_catch = rand(Poisson(agent.competence))\nend\n\nfunction model_diffeq_step!(model)\n    # We step 364 days with this call.\n    OrdinaryDiffEq.step!(model.i, 364.0, true)\n    # Only allow fishing if stocks are high enough\n    model.i.p[2] =\n        model.i.u[1] > model.min_threshold ? sum(a.yearly_catch for a in allagents(model)) :\n        0.0\n    # Notify the integrator that conditions may be altered\n    OrdinaryDiffEq.u_modified!(model.i, true)\n    # Then apply our catch modifier\n    OrdinaryDiffEq.step!(model.i, 1.0, true)\n    # Store yearly stock in the model for plotting\n    model.stock = model.i.u[1]\n    # And reset for the next year\n    model.i.p[2] = 0.0\n    OrdinaryDiffEq.u_modified!(model.i, true)\nend\n\nfunction initialise_diffeq(;\n    stock = 400.0, # Initial population of fish (lets move to an equilibrium position)\n    max_population = 500.0, # Maximum value of fish stock\n    min_threshold = 60.0, # Regulate fishing if population drops below this value\n    nagents = 50,\n)\n\n    function fish_stock!(ds, s, p, t)\n        max_population, h = p\n        ds[1] = s[1] * (1 - (s[1] / max_population)) - h\n    end\n    prob =\n        OrdinaryDiffEq.ODEProblem(fish_stock!, [stock], (0.0, Inf), [max_population, 0.0])\n    integrator = OrdinaryDiffEq.init(prob, OrdinaryDiffEq.Tsit5(); advance_to_tstop = true)\n\n    model = ABM(\n        Fisher;\n        properties = Dict(\n            :stock => stock,\n            :max_population => max_population,\n            :min_threshold => min_threshold,\n            :i => integrator, # The OrdinaryDiffEq integrator\n        ),\n    )\n    for _ in 1:nagents\n        add_agent!(model, floor(rand(truncated(LogNormal(), 1, 6))), 0.0)\n    end\n    model\nend\nnothing #hide","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Notice that we've reverted back to a yearly rather than daily timestep here, since the ODE solver is now in charge of evolving the logistic function forward. We've used the integrator interface to achieve this.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Note that we use OrdinaryDiffEq here, which is a component of DifferentialEquations. Users may switch this to any subcomponent of the DifferentialEquations ecosystem, or use DifferentialEquations directly. Since we don't need other components for this example, we'll stick with the subcomponent but speak in general terms since the packages are interchangable in this context.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"This implementation uses import to explicitly identify which functions are from DifferentialEquations and not Agents. However, since both Agents and DifferentialEquations provide a step! function, each use must be qualified explicitly if one were to choose to bring all of DifferentialEquations into scope via the using keyword.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\nmodeldeq = initialise_diffeq()\n_, resultsdeq = run!(modeldeq, agent_diffeq_step!, model_diffeq_step!, 20; mdata = [:stock])\n\nplot(resultsdeq.stock; legend = false, ylabel = \"Stock\", xlabel = \"Year\")","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The small complexity addition yields us a generous speed up of around 6x.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Random.seed!(6549) #hide\n@btime Agents.step!(model, agent_diffeq_step!, model_diffeq_step!, 20) setup =\n    (model = initialise_diffeq())","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Digging into the results a little more, we can see that the DifferentialEquations solver did not need to solve the logistic equation at every agent step to achieve a stable solution for us:","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"length(modeldeq.i.sol.t)","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"365 * 20 > length(modeldeq.i.sol.t)","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"With other initial conditions, there's the possibility that this may not be the case. When this occurs, these additional samples provide mathematical guarantees that the results are accurate (to a given tolerance), which is a safeguard not possible for our Euler example.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Compare our two results directly, both start with the same random seed and evolve in precisely the same manner:","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"plot(results.stock, label = \"Euler\", ylabel = \"Stock\", xlabel = \"Year\")\nplot!(resultsdeq.stock, label = \"TSit5\")","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"That's an average discrepancy of 30 fish! Optimising the step size in the Euler method can close this gap, but this is yet more analysis overhead we'd prefer to avoid by using better solutions.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"In addition, the ODE solver will be faster most of the time, regardless of how many steps it needs to take. If not, there are other, more effective solvers that can be used for your particular case.","category":"page"},{"location":"examples/diffeq/#Coupling-Agents.jl-to-DifferentialEquations.jl","page":"DifferentialEquations.jl","title":"Coupling Agents.jl to DifferentialEquations.jl","text":"","category":"section"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"Perhaps you're more familiar to the DifferentialEquations solve interface and you're new to Agents?","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"We can also couple the two systems the other way. Let's use callbacks to handle the agent based aspects of our problem.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"function agent_cb_step!(agent, model)\n    agent.yearly_catch = rand(Poisson(agent.competence))\nend\n\nfunction initialise_cb(; min_threshold = 60.0, nagents = 50)\n    model = ABM(Fisher; properties = Dict(:min_threshold => min_threshold))\n\n    for _ in 1:nagents\n        add_agent!(model, floor(rand(truncated(LogNormal(), 1, 6))), 0.0)\n    end\n    model\nend\n\nRandom.seed!(759) #hide\nmodelcb = initialise_cb()","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"That's it for the Agents side of things! Now to build the ODE.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"import DiffEqCallbacks\n\nfunction fish!(integrator, model)\n    integrator.p[2] = integrator.u[1] > model.min_threshold ?\n        sum(a.yearly_catch for a in allagents(model)) : 0.0\n    Agents.step!(model, agent_cb_step!, 1)\nend\n\nfunction fish_stock!(ds, s, p, t)\n    max_population, h = p\n    ds[1] = s[1] * (1 - (s[1] / max_population)) - h\nend\n\ntspan = (0.0, 20.0 * 365.0)\nconst initial_stock = 400.0\nconst max_population = 500.0\n\nprob = OrdinaryDiffEq.ODEProblem(fish_stock!, [initial_stock], tspan, [max_population, 0.0])\n\n# Each Dec 31st, we call fish! that adds our catch modifier to the stock, and steps the model\nfish = DiffEqCallbacks.PeriodicCallback(i -> fish!(i, modelcb), 364)\n# Stocks are replenished again\nreset = DiffEqCallbacks.PeriodicCallback(i -> i.p[2] = 0.0, 365)\n\nsol = OrdinaryDiffEq.solve(\n    prob,\n    OrdinaryDiffEq.Tsit5();\n    callback = OrdinaryDiffEq.CallbackSet(fish, reset),\n)\n\nplot(\n    sol(0:365:(365 * 20)),\n    xticks = (0:(365 * 2):(365 * 20), 0:2:20),\n    legend = false,\n    ylabel = \"Stock\",\n    xlabel = \"Year\",\n)","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"The results are different here, since the construction of this version and the one above are quite different and cannot be randomly seeded in the same manner.","category":"page"},{"location":"examples/diffeq/","page":"DifferentialEquations.jl","title":"DifferentialEquations.jl","text":"However, as you can see, it is for the most part just a re-arranged implementation of the integrator method - giving users flexibility in their architecture choices.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/sir.jl\"","category":"page"},{"location":"examples/sir/#SIR-model-for-the-spread-of-COVID-19","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"(Image: ) This example illustrates how to use GraphSpace and how to model agents on an graph (network) where the transition probabilities between each node is not constant.","category":"page"},{"location":"examples/sir/#SIR-model","page":"SIR model for the spread of COVID-19","title":"SIR model","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"A SIR model tracks the ratio of Susceptible, Infected, and Recovered individuals within a population. Here we add one more category of individuals: those who are infected, but do not know it. Transmission rate for infected and diagnosed individuals is lower than infected and undetected. We also allow a fraction of recovered individuals to catch the disease again, meaning that recovering the disease does not bring full immunity.","category":"page"},{"location":"examples/sir/#Model-parameters","page":"SIR model for the spread of COVID-19","title":"Model parameters","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Here are the model parameters, some of which have default values.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Ns: a vector of population sizes per city. The amount of cities is just C=length(Ns).\nβ_und: a vector for transmission probabilities β of the infected but undetected per city. Transmission probability is how many susceptible are infected per day by an infected individual. If social distancing is practiced, this number increases.\nβ_det: an array for transmission probabilities β of the infected and detected per city. If hospitals are full, this number increases.\ninfection_period = 30: how many days before a person dies or recovers.\ndetection_time = 14: how many days before an infected person is detected.\ndeath_rate = 0.02: the probability that the individual will die after the infection_period.\nreinfection_probability = 0.05: The probability that a recovered person can get infected again.\nmigration_rates: A matrix of migration probability per individual per day from one city to another.\nIs = [zeros(C-1)..., 1]: An array for initial number of infected but undetected people per city. This starts as only one infected individual in the last city.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Notice that Ns, β, Is all need to have the same length, as they are numbers for each city. We've tried to add values to the infection parameters similar to the ones you would hear on the news about COVID-19.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The good thing with Agent based models is that you could easily extend the model we implement here to also include age as an additional property of each agent. This makes ABMs flexible and suitable for research of virus spreading.","category":"page"},{"location":"examples/sir/#Making-the-model-in-Agents.jl","page":"SIR model for the spread of COVID-19","title":"Making the model in Agents.jl","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We start by defining the PoorSoul agent type and the ABM","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using Agents, Random, DataFrames, LightGraphs\nusing Distributions: Poisson, DiscreteNonParametric\nusing DrWatson: @dict\nusing Plots\ngr() # hide\n\nmutable struct PoorSoul <: AbstractAgent\n    id::Int\n    pos::Int\n    days_infected::Int  # number of days since is infected\n    status::Symbol  # 1: S, 2: I, 3:R\nend\n\nfunction model_initiation(;\n    Ns,\n    migration_rates,\n    β_und,\n    β_det,\n    infection_period = 30,\n    reinfection_probability = 0.05,\n    detection_time = 14,\n    death_rate = 0.02,\n    Is = [zeros(Int, length(Ns) - 1)..., 1],\n    seed = 0,\n)\n\n    Random.seed!(seed)\n    @assert length(Ns) ==\n    length(Is) ==\n    length(β_und) ==\n    length(β_det) ==\n    size(migration_rates, 1) \"length of Ns, Is, and B, and number of rows/columns in migration_rates should be the same \"\n    @assert size(migration_rates, 1) == size(migration_rates, 2) \"migration_rates rates should be a square matrix\"\n\n    C = length(Ns)\n    # normalize migration_rates\n    migration_rates_sum = sum(migration_rates, dims = 2)\n    for c in 1:C\n        migration_rates[c, :] ./= migration_rates_sum[c]\n    end\n\n    properties = @dict(\n        Ns,\n        Is,\n        β_und,\n        β_det,\n        β_det,\n        migration_rates,\n        infection_period,\n        infection_period,\n        reinfection_probability,\n        detection_time,\n        C,\n        death_rate\n    )\n    space = GraphSpace(complete_digraph(C))\n    model = ABM(PoorSoul, space; properties = properties)\n\n    # Add initial individuals\n    for city in 1:C, n in 1:Ns[city]\n        ind = add_agent!(city, model, 0, :S) # Susceptible\n    end\n    # add infected individuals\n    for city in 1:C\n        inds = get_node_contents(city, model)\n        for n in 1:Is[city]\n            agent = model[inds[n]]\n            agent.status = :I # Infected\n            agent.days_infected = 1\n        end\n    end\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We will make a function that starts a model with C number of cities, and creates the other parameters automatically by attributing some random values to them. You could directly use the above constructor and specify all Ns, β, etc. for a given set of cities.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"All cities are connected with each other, while it is more probable to travel from a city with small population into a city with large population.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using LinearAlgebra: diagind\n\nfunction create_params(;\n    C,\n    max_travel_rate,\n    infection_period = 30,\n    reinfection_probability = 0.05,\n    detection_time = 14,\n    death_rate = 0.02,\n    Is = [zeros(Int, C - 1)..., 1],\n    seed = 19,\n)\n\n    Random.seed!(seed)\n    Ns = rand(50:5000, C)\n    β_und = rand(0.3:0.02:0.6, C)\n    β_det = β_und ./ 10\n\n    Random.seed!(seed)\n    migration_rates = zeros(C, C)\n    for c in 1:C\n        for c2 in 1:C\n            migration_rates[c, c2] = (Ns[c] + Ns[c2]) / Ns[c]\n        end\n    end\n    maxM = maximum(migration_rates)\n    migration_rates = (migration_rates .* max_travel_rate) ./ maxM\n    migration_rates[diagind(migration_rates)] .= 1.0\n\n    params = @dict(\n        Ns,\n        β_und,\n        β_det,\n        migration_rates,\n        infection_period,\n        reinfection_probability,\n        detection_time,\n        death_rate,\n        Is\n    )\n\n    return params\nend\n\nparams = create_params(C = 8, max_travel_rate = 0.01)\nmodel = model_initiation(; params...)","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Alright, let's plot the cities as a graph to get an idea how the model \"looks like\", using the function plotabm.","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"using AgentsPlots\n\nplotargs = (node_size = 0.2, method = :circular, linealpha = 0.4)\n\nplotabm(model; plotargs...)","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The node size is proportional to the relative population of each city. In principle we could adjust the edge widths to be proportional with the migration rates, by doing:","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"g = model.space.graph\nedgewidthsdict = Dict()\nfor node in 1:nv(g)\n    nbs = neighbors(g, node)\n    for nb in nbs\n        edgewidthsdict[(node, nb)] = params[:migration_rates][node, nb]\n    end\nend\n\nedgewidthsf(s, d, w) = edgewidthsdict[(s, d)] * 250\n\nplotargs = merge(plotargs, (edgewidth = edgewidthsf,))\n\nplotabm(model; plotargs...)","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"In the following we will be coloring each node according to how large percentage of the population is infected. So we create a function to give to plotabm as a second argument","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"infected_fraction(x) = cgrad(:inferno)[count(a.status == :I for a in x) / length(x)]\nplotabm(model; ac = infected_fraction, plotargs...)","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Here this shows all nodes as black, since we haven't run the model yet. Let's change that!","category":"page"},{"location":"examples/sir/#SIR-Stepping-functions","page":"SIR model for the spread of COVID-19","title":"SIR Stepping functions","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"Now we define the functions for modelling the virus spread in time","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"function agent_step!(agent, model)\n    migrate!(agent, model)\n    transmit!(agent, model)\n    update!(agent, model)\n    recover_or_die!(agent, model)\nend\n\nfunction migrate!(agent, model)\n    nodeid = agent.pos\n    d = DiscreteNonParametric(1:(model.C), model.migration_rates[nodeid, :])\n    m = rand(d)\n    if m ≠ nodeid\n        move_agent!(agent, m, model)\n    end\nend\n\nfunction transmit!(agent, model)\n    agent.status == :S && return\n    rate = if agent.days_infected < model.detection_time\n        model.β_und[agent.pos]\n    else\n        model.β_det[agent.pos]\n    end\n\n    d = Poisson(rate)\n    n = rand(d)\n    n == 0 && return\n\n    for contactID in get_node_contents(agent, model)\n        contact = model[contactID]\n        if contact.status == :S ||\n           (contact.status == :R && rand() ≤ model.reinfection_probability)\n            contact.status = :I\n            n -= 1\n            n == 0 && return\n        end\n    end\nend\n\nupdate!(agent, model) = agent.status == :I && (agent.days_infected += 1)\n\nfunction recover_or_die!(agent, model)\n    if agent.days_infected ≥ model.infection_period\n        if rand() ≤ model.death_rate\n            kill_agent!(agent, model)\n        else\n            agent.status = :R\n            agent.days_infected = 0\n        end\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/sir/#Example-animation","page":"SIR model for the spread of COVID-19","title":"Example animation","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"model = model_initiation(; params...)\n\nanim = @animate for i in 0:30\n    i > 0 && step!(model, agent_step!, 1)\n    p1 = plotabm(model; ac = infected_fraction, plotargs...)\n    title!(p1, \"Day $(i)\")\nend\n\ngif(anim, \"covid_evolution.gif\", fps = 5)","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"One can really see \"explosive growth\" in this animation. Things look quite calm for a while and then suddenly supermarkets have no toilet paper anymore!","category":"page"},{"location":"examples/sir/#Exponential-growth","page":"SIR model for the spread of COVID-19","title":"Exponential growth","text":"","category":"section"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We now run the model and collect data. We define two useful functions for data collection:","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)\nnothing # hide","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"and then collect data","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"model = model_initiation(; params...)\n\nto_collect = [(:status, f) for f in (infected, recovered, length)]\ndata, _ = run!(model, agent_step!, 100; adata = to_collect)\ndata[1:10, :]","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"We now plot how quantities evolved in time to show the exponential growth of the virus","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"N = sum(model.Ns) # Total initial population\nx = data.step\np = plot(\n    x,\n    log10.(data[:, aggname(:status, infected)]),\n    label = \"infected\",\n    xlabel = \"steps\",\n    ylabel = \"log(count)\",\n)\nplot!(p, x, log10.(data[:, aggname(:status, recovered)]), label = \"recovered\")\ndead = log10.(N .- data[:, aggname(:status, length)])\nplot!(p, x, dead, label = \"dead\")","category":"page"},{"location":"examples/sir/","page":"SIR model for the spread of COVID-19","title":"SIR model for the spread of COVID-19","text":"The exponential growth is clearly visible since the logarithm of the number of infected increases linearly, until everyone is infected.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/game_of_life_2D_CA.jl\"","category":"page"},{"location":"examples/game_of_life_2D_CA/#Conway's-game-of-life","page":"Conway's game of life","title":"Conway's game of life","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"(Image: )","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"Game of life on wikipedia.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"It is also available from the Models module as Models.game_of_life.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"using Agents, AgentsPlots\nusing Random # hide\ngr(); # hide\nnothing # hide","category":"page"},{"location":"examples/game_of_life_2D_CA/#.-Define-the-rules","page":"Conway's game of life","title":"1. Define the rules","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"Rules of Conway's game of life: DSRO (Death, Survival, Reproduction, Overpopulation). Cells die if the number of their living neighbors is <D or >O, survive if the number of their living neighbors is ≤S, come to life if their living neighbors are  ≥R and ≤O.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"rules = (2, 3, 3, 3)\nnothing # hide","category":"page"},{"location":"examples/game_of_life_2D_CA/#.-Build-the-model","page":"Conway's game of life","title":"2. Build the model","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"First, define an agent type. It needs to have the compulsary id and pos fields, as well as an status field that is true for cells that are alive and false otherwise.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"mutable struct Cell <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    status::Bool\nend","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"The following function builds a 2D cellular automaton. rules is of type Tuple{Int,Int,Int, Int} representing DSRO.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"dims is a tuple of integers determining the width and height of the grid environment. Moore specifies whether cells connect to their diagonal neighbors.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"This function creates a model where all cells are \"off\".","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"function build_model(; rules::Tuple, dims = (100, 100), Moore = true)\n    space = GridSpace(dims, moore = Moore)\n    properties = Dict(:rules => rules)\n    model = ABM(Cell, space; properties = properties)\n    node_idx = 1\n    for x in 1:dims[1]\n        for y in 1:dims[2]\n            add_agent_pos!(Cell(node_idx, (x, y), false), model)\n            node_idx += 1\n        end\n    end\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"Now we define a stepping function for the model to apply the rules to agents.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"function ca_step!(model)\n    new_status = fill(false, nagents(model))\n    for (agid, ag) in model.agents\n        nlive = nlive_neighbors(ag, model)\n        if ag.status == true && (nlive ≤ model.rules[4] && nlive ≥ model.rules[1])\n            new_status[agid] = true\n        elseif ag.status == false && (nlive ≥ model.rules[3] && nlive ≤ model.rules[4])\n            new_status[agid] = true\n        end\n    end\n\n    for k in keys(model.agents)\n        model.agents[k].status = new_status[k]\n    end\nend\n\nfunction nlive_neighbors(ag, model)\n    neighbors_coords = node_neighbors(ag, model)\n    nlive = 0\n    for nc in neighbors_coords\n        nag = model.agents[Agents.coord2vertex((nc[2], nc[1]), model)]\n        if nag.status == true\n            nlive += 1\n        end\n    end\n    return nlive\nend\nnothing # hide","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"now we can instantiate the model:","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"Random.seed!(120) # hide\nmodel = build_model(rules = rules, dims = (50, 50), Moore = true)","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"Let's make some random cells on","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"for i in 1:nv(model)\n    if rand() < 0.2\n        model.agents[i].status = true\n    end\nend","category":"page"},{"location":"examples/game_of_life_2D_CA/#.-Animate-the-model","page":"Conway's game of life","title":"3. Animate the model","text":"","category":"section"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"We use the plotabm function from AgentsPlots.jl package for creating an animation.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"ac(x) = x.status == true ? :black : :white\nanim = @animate for i in 0:100\n    i > 0 && step!(model, dummystep, ca_step!, 1)\n    p1 = plotabm(model; ac = ac, as = 3, am = :square, showaxis = false)\nend\nnothing # hide","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"We can now save the animation to a gif.","category":"page"},{"location":"examples/game_of_life_2D_CA/","page":"Conway's game of life","title":"Conway's game of life","text":"gif(anim, \"game_of_life.gif\", fps = 5)","category":"page"},{"location":"models/#Predefined-Models","page":"Predefined Models","title":"Predefined Models","text":"","category":"section"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"Predefined agent based models exist in the Models submodule in the form of functions that return model, agent_step!, model_step! when called.","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"They are accessed like:","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"using Agents\nmodel, agent_step!, model_step! = Models.flocking(; kwargs...)","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"The Examples section of the docs outline how to use and interact with each model.","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"So far, the predefined models that exist in the Models sub-module are:","category":"page"},{"location":"models/","page":"Predefined Models","title":"Predefined Models","text":"Modules = [Models]\nOrder   = [:function]","category":"page"},{"location":"models/#Agents.Models.daisyworld-Tuple{}","page":"Predefined Models","title":"Agents.Models.daisyworld","text":"daisyworld(; \n    griddims = (30, 30),\n    max_age = 25,\n    init_white = 0.2,\n    init_black = 0.2,\n    albedo_white = 0.75,\n    albedo_black = 0.25,\n    surface_albedo = 0.4,\n    solar_change = 0.005,\n    solar_luminosity = 1.0,\n    scenario = :default,\n    seed = 165\n)\n\nSame as in Daisyworld.\n\nTo access the Daisy and Land types, simply call\n\nusing Agents.Models: Daisy, Land\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.flocking-Tuple{}","page":"Predefined Models","title":"Agents.Models.flocking","text":"flocking(;\n    n_birds = 100,\n    speed = 1.0,\n    cohere_factor = 0.25,\n    separation = 4.0,\n    separate_factor = 0.25,\n    match_factor = 0.01,\n    visual_distance = 5.0,\n    dims = (100, 100),\n)\n\nSame as in Flock model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.forest_fire-Tuple{}","page":"Predefined Models","title":"Agents.Models.forest_fire","text":"forest_fire(; \n    f = 0.02, \n    d = 0.8, \n    p = 0.01, \n    griddims = (100, 100), \n    seed = 111\n)\n\nSame as in Forest fire model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.game_of_life-Tuple{}","page":"Predefined Models","title":"Agents.Models.game_of_life","text":"game_of_life(;\n    rules::Tuple = (2, 3, 3, 3),\n    dims = (100, 100),\n    Moore = true\n)\n\nSame as in Conway's game of life.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.growing_bacteria-Tuple{}","page":"Predefined Models","title":"Agents.Models.growing_bacteria","text":"growing_bacteria()\n\nSame as in Bacterial Growth.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.hk-Tuple{}","page":"Predefined Models","title":"Agents.Models.hk","text":"hk(; \n    numagents = 100, \n    ϵ = 0.2\n)\n\nSame as in HK (Hegselmann and Krause) opinion dynamics model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.opinion-Tuple{}","page":"Predefined Models","title":"Agents.Models.opinion","text":"opinion(;dims=(10, 10), nopinions=3, levels_per_opinion=4)\n\nSame as in Opinion spread.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.predator_prey-Tuple{}","page":"Predefined Models","title":"Agents.Models.predator_prey","text":"predator_prey(; \n    n_sheep = 100,\n    n_wolves = 50,\n    dims = (20, 20),\n    regrowth_time = 30,\n    Δenergy_sheep = 4,\n    Δenergy_wolf = 20,\n    sheep_reproduce = 0.04,\n    wolf_reproduce = 0.05,\n)\n\nSame as in Model of predator-prey dynamics.\n\nTo access the Sheep, Wolf and Grass types, simply call\n\nusing Agents.Models: Sheep, Wolf, Grass\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.schelling-Tuple{}","page":"Predefined Models","title":"Agents.Models.schelling","text":"schelling(; \n    numagents = 320, \n    griddims = (20, 20), \n    min_to_be_happy = 3\n)\n\nSame as in Schelling's segregation model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.social_distancing-Tuple{}","page":"Predefined Models","title":"Agents.Models.social_distancing","text":"social_distancing(;\n    infection_period = 30 * steps_per_day,\n    detection_time = 14 * steps_per_day,\n    reinfection_probability = 0.05,\n    isolated = 0.5, # in percentage\n    interaction_radius = 0.012,\n    dt = 1.0,\n    speed = 0.002,\n    death_rate = 0.044, # from website of WHO\n    N = 1000,\n    initial_infected = 5,\n    seed = 42,\n    βmin = 0.4,\n    βmax = 0.8,\n)\n\nSame as in Continuous space social distancing for COVID-19.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.wealth_distribution-Tuple{}","page":"Predefined Models","title":"Agents.Models.wealth_distribution","text":"wealth_distribution(; \n    dims = (25, 25),\n    wealth = 1,\n    M = 1000\n)\n\nSame as in Wealth distribution model.\n\n\n\n\n\n","category":"method"},{"location":"models/#Agents.Models.wright_fisher-Tuple{}","page":"Predefined Models","title":"Agents.Models.wright_fisher","text":"wright_fisher(; \n    numagents = 100,\n    selection = true\n)\n\nSame as in Wright-Fisher model of evolution.\n\n\n\n\n\n","category":"method"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/schelling.jl\"","category":"page"},{"location":"examples/schelling/#Schelling's-segregation-model","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"(Image: )","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"In this introductory example we demonstrate Agents.jl's architecture and features through building the following definition of Schelling's segregation model:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Agents belong to one of two groups (0 or 1).\nThe agents live in a two-dimensional Moore grid (8 neighbors per node).\nIf an agent is in the same group with at least three neighbors, then it is happy.\nIf an agent is unhappy, it keeps moving to new locations until it is happy.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"This model is also available as Models.schelling.","category":"page"},{"location":"examples/schelling/#Defining-the-agent-type","page":"Schelling's segregation model","title":"Defining the agent type","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Agents, AgentsPlots\ngr() # hide\n\nmutable struct SchellingAgent <: AbstractAgent\n    id::Int # The identifier number of the agent\n    pos::Tuple{Int,Int} # The x, y location of the agent on a 2D grid\n    mood::Bool # whether the agent is happy in its node. (true = happy)\n    group::Int # The group of the agent,  determines mood as it interacts with neighbors\nend","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that the position of this Agent type is a Tuple{Int,Int} because we will use a GridSpace.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We added two more fields for this model, namely a mood field which will store true for a happy agent and false for an unhappy one, and an group field which stores 0 or 1 representing two groups.","category":"page"},{"location":"examples/schelling/#Creating-a-space","page":"Schelling's segregation model","title":"Creating a space","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For this example, we will be using a Moore 2D grid, e.g.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"space = GridSpace((10, 10), moore = true)","category":"page"},{"location":"examples/schelling/#Creating-an-ABM","page":"Schelling's segregation model","title":"Creating an ABM","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"To make our model we follow the instructions of AgentBasedModel. We also want to include a property min_to_be_happy in our model, and so we have:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"properties = Dict(:min_to_be_happy => 3)\nschelling = ABM(SchellingAgent, space; properties = properties)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Here we used the default scheduler (which is also the fastest one) to create the model. We could instead try to activate the agents according to their property :group, so that all agents of group 1 act first. We would then use the scheduler property_activation like so:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"schelling2 = ABM(\n    SchellingAgent,\n    space;\n    properties = properties,\n    scheduler = property_activation(:group),\n)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that property_activation accepts an argument and returns a function, which is why we didn't just give property_activation to scheduler.","category":"page"},{"location":"examples/schelling/#Creating-the-ABM-through-a-function","page":"Schelling's segregation model","title":"Creating the ABM through a function","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Here we put the model instantiation in a function so that it will be easy to recreate the model and change its parameters.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"In addition, inside this function, we populate the model with some agents. We also change the scheduler to random_activation. Because the function is defined based on keywords, it will be of further use in paramscan below.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"function initialize(; numagents = 320, griddims = (20, 20), min_to_be_happy = 3)\n    space = GridSpace(griddims, moore = true)\n    properties = Dict(:min_to_be_happy => min_to_be_happy)\n    model = ABM(SchellingAgent, space;\n                properties = properties, scheduler = random_activation)\n    # populate the model with agents, adding equal amount of the two types of agents\n    # at random positions in the model\n    for n in 1:numagents\n        agent = SchellingAgent(n, (1, 1), false, n < numagents / 2 ? 1 : 2)\n        add_agent_single!(agent, model)\n    end\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Notice that the position that an agent is initialized does not matter in this example. This is because we use add_agent_single!, which places the agent in a random, empty location on the grid, thus updating its position.","category":"page"},{"location":"examples/schelling/#Defining-a-step-function","page":"Schelling's segregation model","title":"Defining a step function","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Finally, we define a step function to determine what happens to an agent when activated.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"function agent_step!(agent, model)\n    agent.mood == true && return # do nothing if already happy\n    minhappy = model.min_to_be_happy\n    neighbor_cells = node_neighbors(agent, model)\n    count_neighbors_same_group = 0\n    # For each neighbor, get group and compare to current agent's group\n    # and increment count_neighbors_same_group as appropriately.\n    for neighbor_cell in neighbor_cells\n        node_contents = get_node_contents(neighbor_cell, model)\n        # Skip iteration if the node is empty.\n        length(node_contents) == 0 && continue\n        # Otherwise, get the first agent in the node...\n        agent_id = node_contents[1]\n        # ...and increment count_neighbors_same_group if the neighbor's group is\n        # the same.\n        neighbor_agent_group = model[agent_id].group\n        if neighbor_agent_group == agent.group\n            count_neighbors_same_group += 1\n        end\n    end\n    # After counting the neighbors, decide whether or not to move the agent.\n    # If count_neighbors_same_group is at least the min_to_be_happy, set the\n    # mood to true. Otherwise, move the agent to a random node.\n    if count_neighbors_same_group ≥ minhappy\n        agent.mood = true\n    else\n        move_agent_single!(agent, model)\n    end\n    return\nend\nnothing # hide","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For the purpose of this implementation of Schelling's segregation model, we only need an agent step function.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"When defining agent_step!, we used some of the built-in functions of Agents.jl, such as node_neighbors that returns the neighboring nodes of the node on which the agent resides, get_node_contents that returns the IDs of the agents on a given node, and move_agent_single! which moves agents to random empty nodes on the grid. A full list of built-in functions and their explanations are available in the API page.","category":"page"},{"location":"examples/schelling/#Stepping-the-model","page":"Schelling's segregation model","title":"Stepping the model","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Let's initialize the model with 370 agents on a 20 by 20 grid.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize()","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can advance the model one step","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"step!(model, agent_step!)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Or for three steps","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"step!(model, agent_step!, 3)","category":"page"},{"location":"examples/schelling/#Running-the-model-and-collecting-data","page":"Schelling's segregation model","title":"Running the model and collecting data","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can use the run! function with keywords to run the model for multiple steps and collect values of our desired fields from every agent and put these data in a DataFrame object. We define vector of Symbols for the agent fields that we want to collect as data","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"adata = [:pos, :mood, :group]\n\nmodel = initialize()\ndata, _ = run!(model, agent_step!, 5; adata = adata)\ndata[1:10, :] # print only a few rows","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We could also use functions in adata, for example we can define","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"x(agent) = agent.pos[1]\nmodel = initialize()\nadata = [x, :mood, :group]\ndata, _ = run!(model, agent_step!, 5; adata = adata)\ndata[1:10, :]","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"With the above adata vector, we collected all agent's data. We can instead collect aggregated data for the agents. For example, let's only get the number of happy individuals, and the maximum of the \"x\" (not very interesting, but anyway!)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize();\nadata = [(:mood, sum), (x, maximum)]\ndata, _ = run!(model, agent_step!, 5; adata = adata)\ndata","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Other examples in the documentation are more realistic, with a much more meaningful collected data. Don't forget to use the function aggname to access the columns of the resulting dataframe by name.","category":"page"},{"location":"examples/schelling/#Visualizing-the-data","page":"Schelling's segregation model","title":"Visualizing the data","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can use the plotabm function to plot the distribution of agents on a 2D grid at every generation, via the AgentsPlots package. Let's color the two groups orange and blue and make one a square and the other a circle.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"groupcolor(a) = a.group == 1 ? :blue : :orange\ngroupmarker(a) = a.group == 1 ? :circle : :square\nplotabm(model; ac = groupcolor, am = groupmarker, as = 4)","category":"page"},{"location":"examples/schelling/#Animating-the-evolution","page":"Schelling's segregation model","title":"Animating the evolution","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"The function plotabm can be used to make your own animations","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize();\nanim = @animate for i in 0:10\n    p1 = plotabm(model; ac = groupcolor, am = groupmarker, as = 4)\n    title!(p1, \"step $(i)\")\n    step!(model, agent_step!, 1)\nend\n\ngif(anim, \"schelling.gif\", fps = 2)","category":"page"},{"location":"examples/schelling/#Replicates-and-parallel-computing","page":"Schelling's segregation model","title":"Replicates and parallel computing","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can run replicates of a simulation and collect all of them in a single DataFrame. To that end, we only need to specify replicates in the run! function:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"model = initialize(numagents = 370, griddims = (20, 20), min_to_be_happy = 3)\ndata, _ = run!(model, agent_step!, 5; adata = adata, replicates = 3)\ndata[(end - 10):end, :]","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"It is possible to run the replicates in parallel. For that, we should start julia with julia -p n where is the number of processing cores. Alternatively, we can define the number of cores from within a Julia session:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using Distributed\naddprocs(4)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"For distributed computing to work, all definitions must be preceded with @everywhere, e.g.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"@everywhere using Agents\n@everywhere mutable struct SchellingAgent ...","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Then we can tell the run! function to run replicates in parallel:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"data, _ = run!(model, agent_step!, 2, adata=adata,\n               replicates=5, parallel=true)","category":"page"},{"location":"examples/schelling/#Scanning-parameter-ranges","page":"Schelling's segregation model","title":"Scanning parameter ranges","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We often are interested in the effect of different parameters on the behavior of an agent-based model. Agents.jl provides the function paramscan to automatically explore the effect of different parameter values.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We have already defined our model initialization function as initialize. We now also define a processing function, that returns the percentage of happy agents:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"happyperc(moods) = count(x -> x == true, moods) / length(moods)\n\nadata = [(:mood, happyperc)]\nparameters =\n    Dict(:min_to_be_happy => collect(2:5), :numagents => [200, 300], :griddims => (20, 20))\n\ndata, _ = paramscan(parameters, initialize; adata = adata, n = 3, agent_step! = agent_step!)\ndata","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"paramscan also allows running replicates per parameter setting:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"data, _ = paramscan(\n    parameters,\n    initialize;\n    adata = adata,\n    n = 3,\n    agent_step! = agent_step!,\n    replicates = 3,\n)\n\ndata[(end - 10):end, :]","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We can combine all replicates with an aggregating function, such as mean, using the groupby and combine functions from the DataFrames package:","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using DataFrames: groupby, combine, Not, select!\nusing Statistics: mean\ngd = groupby(data,[:step, :min_to_be_happy, :numagents])\ndata_mean = combine(gd,[:happyperc_mood,:replicate] .=> mean)\n\nselect!(data_mean, Not(:replicate_mean))","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Note that the second argument takes the column names on which to split the data, i.e., it denotes which columns should not be aggregated. It should include the :step column and any parameter that changes among simulations. But it should not include the :replicate column. So in principle what we are doing here is simply averaging our result across the replicates.","category":"page"},{"location":"examples/schelling/#Launching-the-interactive-application","page":"Schelling's segregation model","title":"Launching the interactive application","text":"","category":"section"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Given the definitions we have already created for a normal study of the Schelling model, it is almost trivial to launch an interactive application for it. First, we load InteractiveChaos to access interactive_abm","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"using InteractiveChaos\nusing GLMakie # we choose OpenGL as plotting backend","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Then, we define a dictionary that maps some model-level parameters to a range of potential values, so that we can interactively change them.","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"parange = Dict(:min_to_be_happy => 0:8)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"Due to the different plotting backend (Plots.jl vs Makie.jl) we redefine some of the plotting functions (in the near future this won't be necessary, as everything will be Makie.jl based)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"groupcolor(a) = a.group == 1 ? :blue : :orange\ngroupmarker(a) = a.group == 1 ? :circle : :rect","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"We define the alabels so that we can simple see the plotted timeseries with a shorter name (since the defaults can get large)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"adata = [(:mood, sum), (x, mean)]\nalabels = [\"happy\", \"avg. x\"]\n\nmodel = initialize(; numagents = 300) # fresh model, noone happy","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"scene, adf, modeldf =\ninteractive_abm(model, agent_step!, dummystep, parange;\n                ac = groupcolor, am = groupmarker, as = 1,\n                adata = adata, alabels = alabels)","category":"page"},{"location":"examples/schelling/","page":"Schelling's segregation model","title":"Schelling's segregation model","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/agents/schelling_app.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/wright-fisher.jl\"","category":"page"},{"location":"examples/wright-fisher/#Wright-Fisher-model-of-evolution","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"","category":"section"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"This is one of the simplest models of population genetics that demonstrates the use of sample!. We implement a simple case of the model where we study haploids (cells with a single set of chromosomes) while for simplicity, focus only on one locus (a specific gene). In this example we will be dealing with a population of constant size.","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"It is also available from the Models module as Models.wright_fisher.","category":"page"},{"location":"examples/wright-fisher/#A-neutral-model","page":"Wright-Fisher model of evolution","title":"A neutral model","text":"","category":"section"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Imagine a population of n haploid individuals.\nAt each generation, n offsprings replace the parents.\nEach offspring chooses a parent at random and inherits its genetic material.","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"using Agents\nnumagents = 100\nnothing # hide","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Let's define an agent. The genetic value of an agent is a number (trait field).","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"mutable struct Haploid <: AbstractAgent\n    id::Int\n    trait::Float64\nend","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"And make a model without any spatial structure:","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"model = ABM(Haploid)","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Create n random individuals:","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"for i in 1:numagents\n    add_agent!(model, rand())\nend","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"To create a new generation, we can use the sample! function. It chooses random individuals with replacement from the current individuals and updates the model. For example:","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"sample!(model, nagents(model))\nnothing # hide","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"The model can be run for many generations and we can collect the average trait value of the population. To do this we will use a model-step function (see step!) that utilizes sample!:","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"modelstep_neutral!(model::ABM) = sample!(model, nagents(model))\nnothing # hide","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"We can now run the model and collect data. We use dummystep for the agent-step function (as the agents perform no actions).","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"using Statistics: mean\n\ndata, _ = run!(model, dummystep, modelstep_neutral!, 20; adata = [(:trait, mean)])\ndata","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"As expected, the average value of the \"trait\" remains around 0.5.","category":"page"},{"location":"examples/wright-fisher/#A-model-with-selection","page":"Wright-Fisher model of evolution","title":"A model with selection","text":"","category":"section"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"We can sample individuals according to their trait values, supposing that their fitness is correlated with their trait values.","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"model = ABM(Haploid)\nfor i in 1:numagents\n    add_agent!(model, rand())\nend\n\nmodelstep_selection!(model::ABM) = sample!(model, nagents(model), :trait)\n\ndata, _ = run!(model, dummystep, modelstep_selection!, 20; adata = [(:trait, mean)])\ndata","category":"page"},{"location":"examples/wright-fisher/","page":"Wright-Fisher model of evolution","title":"Wright-Fisher model of evolution","text":"Here we see that as time progresses, the trait becomes closer and closer to 1, which is expected - since agents with higher traits have higher probability of being sampled for the next \"generation\".","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The core API is defined by AgentBasedModel, Space, AbstractAgent and step!, which are described in the Tutorial page. The functionality described here builds on top of the core API.","category":"page"},{"location":"api/#Agent-information-and-retrieval","page":"API","title":"Agent information and retrieval","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"space_neighbors\nrandom_agent\nnagents\nallagents\nallids\nnextid","category":"page"},{"location":"api/#Agents.space_neighbors","page":"API","title":"Agents.space_neighbors","text":"space_neighbors(position, model::ABM, r) → ids\n\nReturn the ids of the agents neighboring the given position (which must match type with the spatial structure of the model). r is the radius to search for agents.\n\nFor DiscreteSpace r must be integer and defines higher degree neighbors. For example, for r=2 include first and second degree neighbors, that is, neighbors and neighbors of neighbors. Specifically for GraphSpace, the keyword neighbor_type can also be used as in node_neighbors to restrict search on directed graphs.\n\nFor ContinuousSpace, r is real number and finds all neighbors within distance r (based on the space's metric).\n\nspace_neighbors(agent::AbstractAgent, model::ABM [, r]) → ids\n\nCall space_neighbors(agent.pos, model, r) but exclude the given agent from the neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_agent","page":"API","title":"Agents.random_agent","text":"random_agent(model)\n\nReturn a random agent from the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nagents","page":"API","title":"Agents.nagents","text":"nagents(model::ABM)\n\nReturn the number of agents in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allagents","page":"API","title":"Agents.allagents","text":"allagents(model)\n\nReturn an iterator over all agents of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.allids","page":"API","title":"Agents.allids","text":"allids(model)\n\nReturn an iterator over all agent IDs of the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nextid","page":"API","title":"Agents.nextid","text":"nextid(model::ABM) → id\n\nReturn a valid id for creating a new agent with it.\n\n\n\n\n\n","category":"function"},{"location":"api/#Model-Agent-interaction","page":"API","title":"Model-Agent interaction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following API is mostly universal across all types of Space. Only some specific methods are exclusive to a specific type of space, but we think this is clear from the documentation strings (if not, please open an issue!).","category":"page"},{"location":"api/","page":"API","title":"API","text":"add_agent!\nadd_agent_pos!\nadd_agent_single!\nmove_agent!\nmove_agent_single!\nkill_agent!\ngenocide!\nsample!","category":"page"},{"location":"api/#Agents.add_agent!","page":"API","title":"Agents.add_agent!","text":"add_agent!(agent::AbstractAgent [, position], model::ABM) → agent\n\nAdd the agent to the position in the space and to the list of agents. If position is not given, the agent is added to a random position. The agent's position is always updated to match position, and therefore for add_agent! the position of the agent is meaningless. Use add_agent_pos! to use the agent's position.\n\n\n\n\n\nadd_agent!([pos,] model::ABM, args...; kwargs...)\n\nCreate and add a new agent to the model by constructing an agent of the type of the model. Propagate all extra positional arguments and keyword arguemts to the agent constructor.\n\nNotice that this function takes care of setting the agent's id and position and thus args... and kwargs... are propagated to other fields the agent has.\n\nOptionally provide a position to add the agent to as first argument.\n\nExample\n\nusing Agents\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::Int\n    w::Float64\n    k::Bool\nend\nAgent(id, pos; w, k) = Agent(id, pos, w, k) # keyword constructor\nmodel = ABM(Agent, GraphSpace(complete_digraph(5)))\n\nadd_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally\nadd_agent!(model, 0.5, true) # correct: w becomes 0.5\nadd_agent!(5, model, 0.5, true) # add at node 5, w becomes 0.5\nadd_agent!(model; w = 0.5, k = true) # use keywords: w becomes 0.5\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_pos!","page":"API","title":"Agents.add_agent_pos!","text":"add_agent_pos!(agent::AbstractAgent, model::ABM) → agent\n\nAdd the agent to the model at the agent's own position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.add_agent_single!","page":"API","title":"Agents.add_agent_single!","text":"add_agent_single!(agent::A, model::ABM{A, <: DiscreteSpace}) → agent\n\nAdd agent to a random node in the space while respecting a maximum one agent per node. This function throws a warning if no empty nodes remain.\n\n\n\n\n\nadd_agent_single!(model::ABM{A, <: DiscreteSpace}, properties...; kwargs...)\n\nSame as add_agent!(model, properties...) but ensures that it adds an agent into a node with no other agents (does nothing if no such node exists).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_agent!","page":"API","title":"Agents.move_agent!","text":"move_agent!(agent::A, model::ABM{A, ContinuousSpace}, dt = 1.0)\n\nPropagate the agent forwards one step according to its velocity, after updating the agent's velocity (see ContinuousSpace). Also take care of periodic boundary conditions.\n\nFor this continuous space version of move_agent!, the \"evolution algorithm\" is a trivial Euler scheme with dt the step size, i.e. the agent position is updated as agent.pos += agent.vel * dt.\n\nNotice that if you want the agent to instantly move to a specified position, do agent.pos = pos and then update_space!(agent, model).\n\n\n\n\n\nmove_agent!(agent::A, model::ABM{A, ContinuousSpace}, vel::NTuple{D, N}, dt = 1.0)\n\nPropagate the agent forwards one step according to vel and the model's space, with dt as the time step. (update_vel! is not used)\n\n\n\n\n\nmove_agent!(agent::A [, pos], model::ABM{A, <: DiscreteSpace}) → agent\n\nMove agent to the given position, or to a random one if a position is not given. pos must be the appropriate position type depending on the space type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.move_agent_single!","page":"API","title":"Agents.move_agent_single!","text":"move_agent_single!(agent::AbstractAgent, model::ABM) → agent\n\nMove agent to a random node while respecting a maximum of one agent per node. If there are no empty nodes, the agent wont move. Only valid for non-continuous spaces.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.kill_agent!","page":"API","title":"Agents.kill_agent!","text":"kill_agent!(agent::AbstractAgent, model::ABM)\n\nRemove an agent from model, and from the space if the model has a space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.genocide!","page":"API","title":"Agents.genocide!","text":"genocide!(model::ABM)\n\nKill all the agents of the model.\n\n\n\n\n\ngenocide!(model::ABM, n::Int)\n\nKill the agents of the model whose IDs are larger than n.\n\n\n\n\n\ngenocide!(model::ABM, f::Function)\n\nKill all agents where the function f(agent) returns true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.sample!","page":"API","title":"Agents.sample!","text":"sample!(model::ABM, n [, weight]; kwargs...)\n\nReplace the agents of the model with a random sample of the current agents with size n.\n\nOptionally, provide a weight: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the weight of the agent, the higher the probability that this agent will be chosen in the new sampling.\n\nKeywords\n\nreplace = true : whether sampling is performed with replacement, i.e. all agents can\n\nbe chosen more than once.\n\nrng = GLOBAL_RNG : a random number generator to perform the sampling with.\n\nSee the Wright-Fisher example in the documentation for an application of sample!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Discrete-space-exclusives","page":"API","title":"Discrete space exclusives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"fill_space!\nnode_neighbors\nnv(::ABM)\nne(::ABM)\nhas_empty_nodes\nfind_empty_nodes\npick_empty\nget_node_contents\nget_node_agents\nisempty(::Integer, ::ABM)\nNodeIterator\nnodes\ncoord2vertex\nvertex2coord","category":"page"},{"location":"api/#Agents.fill_space!","page":"API","title":"Agents.fill_space!","text":"fill_space!([A ,] model::ABM{A, <:DiscreteSpace}, args...; kwargs...)\nfill_space!([A ,] model::ABM{A, <:DiscreteSpace}, f::Function; kwargs...)\n\nAdd one agent to each node in the model's space. Similarly with add_agent!, the function creates the necessary agents and the args...; kwargs... are propagated into agent creation. If instead of args... a function f is provided, then args = f(pos) is the result of applying f where pos is each position (tuple for grid, node index for graph).\n\nAn optional first argument is an agent type to be created, and targets mixed-agent models where the agent constructor cannot be deduced (since it is a union).\n\nExample\n\nusing Agents\nmutable struct Daisy <: AbstractAgent\n    id::Int\n    pos::Tuple{Int, Int}\n    breed::String\nend\nmutable struct Land <: AbstractAgent\n    id::Int\n    pos::Tuple{Int, Int}\n    temperature::Float64\nend\nspace = GridSpace((10, 10), moore = true, periodic = true)\nmodel = ABM(Union{Daisy, Land}, space)\ntemperature(pos) = (pos[1]/10, ) # make it Tuple!\nfill_space!(Land, model, temperature)\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.node_neighbors","page":"API","title":"Agents.node_neighbors","text":"node_neighbors(node, model::ABM{A, <:DiscreteSpace}, r = 1) → nodes\n\nReturn all nodes that are neighbors to the given node, which can be an Int for GraphSpace, or a NTuple{Int} for GridSpace. Use vertex2coord to convert nodes to positions for GridSpace.\n\nnode_neighbors(agent, model::ABM{A, <:DiscreteSpace}, r = 1) → nodes\n\nSame as above, but uses agent.pos as node.\n\nKeyword argument neighbor_type=:default can be used to select differing neighbors depending on the underlying graph directionality type.\n\n:default returns neighbors of a vertex. If graph is directed, this is equivalent\n\nto :out. For undirected graphs, all options are equivalent to :out.\n\n:all returns both :in and :out neighbors.\n:in returns incoming vertex neighbors.\n:out returns outgoing vertex neighbors.\n\n\n\n\n\n","category":"function"},{"location":"api/#LightGraphs.nv-Tuple{AgentBasedModel}","page":"API","title":"LightGraphs.nv","text":"nv(model::ABM)\n\nReturn the number of nodes (vertices) in the model space.\n\n\n\n\n\n","category":"method"},{"location":"api/#LightGraphs.ne-Tuple{AgentBasedModel}","page":"API","title":"LightGraphs.ne","text":"ne(model::ABM)\n\nReturn the number of edges in the model space.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agents.has_empty_nodes","page":"API","title":"Agents.has_empty_nodes","text":"has_empty_nodes(model)\n\nReturn true if there are empty nodes in the model.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.find_empty_nodes","page":"API","title":"Agents.find_empty_nodes","text":"find_empty_nodes(model::ABM)\n\nReturns the indices of empty nodes on the model space.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.pick_empty","page":"API","title":"Agents.pick_empty","text":"pick_empty(model)\n\nReturn a random empty node or 0 if there are no empty nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_node_contents","page":"API","title":"Agents.get_node_contents","text":"get_node_contents(node, model)\n\nReturn the ids of agents in the node of the model's space (which is an integer for GraphSpace and a tuple for GridSpace).\n\n\n\n\n\nget_node_contents(agent::AbstractAgent, model)\n\nReturn all agents' ids in the same node as the agent (including the agent's own id).\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.get_node_agents","page":"API","title":"Agents.get_node_agents","text":"get_node_agents(x, model)\n\nSame as get_node_contents(x, model) but directly returns the list of agents instead of just the list of IDs.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.isempty-Tuple{Integer,AgentBasedModel}","page":"API","title":"Base.isempty","text":"isempty(node::Int, model::ABM)\n\nReturn true if there are no agents in node.\n\n\n\n\n\n","category":"method"},{"location":"api/#Agents.NodeIterator","page":"API","title":"Agents.NodeIterator","text":"NodeIterator(model) → iterator\n\nCreate an iterator that returns node coordinates, if the space is a grid, or otherwise node number, and the agent IDs in each node.\n\n\n\n\n\n","category":"type"},{"location":"api/#Agents.nodes","page":"API","title":"Agents.nodes","text":"nodes(model; by = :id) -> ns\n\nReturn a vector of the node ids of the model that you can iterate over. The ns are sorted depending on by:\n\n:id - just sorted by their number\n:random - randomly sorted\n:population - nodes are sorted depending on how many agents they accommodate. The more populated nodes are first.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.coord2vertex","page":"API","title":"Agents.coord2vertex","text":"coord2vertex(coord::NTuple{Int}, model_or_space) → n\ncoord2vertex(coord::AbstractAgent, model_or_space) → n\n\nReturn the node number n of the given coordinates or the agent's position.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.vertex2coord","page":"API","title":"Agents.vertex2coord","text":"vertex2coord(vertex::Integer, model_or_space) → coords\n\nReturns the coordinates of a node given its number on the graph.\n\n\n\n\n\n","category":"function"},{"location":"api/#Continuous-space-exclusives","page":"API","title":"Continuous space exclusives","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"interacting_pairs\nnearest_neighbor\nelastic_collision!\nindex!\nupdate_space!","category":"page"},{"location":"api/#Agents.interacting_pairs","page":"API","title":"Agents.interacting_pairs","text":"interacting_pairs(model, r, method; scheduler = model.scheduler)\n\nReturn an iterator that yields unique pairs of agents (a1, a2) that are close neighbors to each other, within some interaction radius r.\n\nThis function is usefully combined with model_step!, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with a1 and with a2, which is unavoidable when using agent_step!).\n\nThe argument method provides three pairing scenarios\n\n:all: return every pair of agents that are within radius r of each other, not only the nearest ones.\n:nearest: agents are only paired with their true nearest neighbor (existing within radius r). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by id) will be paired.\n:scheduler: agents are scanned according to the given keyword scheduler (by default the model's scheduler), and each scanned agent is paired to its nearest neighbor. Similar to :nearest, each agent can belong to only one pair. This functionality is useful e.g. when you want some agents to be paired \"guaranteed\", even if some other agents might be nearest to each other.\n:types: For mixed agent models only. Return every pair of agents within radius r (similar to :all), only capturing pairs of differing types. For example, a model of Union{Sheep,Wolf} will only return pairs of (Sheep, Wolf). In the case of multiple agent types, e.g. Union{Sheep, Wolf, Grass}, skipping pairings that involve Grass, can be achived by a scheduler that doesn't schedule Grass types, i.e.: scheduler = [a.id for a in allagents(model) of !(a isa Grass)].\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.nearest_neighbor","page":"API","title":"Agents.nearest_neighbor","text":"nearest_neighbor(agent, model, r) → nearest\n\nReturn the agent that has the closest distance to given agent, according to the space's metric. Valid only in continuous space. Return nothing if no agent is within distance r.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.elastic_collision!","page":"API","title":"Agents.elastic_collision!","text":"elastic_collision!(a, b, f = nothing)\n\nResolve a (hypothetical) elastic collision between the two agents a, b. They are assumed to be disks of equal size touching tangentially. Their velocities (field vel) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.\n\nIf f is a Symbol, then the agent property f, e.g. :mass, is taken as a mass to weight the two agents for the collision. By default no weighting happens.\n\nOne of the two agents can have infinite \"mass\", and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.index!","page":"API","title":"Agents.index!","text":"index!(model)\n\nIndex the database underlying the ContinuousSpace of the model.\n\nThis can drastically improve performance for finding neighboring agents, but adding new data can become slower because after each addition, index needs to be called again.\n\nLack of index won't be noticed for small databases. Only use it when you have many agents and not many additions of agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.update_space!","page":"API","title":"Agents.update_space!","text":"update_space!(model::ABM{A, ContinuousSpace}, agent)\n\nUpdate the internal representation of continuous space to match the new position of the agent (useful in custom move_agent functions).\n\n\n\n\n\n","category":"function"},{"location":"api/#Data-collection","page":"API","title":"Data collection","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The central simulation function is run!, which is mentioned in our Tutorial. But there are other functions that are related to simulations listed here.","category":"page"},{"location":"api/","page":"API","title":"API","text":"init_agent_dataframe\ncollect_agent_data!\ninit_model_dataframe\ncollect_model_data!\naggname\nparamscan","category":"page"},{"location":"api/#Agents.init_agent_dataframe","page":"API","title":"Agents.init_agent_dataframe","text":"init_agent_dataframe(model, adata) → agent_df\n\nInitialize a dataframe to add data later with collect_agent_data!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.collect_agent_data!","page":"API","title":"Agents.collect_agent_data!","text":"collect_agent_data!(df, model, properties, step = 0; obtainer = identity)\n\nCollect and add agent data into df (see run! for the dispatch rules of properties and obtainer). step is given because the step number information is not known.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.init_model_dataframe","page":"API","title":"Agents.init_model_dataframe","text":"init_model_dataframe(model, mdata) → model_df\n\nInitialize a dataframe to add data later with collect_model_data!.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.collect_model_data!","page":"API","title":"Agents.collect_model_data!","text":"collect_model_data!(df, model, properties, step = 0, obtainer = identity)\n\nSame as collect_agent_data! but for model data instead.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.aggname","page":"API","title":"Agents.aggname","text":"aggname(k) → name\naggname(k, agg) → name\naggname(k, agg, condition) → name\n\nReturn the name of the column of the i-th collected data where k = adata[i] (or mdata[i]). aggname also accepts tuples with aggregate and conditional values.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.paramscan","page":"API","title":"Agents.paramscan","text":"paramscan(parameters, initialize; kwargs...)\n\nRun the model with all the parameter value combinations given in parameters while initializing the model with initialize. This function uses DrWatson's dict_list internally. This means that every entry of parameters that is a Vector, contains many parameters and thus is scanned. All other entries of parameters that are not Vectors are not expanded in the scan. Keys of parameters should be of type Symbol.\n\ninitialize is a function that creates an ABM. It should accept keyword arguments, of which all values in parameters should be a subset. This means parameters can take both model and agent constructor properties.\n\nKeywords\n\nAll the following keywords are propagated into run!. Defaults are also listed for convenience: agent_step! = dummystep, n = 1, when = 1:n, model_step! = dummystep, step0::Bool = true, parallel::Bool = false, replicates::Int = 0. Keyword arguments such as adata and mdata are also propagated.\n\nThe following keywords modify the paramscan function:\n\ninclude_constants::Bool=false determines whether constant parameters should be included in the output DataFrame.\n\nprogress::Bool = true whether to show the progress of simulations.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"For example, the core loop of run! is just","category":"page"},{"location":"api/","page":"API","title":"API","text":"df_agent = init_agent_dataframe(model, adata)\ndf_model = init_model_dataframe(model, mdata)\n\ns = 0\nwhile until(s, n, model)\n  if should_we_collect(s, model, when)\n      collect_agent_data!(df_agent, model, adata, s)\n  end\n  if should_we_collect(s, model, when_model)\n      collect_model_data!(df_model, model, mdata, s)\n  end\n  step!(model, agent_step!, model_step!, 1)\n  s += 1\nend\nreturn df_agent, df_model","category":"page"},{"location":"api/","page":"API","title":"API","text":"(here until and should_we_collect are internal functions)","category":"page"},{"location":"api/#Schedulers","page":"API","title":"Schedulers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The schedulers of Agents.jl have a very simple interface. All schedulers are functions, that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a \"true\" iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an AgentBasedModel.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Also notice that you can use Function-like-objects to make your scheduling possible of arbitrary events. For example, imagine that after the n-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define","category":"page"},{"location":"api/","page":"API","title":"API","text":"mutable struct MyScheduler\n    n::Int # step number\n    w::Float64\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"and then define a calling method for it like so","category":"page"},{"location":"api/","page":"API","title":"API","text":"function (ms::MyScheduler)(model::ABM)\n    ms.n += 1 # increment internal counter by 1 each time its called\n              # be careful to use a *new* instance of this scheduler when plotting!\n    if ms.n < 10\n        return keys(model.agents) # order doesn't matter in this case\n    else\n        ids = collect(allids(model))\n        # filter all ids whose agents have `w` less than some amount\n        filter!(id -> model[id].w < ms.w, ids)\n        return ids\n    end\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"and pass it to e.g. step! by initializing it","category":"page"},{"location":"api/","page":"API","title":"API","text":"ms = MyScheduler(100, 0.5)\nrun!(model, agentstep, modelstep, 100; scheduler = ms)","category":"page"},{"location":"api/#Predefined-schedulers","page":"API","title":"Predefined schedulers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Some useful schedulers are available below as part of the Agents.jl public API:","category":"page"},{"location":"api/","page":"API","title":"API","text":"fastest\nby_id\nrandom_activation\npartial_activation\nproperty_activation\nby_type","category":"page"},{"location":"api/#Agents.fastest","page":"API","title":"Agents.fastest","text":"fastest\n\nActivate all agents once per step in the order dictated by the agent's container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.by_id","page":"API","title":"Agents.by_id","text":"by_id\n\nActivate agents at each step according to their id.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.random_activation","page":"API","title":"Agents.random_activation","text":"random_activation\n\nActivate agents once per step in a random order. Different random ordering is used at each different step.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.partial_activation","page":"API","title":"Agents.partial_activation","text":"partial_activation(p)\n\nAt each step, activate only p percentage of randomly chosen agents.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.property_activation","page":"API","title":"Agents.property_activation","text":"property_activation(property)\n\nAt each step, activate the agents in an order dictated by their property, with agents with greater property acting first. property is a Symbol, which just dictates which field the agents to compare.\n\n\n\n\n\n","category":"function"},{"location":"api/#Agents.by_type","page":"API","title":"Agents.by_type","text":"by_type(shuffle_types::Bool, shuffle_agents::Bool)\n\nUseful only for mixed agent models using Union types.\n\nSetting shuffle_types = true groups by agent type, but randomizes the type order.\n\nOtherwise returns agents grouped in order of appearance in the Union.\n\nshuffle_agents = true randomizes the order of agents within each group, false returns\n\nthe default order of the container (equivalent to fastest).\n\n\n\n\n\nby_type((C, B, A), shuffle_agents::Bool)\n\nActivate agents by type in specified order (since Unions are not order preserving). shuffle_agents = true randomizes the order of agents within each group.\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting","page":"API","title":"Plotting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Plotting functionality comes from AgentsPlots, which uses Plots.jl. You need to install both AgentsPlots, as well as a plotting backend (we use GR) to use the following functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"The version of AgentsPlots is:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using Pkg\nPkg.status(\"AgentsPlots\")","category":"page"},{"location":"api/","page":"API","title":"API","text":"plotabm","category":"page"},{"location":"api/#AgentsPlots.plotabm","page":"API","title":"AgentsPlots.plotabm","text":"plotabm(model::ABM{A, <: ContinuousSpace}; ac, as, am, kwargs...)\nplotabm(model::ABM{A, <: DiscreteSpace}; ac, as, am, kwargs...)\n\nPlot the model as a scatter-plot, by configuring the agent shape, color and size via the keywords ac, as, am. These keywords can be constants, or they can be functions, each accepting an agent and outputting a valid value for color/shape/size.\n\nThe keyword scheduler = model.scheduler decides the plotting order of agents (which matters only if there is overlap).\n\nThe keyword offset is a function with argument offest(a::Agent). It targets scenarios where multiple agents existin within a grid cell as it adds an offset (same type as agent.pos) to the plotted agent position.\n\nAll other keywords are propagated into Plots.scatter and the plot is returned.\n\n\n\n\n\nplotabm(model::ABM{A, <: GraphSpace}; ac, as, am, kwargs...)\n\nThis function is the same as plotabm for ContinuousSpace, but here the three key functions ac, as, am do not get an agent as an input but a vector of agents at each node of the graph. Their output is the same.\n\nHere as defaults to length. Internally, the graphplot recipe is used, and all other kwargs... are propagated there.\n\n\n\n\n\n","category":"function"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/daisyworld.jl\"","category":"page"},{"location":"examples/daisyworld/#Daisyworld","page":"Daisyworld","title":"Daisyworld","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"(Image: )","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Study this example to learn about","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Simple agent properties with complex model interactions\nCollecting data with the low-level data collection API\nDiffusion of a quantity in a GridSpace\nthe fill_space! function\nrepresent a space \"surface property\" as an agent\ncounting time in the model and having time-dependent dynamics\ndata collection in a mixed-agent model\nperforming interactive scientific research","category":"page"},{"location":"examples/daisyworld/#Overview-of-Daisyworld","page":"Daisyworld","title":"Overview of Daisyworld","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"This model explores the Gaia hypothesis, which considers the Earth as a single, self-regulating system including both living and non-living parts.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Daisyworld is filled with black and white daisies. Their albedo's differ, with black daisies absorbing light and heat, warming the area around them; white daisies doing the opposite. Daisies can only reproduce within a certain temperature range, meaning too much (or too little) heat coming from the sun and/or surrounds will ultimately halt daisy propagation.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"When the climate is too cold it is necessary for the black daisies to propagate in order to raise the temperature, and vice versa – when the climate is too warm, it is necessary for more white daisies to be produced in order to cool the temperature. The interplay of the living and non living aspects of this world manages to find an equilibrium over a wide range of parameter settings, although with enough external forcing, the daisies will not be able to regulate the temperature of the planet and eventually go extinct.","category":"page"},{"location":"examples/daisyworld/#Defining-the-agent-types","page":"Daisyworld","title":"Defining the agent types","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Daisy has three values (other than the required id and pos for an agent that lives on a GridSpace. Each daisy has an age, confined later by a maximum age set by the user, a breed (either :black or :white) and an associated albedo value, again set by the user. Land represents the surface. We could make Land also have an albedo field, but in this world, the entire surface has the same albedo and thus we make it a model parameter.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Notice that the Land does not necessarily have to be an agent, and one could represent surface temperature via a matrix (parameter of the model). This is done in an older version, see file examples/daisyworld_matrix.jl. The old version has a slight performance advantage. However, the advantage of making the surface composed of agents is that visualization is simple and one can use the interactive application to also visualize surface temperature. It is also available from the Models module as Models.daisyworld.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"using Agents, AgentsPlots, Plots\nusing Statistics: mean\nusing Random # hide\ngr() # hide\n\nmutable struct Daisy <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    breed::Symbol\n    age::Int\n    albedo::Float64 # 0-1 fraction\nend\n\nmutable struct Land <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    temperature::Float64\nend\n\nconst DaisyWorld = ABM{Union{Daisy, Land}};\nnothing #hide","category":"page"},{"location":"examples/daisyworld/#World-heating","page":"Daisyworld","title":"World heating","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"The surface temperature of the world is heated by its sun, but daisies growing upon it absorb or reflect the starlight – altering the local temperature.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"function update_surface_temperature!(node::Int, model::DaisyWorld)\n    ids = get_node_contents(node, model)\n    # All grid points have at least one agent (the land)\n    absorbed_luminosity = if length(ids) == 1\n        # Set luminosity via surface albedo\n        (1 - model.surface_albedo) * model.solar_luminosity\n    else\n        # more than 1 agents: daisy exists\n        # Set luminosity via daisy albedo\n        (1 - model[ids[2]].albedo) * model.solar_luminosity\n    end\n    # We expect local heating to be 80 ᵒC for an absorbed luminosity of 1,\n    # approximately 30 for 0.5 and approximately -273 for 0.01.\n    local_heating = absorbed_luminosity > 0 ? 72 * log(absorbed_luminosity) + 80 : 80\n    # Surface temperature is the average of the current temperature and local heating.\n    T0 = model[ids[1]].temperature\n    model[ids[1]].temperature = (T0 + local_heating) / 2\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"In addition, temperature diffuses over time","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"function diffuse_temperature!(node::Int, model::DaisyWorld)\n    ratio = get(model.properties, :ratio, 0.5) # diffusion ratio\n    ids = space_neighbors(node, model)\n    meantemp = sum(model[i].temperature for i in ids if model[i] isa Land)/8\n    land = model[get_node_contents(node, model)[1]] # land at current node\n    # Each neighbor land patch is giving up 1/8 of the diffused\n    # amount to each of *its* neighbors\n    land.temperature = (1 - ratio)*land.temperature + ratio*meantemp\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/#Daisy-dynamics","page":"Daisyworld","title":"Daisy dynamics","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"The final piece of the puzzle is the life-cycle of each daisy. This method defines an optimal temperature for growth. If the temperature gets too hot or too cold, daisies will not wish to propagate. So long as the temperature is favorable, daisies compete for land and attempt to spawn a new plant of their breed in locations close to them.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"function propagate!(node::Int, model::DaisyWorld)\n    ids = get_node_contents(node, model)\n    if length(ids) > 1\n        daisy = model[ids[2]]\n        temperature = model[ids[1]].temperature\n        # Set optimum growth rate to 22.5 ᵒC, with bounds of [5, 40]\n        seed_threshold = (0.1457 * temperature - 0.0032 * temperature^2) - 0.6443\n        if rand() < seed_threshold\n            # Collect all adjacent cells that have no daisies\n            empty_neighbors = Int[]\n            neighbors = node_neighbors(node, model)\n            for n in neighbors\n                if length(get_node_contents(n, model)) == 1\n                    push!(empty_neighbors, n)\n                end\n            end\n            if !isempty(empty_neighbors)\n                # Seed a new daisy in one of those cells\n                seeding_place = vertex2coord(rand(empty_neighbors), model)\n                a = Daisy(nextid(model), seeding_place, daisy.breed, 0, daisy.albedo)\n                add_agent_pos!(a, model)\n            end\n        end\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"And if the daisies cross an age threshold, they die out. Death is controlled by the agent_step function","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"function agent_step!(agent::Daisy, model::DaisyWorld)\n    agent.age += 1\n    agent.age >= model.max_age && kill_agent!(agent, model)\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"We also need to define a version for the Land instances (the dynamics of the Land are resolved at model level)","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"agent_step!(agent::Land, model::DaisyWorld) = nothing\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"The model step function and agent step functions for Agents.jl to advance Daisyworld's dynamics. Since we have constructed a number of helper functions, these methods are quite straightforward.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"function model_step!(model)\n    for n in nodes(model)\n        update_surface_temperature!(n, model)\n        diffuse_temperature!(n, model)\n        propagate!(n, model)\n    end\n    model.tick += 1\n    solar_activity!(model)\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Notice that solar_activity! changes the incoming solar radiation over time, if the given \"scenario\" (a model parameter) is :ramp. The parameter tick of the model keeps track of time.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"function solar_activity!(model::DaisyWorld)\n    if model.scenario == :ramp\n        if model.tick > 200 && model.tick <= 400\n            model.solar_luminosity += model.solar_change\n        end\n        if model.tick > 500 && model.tick <= 750\n            model.solar_luminosity -= model.solar_change/2\n        end\n    elseif model.scenario == :change\n        model.solar_luminosity += model.solar_change\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/#Initialising-Daisyworld","page":"Daisyworld","title":"Initialising Daisyworld","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Here, we construct a function to initialize a Daisyworld. We use fill_space! to fill the space with Land instances. Then, we need to know how many daisies of each type to seed the planet with and what their albedo's are. We also want a value for surface albedo, as well as solar intensity (and we also choose between constant or time-dependent intensity with scenario).","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"import StatsBase\nimport DrWatson: @dict\n\nfunction daisyworld(;\n        griddims = (30, 30),\n        max_age = 25,\n        init_white = 0.2, # % cover of the world surface of white breed\n        init_black = 0.2, # % cover of the world surface of black breed\n        albedo_white = 0.75,\n        albedo_black = 0.25,\n        surface_albedo = 0.4,\n        solar_change = 0.005,\n        solar_luminosity = 1.0, # initial luminosity\n        scenario = :default,\n    )\n\n    space = GridSpace(griddims, moore = true, periodic = true)\n    properties = @dict max_age surface_albedo solar_luminosity solar_change scenario\n    properties[:tick] = 0\n    # create a scheduler that only schedules Daisies\n    daisysched(model) = [a.id for a in allagents(model) if a isa Daisy]\n    model = ABM(Union{Daisy, Land}, space;\n        scheduler = daisysched, properties = properties, warn = false\n    )\n\n    # fill model with `Land`: every grid cell has 1 land instance\n    fill_space!(Land, model, 0.0) # zero starting temperature\n\n    # Populate with daisies: each cell has only one daisy (black or white)\n    white_nodes = StatsBase.sample(1:nv(space), Int(init_white * nv(space)); replace = false)\n    for n in white_nodes\n        wd = Daisy(nextid(model), vertex2coord(n, space), :white, rand(0:max_age), albedo_white)\n        add_agent_pos!(wd, model)\n    end\n    allowed = setdiff(1:nv(space), white_nodes)\n    black_nodes = StatsBase.sample(allowed, Int(init_black * nv(space)); replace = false)\n    for n in black_nodes\n        wd = Daisy(nextid(model), vertex2coord(n, space), :black, rand(0:max_age), albedo_black)\n        add_agent_pos!(wd, model)\n    end\n\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/daisyworld/#Visualizing-and-animating","page":"Daisyworld","title":"Visualizing & animating","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Lets run the model with constant solar isolation and visualize the result","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Random.seed!(165) # hide\nmodel = daisyworld()","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"To visualize we need to define the necessary functions for plotabm. The daisies will obviously be black or white, but the land will have a color that reflects its temperature, with -50 darkest and 100 ᵒC brightest color","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"daisycolor(a::Daisy) = a.breed\nconst landcolor = cgrad(:thermal)\ndaisycolor(a::Land) = landcolor[(a.temperature+50)/150]\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"And we plot daisies as circles, and land patches as squares","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"daisyshape(a::Daisy) = :circle\ndaisysize(a::Daisy) = 7\ndaisyshape(a::Land) = :square\ndaisysize(a::Land) = 8.8\nnothing # hide","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Notice that we want to ensure that the Land patches are always plotted first.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"plotsched = by_type((Land, Daisy), false)\n\nplotkwargs = (\n    ac = daisycolor, am = daisyshape, as = daisysize,\n    scheduler = plotsched, aspect_ratio = 1, size = (600, 600), showaxis = false,\n)\n\np = plotabm(model; plotkwargs...)","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"And after a couple of steps","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"step!(model, agent_step!, model_step!, 5)\np = plotabm(model; plotkwargs...)","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Let's do some animation now","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Random.seed!(165) # hide\nmodel = daisyworld()\nanim = @animate for i in 0:30\n    p = plotabm(model; plotkwargs...)\n    title!(p, \"step $(i)\")\n    step!(model, agent_step!, model_step!)\nend\ngif(anim, \"daisyworld.gif\", fps = 3)","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Running this animation for longer hints that this world achieves quasi-equilibrium for some input parameters, where one breed does not totally dominate the other. Of course we can check this easily through data collection. Notice that here we have to define a function breed that returns the daisy's breed field. We cannot use just :breed to automatically find it, because in this mixed agent model, the Land doesn't have any breed.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"black(y) = count(x -> x == :black, y)\nwhite(y) = count(x -> x == :white, y)\nbreed(a) = a isa Daisy ? a.breed : :land\nadata = [(breed, black), (breed, white)]\n\nRandom.seed!(165) # hide\nmodel = daisyworld(; solar_luminosity = 1.0)\n\nagent_df, model_df = run!(model, agent_step!, model_step!, 1000; adata = adata)\n\np = plot(agent_df[!, :step], agent_df[!, :black_breed], label = \"black\")\nplot!(p, agent_df[!, :step], agent_df[!, :white_breed], label = \"white\")\nplot!(p; xlabel = \"tick\", ylabel = \"daisy count\")","category":"page"},{"location":"examples/daisyworld/#Time-dependent-dynamics","page":"Daisyworld","title":"Time dependent dynamics","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"To use the time-dependent dynamics we simply use the keyword scenario = :ramp during model creation. However, we also want to see how the planet surface temperature changes and would be nice to plot solar luminosity as well. Thus, we define in addition","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"gettemperature(a) = a isa Land ? a.temperature : missing\nmeantemperature(x) = mean(skipmissing(x))\nadata = [(breed, black), (breed, white), (gettemperature, meantemperature)]","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"And, to have it as reference, we also record the solar luminosity value","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"mdata = [:solar_luminosity]","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"And we run (and plot) everything","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Random.seed!(165) # hide\nmodel = daisyworld(solar_luminosity = 1.0, scenario = :ramp)\nagent_df, model_df = run!(model, agent_step!, model_step!, 1000; adata = adata, mdata = mdata)\n\np = plot(agent_df[!, :step], agent_df[!, :black_breed], label = \"black\")\nplot!(p, agent_df[!, :step], agent_df[!, :white_breed], label = \"white\")\nplot!(p; xlabel = \"tick\", ylabel = \"daisy count\")\n\np2 = plot(agent_df[!, :step], agent_df[!, aggname(adata[3])], ylabel = \"temperature\")\np3 = plot(model_df[!, :step], model_df[!, :solar_luminosity], ylabel = \"L\", xlabel = \"ticks\")\n\nplot(p, p2, p3, layout = (3, 1))","category":"page"},{"location":"examples/daisyworld/#Interactive-scientific-research","page":"Daisyworld","title":"Interactive scientific research","text":"","category":"section"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Julia is an interactive language, and thus everything that you do with Agents.jl can be considered interactive. However, we can do even better by using our interactive application. In this example, rather than describing what solar forcing we want to investigate before hand, we use the interactive application, to control by ourselves, in real time, how much solar forcing is delivered to daisyworld.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"So, let's use interactive_abm from the Interactive application page!","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"using InteractiveChaos, Makie, Random\nRandom.seed!(165)\nmodel = daisyworld(; solar_luminosity = 1.0, solar_change = 0.0, scenario = :change)","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"Thankfully, we have already defined the necessary adata, mdata as well as the agent color/shape/size functions, and we can re-use them for the interactive application. Because InteractiveChaos uses a different plotting package, Makie.jl, the plotting functions we have defined for plotabm need to be slightly adjusted. In the near future, AgentsPlots.jl will move to Makie.jl, so no adjustment will be necessary.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"using AbstractPlotting: to_color\ndaisycolor(a::Daisy) = RGBAf0(to_color(a.breed))\nconst landcolor = cgrad(:thermal)\ndaisycolor(a::Land) = to_color(landcolor[(a.temperature+50)/150])\n\ndaisyshape(a::Daisy) = :circle\ndaisysize(a::Daisy) = 0.6\ndaisyshape(a::Land) = :rect\ndaisysize(a::Land) = 1","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"The only significant addition to use the interactive application is that we make a parameter container for surface albedo and for the rate of change of solar luminosity, and add some labels for clarity.","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"params = Dict(\n    :solar_change => -0.1:0.01:0.1,\n    :surface_albedo => 0:0.01:1,\n)\n\nalabels = [\"black\", \"white\", \"T\"]\nmlabels = [\"L\"]\n\nlandfirst = by_type((Land, Daisy), false)\n\nscene, agent_df, model_def = interactive_abm(\n    model, agent_step!, model_step!, params;\n    ac = daisycolor, am = daisyshape, as = daisysize,\n    mdata = mdata, adata = adata, alabels = alabels, mlabels = mlabels,\n    scheduler = landfirst # crucial to change model scheduler!\n)","category":"page"},{"location":"examples/daisyworld/","page":"Daisyworld","title":"Daisyworld","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/agents/daisies.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/forest_fire.jl\"","category":"page"},{"location":"examples/forest_fire/#Forest-fire-model","page":"Forest fire","title":"Forest fire model","text":"","category":"section"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"(Image: )","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"The forest fire model is defined as a cellular automaton on a grid. A cell can be empty, occupied by a tree, or burning. The model of Drossel and Schwabl (1992) is defined by four rules which are executed simultaneously:","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"A burning cell turns into an empty cell\nA tree will burn if at least one neighbor is burning\nA tree ignites with probability f even if no neighbor is burning\nAn empty space fills with a tree with probability p","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"The forest has an innate density d, which is the proportion of trees initialized as green. This model is an example that does not have an agent_step! function. It only uses a model_step!. It is also available from the Models module as Models.forest_fire.","category":"page"},{"location":"examples/forest_fire/#Defining-the-core-structures","page":"Forest fire","title":"Defining the core structures","text":"","category":"section"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"We start by defining the agent type","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"using Agents, Random, AgentsPlots\ngr() # hide\n\nmutable struct Tree <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    status::Bool  # true is green and false is burning\nend\nnothing # hide","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"The agent type Tree has three fields: id and pos, which have to be there for any agent, and a status field that we introduce for this specific model. The status field will hold true for a green tree and false for a burning one. All other model parameters go into the AgentBasedModel.","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"We then make a setup function that initializes the model.","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"function model_initiation(; f = 0.02, d = 0.8, p = 0.01, griddims = (100, 100), seed = 111)\n    Random.seed!(seed)\n    space = GridSpace(griddims, moore = true)\n    properties = Dict(:f => f, :d => d, :p => p)\n    forest = AgentBasedModel(Tree, space; properties = properties)\n\n    # create and add trees to each node with probability d,\n    # which determines the density of the forest\n    for node in nodes(forest)\n        if rand() ≤ forest.d\n            add_agent!(node, forest, true)\n        end\n    end\n    return forest\nend\n\nforest = model_initiation(f = 0.05, d = 0.8, p = 0.05, griddims = (20, 20), seed = 2)","category":"page"},{"location":"examples/forest_fire/#Defining-the-step!","page":"Forest fire","title":"Defining the step!","text":"","category":"section"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"Because of the way the forest fire model is defined, we only need a stepping function for the model","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"function forest_step!(forest)\n    for node in nodes(forest, by = :random)\n        nc = get_node_contents(node, forest)\n        # the cell is empty, maybe a tree grows here\n        if length(nc) == 0\n            rand() ≤ forest.p && add_agent!(node, forest, true)\n        else\n            tree = forest[nc[1]] # by definition only 1 agent per node\n            if tree.status == false  # if it is has been burning, remove it.\n                kill_agent!(tree, forest)\n            else\n                if rand() ≤ forest.f  # the tree ignites spontaneously\n                    tree.status = false\n                else  # if any neighbor is on fire, set this tree on fire too\n                    for cell in node_neighbors(node, forest)\n                        neighbors = get_node_contents(cell, forest)\n                        length(neighbors) == 0 && continue\n                        if any(n -> !forest.agents[n].status, neighbors)\n                            tree.status = false\n                            break\n                        end\n                    end\n                end\n            end\n        end\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"as we discussed, there is no agent_step! function here, so we will just use dummystep.","category":"page"},{"location":"examples/forest_fire/#Running-the-model","page":"Forest fire","title":"Running the model","text":"","category":"section"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"step!(forest, dummystep, forest_step!, 1)\nforest","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"step!(forest, dummystep, forest_step!, 10)\nforest","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"Now we can do some data collection as well using an aggregate function percentage:","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"forest = model_initiation(griddims = (20, 20), seed = 2)\npercentage(x) = count(x) / nv(forest)\nadata = [(:status, percentage)]\n\ndata, _ = run!(forest, dummystep, forest_step!, 10; adata = adata)\ndata","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"Now let's plot the model using green and red color for alive/burning","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"forest = model_initiation()\nstep!(forest, dummystep, forest_step!, 1)\ntreecolor(a) = a.status == 1 ? :green : :red\nplotabm(forest; ac = treecolor, ms = 6, msw = 0)","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"or animate it","category":"page"},{"location":"examples/forest_fire/","page":"Forest fire","title":"Forest fire","text":"forest = model_initiation(f = 0.005)\nanim = @animate for i in 0:20\n    i > 0 && step!(forest, dummystep, forest_step!, 1)\n    p1 = plotabm(forest; ac = treecolor, ms = 6, msw = 0)\n    title!(p1, \"step $(i)\")\nend\n\ngif(anim, \"forest.gif\", fps = 2)","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/flock.jl\"","category":"page"},{"location":"examples/flock/#Flock-model","page":"Flocking","title":"Flock model","text":"","category":"section"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"(Image: )","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"The flock model illustrates how flocking behavior can emerge when each bird follows three simple rules:","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"maintain a minimum distance from other birds to avoid collision\nfly towards the average position of neighbors\nfly in the average direction of neighbors","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"It is also available from the Models module as Models.flocking.","category":"page"},{"location":"examples/flock/#Defining-the-core-structures","page":"Flocking","title":"Defining the core structures","text":"","category":"section"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"We begin by calling the required packages and defining an agent type representing a bird.","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"using Agents, LinearAlgebra\nusing Random # hide\n\nmutable struct Bird <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Float64}\n    vel::NTuple{2,Float64}\n    speed::Float64\n    cohere_factor::Float64\n    separation::Float64\n    separate_factor::Float64\n    match_factor::Float64\n    visual_distance::Float64\nend","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"The fields id and pos are required for every agent. The field vel is required for using move_agent! in ContinuousSpace. speed defines how far the bird travels in the direction defined by vel per step. seperation defines the minimum distance a bird must maintain from its neighbors. visual_distance refers to the distance a bird can see and defines a radius of neighboring birds. The contribution of each rule defined above recieves an importance weight: cohere_factor is the importance of maintaining the average position of neighbors, match_factor is the importance of matching the average trajectory of neighboring birds, and separate_factor is the importance of maining the minimum distance from neighboring birds.","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"The function initialize_model generates birds and returns a model object using default values.","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"function initialize_model(;\n    n_birds = 100,\n    speed = 1.0,\n    cohere_factor = 0.25,\n    separation = 4.0,\n    separate_factor = 0.25,\n    match_factor = 0.01,\n    visual_distance = 5.0,\n    dims = (100, 100),\n)\n    space2d = ContinuousSpace(2; periodic = true, extend = dims)\n    model = ABM(Bird, space2d, scheduler = random_activation)\n    for _ in 1:n_birds\n        vel = Tuple(rand(2) * 2 .- 1)\n        add_agent!(\n            model,\n            vel,\n            speed,\n            cohere_factor,\n            separation,\n            separate_factor,\n            match_factor,\n            visual_distance,\n        )\n    end\n    index!(model)\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/flock/#Defining-the-agent_step!","page":"Flocking","title":"Defining the agent_step!","text":"","category":"section"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"agent_step! is the primary function called for each step and computes velocity according to the three rules defined above.","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"function agent_step!(bird, model)\n    # Obtain the ids of neighbors within the bird's visual distance\n    ids = space_neighbors(bird, model, bird.visual_distance)\n    # Compute velocity based on rules defined above\n    bird.vel =\n        (\n            bird.vel .+ cohere(bird, model, ids) .+ separate(bird, model, ids) .+\n            match(bird, model, ids)\n        ) ./ 2\n    bird.vel = bird.vel ./ norm(bird.vel)\n    # Move bird according to new velocity and speed\n    move_agent!(bird, model, bird.speed)\nend\n\ndistance(a1, a2) = sqrt(sum((a1.pos .- a2.pos) .^ 2))\n\nget_heading(a1, a2) = a1.pos .- a2.pos\nnothing # hide","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"cohere computes the average position of neighboring birds, weighted by importance","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"function cohere(bird, model, ids)\n    N = max(length(ids), 1)\n    birds = model.agents\n    coherence = (0.0, 0.0)\n    for id in ids\n        coherence = coherence .+ get_heading(birds[id], bird)\n    end\n    return coherence ./ N .* bird.cohere_factor\nend\nnothing # hide","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"separate repels the bird away from neighboring birds","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"function separate(bird, model, ids)\n    seperation_vec = (0.0, 0.0)\n    N = max(length(ids), 1)\n    birds = model.agents\n    for id in ids\n        neighbor = birds[id]\n        if distance(bird, neighbor) < bird.separation\n            seperation_vec = seperation_vec .- get_heading(neighbor, bird)\n        end\n    end\n    return seperation_vec ./ N .* bird.separate_factor\nend\nnothing # hide","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"match computes the average trajectory of neighboring birds, weighted by importance","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"function match(bird, model, ids)\n    match_vector = (0.0, 0.0)\n    N = max(length(ids), 1)\n    birds = model.agents\n    for id in ids\n        match_vector = match_vector .+ birds[id].vel\n    end\n    return match_vector ./ N .* bird.match_factor\nend\nnothing # hide","category":"page"},{"location":"examples/flock/#Running-the-model","page":"Flocking","title":"Running the model","text":"","category":"section"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"Random.seed!(23182) # hide\nn_steps = 500\nmodel = initialize_model()\nstep!(model, agent_step!, n_steps)","category":"page"},{"location":"examples/flock/#Plotting-the-birds","page":"Flocking","title":"Plotting the birds","text":"","category":"section"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"The great thing about plotabm is its flexibility. We can incorporate the direction of the birds when plotting them, by making the \"marker\" function am create a Shape: a triangle with same orientation as the bird's velocity. It is as simple as defining the following function:","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"function bird_triangle(b::Bird)\n    φ = atan(b.vel[2], b.vel[1])\n    xs = [(i ∈ (0, 3) ? 2 : 1) * cos(i * 2π / 3 + φ) for i in 0:3]\n    ys = [(i ∈ (0, 3) ? 2 : 1) * sin(i * 2π / 3 + φ) for i in 0:3]\n    Shape(xs, ys)\nend\nnothing # hide","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"And here is the animation","category":"page"},{"location":"examples/flock/","page":"Flocking","title":"Flocking","text":"using AgentsPlots\ngr() # hide\nRandom.seed!(23182) # hide\nmodel = initialize_model()\ne = model.space.extend\nanim = @animate for i in 0:100\n    i > 0 && step!(model, agent_step!, 1)\n    p1 = plotabm(\n        model;\n        am = bird_triangle,\n        as = 10,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n    title!(p1, \"step $(i)\")\nend\ngif(anim, \"flock.gif\", fps = 30)","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/social_distancing.jl\"","category":"page"},{"location":"examples/social_distancing/#Continuous-space-social-distancing-for-COVID-19","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"(Image: )","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"This is a model similar to our SIR model for the spread of COVID-19. But instead of having different cities, we let agents move in one continuous space and transfer the disease if they come into contact with one another. This model is partly inspired by this article, and can complement the SIR graph model. The graph model can model virus transfer between cities, whilst this model can be used to study what happens within a city.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"The example here serves additionally as an introduction to using continuous space, modelling billiard-like collisions in that space, and animating the agent motion in the space. Notice that a detailed description of the basics of the model regarding disease spreading exists in the SIR example, and is not repeated here.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"It is also available from the Models module as Models.social_distancing.","category":"page"},{"location":"examples/social_distancing/#Moving-agents-in-continuous-space","page":"Continuous space social distancing for COVID-19","title":"Moving agents in continuous space","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let us first create a simple model where balls move around in a continuous space. We need to create agents that comply with ContinuousSpace, i.e. they have a pos and vel fields, both of which are tuples of float numbers.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"using Agents, Random, AgentsPlots, Plots\ngr() # hide\nmutable struct Agent <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Float64}\n    vel::NTuple{2,Float64}\n    mass::Float64\nend","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"The mass field will come in handy later on, when we implement social isolation (i.e. that some agents don't move and can't be moved).","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let's also initialize a trivial model with continuous space","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function ball_model(; speed = 0.002)\n    space2d = ContinuousSpace(2; periodic = true, extend = (1, 1))\n    model = ABM(Agent, space2d, properties = Dict(:dt => 1.0))\n\n    # And add some agents to the model\n    Random.seed!(42) # hide\n    for ind in 1:500\n        pos = Tuple(rand(2))\n        vel = sincos(2π * rand()) .* speed\n        add_agent!(pos, model, vel, 1.0)\n    end\n    index!(model)\n    return model\nend\n\nmodel = ball_model()","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We took advantage of the functionality of add_agent! that creates the agents automatically. For now all agents have the same absolute speed, and mass. We index! the model, to make finding space neighbors faster.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"The agent step function for now is trivial. It is just move_agent! in continuous space","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"agent_step!(agent, model) = move_agent!(agent, model, model.dt)\nnothing # hide","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"dt is our time resolution, but we will talk about this more later! Cool, let's see now how this model evolves.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"e = model.space.extend\nanim = @animate for i in 1:2:100\n    p1 = plotabm(\n        model,\n        as = 4,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n\n    title!(p1, \"step $(i)\")\n    step!(model, agent_step!, 2)\nend\ngif(anim, \"socialdist1.gif\", fps = 25)","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"As you can see the agents move in a straight line in periodic space. There is no interaction yet. Let's change that.","category":"page"},{"location":"examples/social_distancing/#Billiard-like-interaction","page":"Continuous space social distancing for COVID-19","title":"Billiard-like interaction","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We will model the agents as balls that collide with each other. To this end, we will use two functions from the continuous space API:","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"interacting_pairs\nelastic_collision!","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We want all agents to interact in one go, and we want to avoid double interactions (as instructed by interacting_pairs), so we define a model step and re-run the animation.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function model_step!(model)\n    for (a1, a2) in interacting_pairs(model, 0.012, :nearest)\n        elastic_collision!(a1, a2, :mass)\n    end\nend\n\nmodel2 = ball_model()\n\ne = model.space.extend\nanim = @animate for i in 1:2:100\n    p1 = plotabm(\n        model2,\n        as = 4,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n    title!(p1, \"step $(i)\")\n    step!(model2, agent_step!, model_step!, 2)\nend\ngif(anim, \"socialdist2.gif\", fps = 25)","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Alright, this works great so far!","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"warning: Agents.jl is not a billiards simulator!\nPlease understand that Agents.jl does not accurately simulate billiard systems. This is the job of Julia packages HardSphereDynamics.jl or DynamicalBilliards.jl. In Agents.jl we only provide an approximating function elastic_collision!. The accuracy of this simulation increases as the time resolution dt decreases, but even in the limit dt → 0 we still don't reach the accuracy of proper billiard packages.Also notice that the plotted size of the circles representing agents is not deduced from the interaction_radius (as it should). We only eye-balled it to look similar enough.","category":"page"},{"location":"examples/social_distancing/#Immovable-agents","page":"Continuous space social distancing for COVID-19","title":"Immovable agents","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"For the following social distancing example, it will become crucial that some agents don't move, and can't be moved (i.e. they stay \"isolated\"). This is very easy to do with the elastic_collision! function, we only have to make some agents have infinite mass","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"model3 = ball_model()\n\nfor id in 1:400\n    agent = model3[id]\n    agent.mass = Inf\n    agent.vel = (0.0, 0.0)\nend","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"let's animate this again","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"e = model.space.extend\nanim = @animate for i in 1:2:100\n    p1 = plotabm(\n        model3,\n        as = 4,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n    title!(p1, \"step $(i)\")\n    step!(model3, agent_step!, model_step!, 2)\nend\ngif(anim, \"socialdist3.gif\", fps = 25)","category":"page"},{"location":"examples/social_distancing/#Adding-Virus-spread-(SIR)","page":"Continuous space social distancing for COVID-19","title":"Adding Virus spread (SIR)","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We now add more functionality to these agents, according to the SIR model (see previous example). They can be infected with a disease and transfer the disease to other agents around them.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"mutable struct PoorSoul <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Float64}\n    vel::NTuple{2,Float64}\n    mass::Float64\n    days_infected::Int  # number of days since is infected\n    status::Symbol  # :S, :I or :R\n    β::Float64\nend","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Here β is the transmission probability, which we choose to make an agent parameter instead of a model parameter. It reflects the level of hygiene of an individual. In a realistic scenario, the actual virus transmission would depend on the β value of both agents, but we don't do that here for simplicity.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We also significantly modify the model creation, to have SIR-related parameters. Each step in the model corresponds to one hour.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"const steps_per_day = 24\n\nusing DrWatson: @dict\nfunction sir_initiation(;\n    infection_period = 30 * steps_per_day,\n    detection_time = 14 * steps_per_day,\n    reinfection_probability = 0.05,\n    isolated = 0.0, # in percentage\n    interaction_radius = 0.012,\n    dt = 1.0,\n    speed = 0.002,\n    death_rate = 0.044, # from website of WHO\n    N = 1000,\n    initial_infected = 5,\n    seed = 42,\n    βmin = 0.4,\n    βmax = 0.8,\n)\n\n    properties = @dict(\n        infection_period,\n        reinfection_probability,\n        detection_time,\n        death_rate,\n        interaction_radius,\n        dt,\n    )\n    space = ContinuousSpace(2)\n    model = ABM(PoorSoul, space, properties = properties)\n\n    # Add initial individuals\n    Random.seed!(seed)\n    for ind in 1:N\n        pos = Tuple(rand(2))\n        status = ind ≤ N - initial_infected ? :S : :I\n        isisolated = ind ≤ isolated * N\n        mass = isisolated ? Inf : 1.0\n        vel = isisolated ? (0.0, 0.0) : sincos(2π * rand()) .* speed\n\n        # very high transmission probability\n        # we are modelling close encounters after all\n        β = (βmax - βmin) * rand() + βmin\n        add_agent!(pos, model, vel, mass, 0, status, β)\n    end\n\n    Agents.index!(model)\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Notice the constant steps_per_day, which approximates how many model steps correspond to one day (since the parameters we used in the previous graph SIR example were given in days).","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"To visualize this model, we will use black color for the susceptible, red for the infected infected and green for the recovered, leveraging plotabm.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"sir_model = sir_initiation()\n\nsir_colors(a) = a.status == :S ? \"#2b2b33\" : a.status == :I ? \"#bf2642\" : \"#338c54\"\n\ne = model.space.extend\nplotabm(\n    sir_model;\n    ac = sir_colors,\n    as = 4,\n    msc=:auto,\n    showaxis = false,\n    grid = false,\n    xlims = (0, e[1]),\n    ylims = (0, e[2]),\n)","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We have increased the size of the model 10-fold (for more realistic further analysis)","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"To actually spread the virus, we modify the model_step! function, so that individuals have a probability to transmit the disease as they interact.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function transmit!(a1, a2, rp)\n    # for transmission, only 1 can have the disease (otherwise nothing happens)\n    count(a.status == :I for a in (a1, a2)) ≠ 1 && return\n    infected, healthy = a1.status == :I ? (a1, a2) : (a2, a1)\n\n    rand() > infected.β && return\n\n    if healthy.status == :R\n        rand() > rp && return\n    end\n    healthy.status = :I\nend\n\nfunction sir_model_step!(model)\n    r = model.interaction_radius\n    for (a1, a2) in interacting_pairs(model, r, :nearest)\n        transmit!(a1, a2, model.reinfection_probability)\n        elastic_collision!(a1, a2, :mass)\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Notice that it is not necessary that the transmission interaction radius is the same as the billiard-ball dynamics. We only have them the same here for convenience, but in a real model they will probably differ.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We also modify the agent_step! function, so that we keep track of how long the agent has been infected, and whether they have to die or not.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"function sir_agent_step!(agent, model)\n    move_agent!(agent, model, model.dt)\n    update!(agent)\n    recover_or_die!(agent, model)\nend\n\nupdate!(agent) = agent.status == :I && (agent.days_infected += 1)\n\nfunction recover_or_die!(agent, model)\n    if agent.days_infected ≥ model.infection_period\n        if rand() ≤ model.death_rate\n            kill_agent!(agent, model)\n        else\n            agent.status = :R\n            agent.days_infected = 0\n        end\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Alright, now we can animate this process for default parameters","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"sir_model = sir_initiation()\n\ne = model.space.extend\nanim = @animate for i in 1:2:100\n    p1 = plotabm(\n        sir_model;\n        ac = sir_colors,\n        as = 4,\n        msc=:auto,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n    title!(p1, \"step $(i)\")\n    step!(sir_model, sir_agent_step!, sir_model_step!, 2)\nend\ngif(anim, \"socialdist4.gif\", fps = 25)","category":"page"},{"location":"examples/social_distancing/#Exponential-spread","page":"Continuous space social distancing for COVID-19","title":"Exponential spread","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"We can all agree that these animations look interesting, but let's do some actual analysis of this model. The quantity we wish to look at is the number of infected over time, so let's calculate this, similarly with the graph SIR model.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"infected(x) = count(i == :I for i in x)\nrecovered(x) = count(i == :R for i in x)\nadata = [(:status, infected), (:status, recovered)]\nnothing # hide","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let's do the following runs, with different parameters probabilities","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"r1, r2 = 0.04, 0.33\nβ1, β2 = 0.5, 0.1\nsir_model1 = sir_initiation(reinfection_probability = r1, βmin = β1)\nsir_model2 = sir_initiation(reinfection_probability = r2, βmin = β1)\nsir_model3 = sir_initiation(reinfection_probability = r1, βmin = β2)\n\ndata1, _ = run!(sir_model1, sir_agent_step!, sir_model_step!, 2000; adata = adata)\ndata2, _ = run!(sir_model2, sir_agent_step!, sir_model_step!, 2000; adata = adata)\ndata3, _ = run!(sir_model3, sir_agent_step!, sir_model_step!, 2000; adata = adata)\n\ndata1[(end - 10):end, :]","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Now, we can plot the number of infected versus time","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"p = plot(\n    data1[:, aggname(:status, infected)],\n    label = \"r=$r1, beta=$β1\",\n    ylabel = \"Infected\",\n)\nplot!(p, data2[:, aggname(:status, infected)], label = \"r=$r2, beta=$β1\")\nplot!(p, data3[:, aggname(:status, infected)], label = \"r=$r1, beta=$β2\")\np","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Exponential growth is evident in all cases.","category":"page"},{"location":"examples/social_distancing/#Social-distancing","page":"Continuous space social distancing for COVID-19","title":"Social distancing","text":"","category":"section"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Of course in reality a dampening mechanism will (hopefully) happen before all of the population is infected: a vaccine. This effectively introduces a 4th type of status, :V for vaccinated. This type can't get infected, and thus all remaining individuals that are already infected will (hopefully) survive or die out.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Until that point, social distancing is practiced. The best way to model social distancing is to make some agents simply not move (which feels like it approximates reality better).","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"sir_model = sir_initiation(isolated = 0.8)\n\ne = model.space.extend\nanim = @animate for i in 0:2:1000\n    p1 = plotabm(\n        sir_model;\n        ac = sir_colors,\n        as = 4,\n        msc=:auto,\n        showaxis = false,\n        grid = false,\n        xlims = (0, e[1]),\n        ylims = (0, e[2]),\n    )\n    title!(p1, \"step $(i)\")\n    step!(sir_model, sir_agent_step!, sir_model_step!, 2)\nend\ngif(anim, \"socialdist5.gif\", fps = 25)","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Here we let some 20% of the population not be isolated, probably teenagers still partying, or anti-vaxers / flat-earthers that don't believe in science. Still, you can see that the spread of the virus is dramatically contained.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Let's look at the actual numbers, because animations are cool, but science is even cooler.","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"r4 = 0.04\nsir_model4 = sir_initiation(reinfection_probability = r4, βmin = β1, isolated = 0.8)\n\ndata4, _ = run!(sir_model4, sir_agent_step!, sir_model_step!, 2000; adata = adata)\n\nplot!(p, data4[:, aggname(:status, infected)], label = \"r=$r4, social distancing\")\np","category":"page"},{"location":"examples/social_distancing/","page":"Continuous space social distancing for COVID-19","title":"Continuous space social distancing for COVID-19","text":"Here you can see the characteristic \"flattening the curve\" phrase you hear all over the news.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/predator_prey.jl\"","category":"page"},{"location":"examples/predator_prey/#Model-of-predator-prey-dynamics","page":"Predator-Prey","title":"Model of predator-prey dynamics","text":"","category":"section"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"The predator-prey model emulates the population dynamics of predator and prey animals who live in a common ecosystem and compete over limited resources. This model is an agent-based analog to the classic Lotka-Volterra differential equation model. This example illustrates how to develop models with heterogeneous agents (sometimes referred to as a mixed agent based model).","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"The environment is a two dimensional grid containing sheep, wolves and grass. In the model, wolves eat sheep and sheep eat grass. Their populations will oscillate over time if the correct balance of resources is achieved. Without this balance however, a population may become extinct. For example, if wolf population becomes too large, they will deplete the sheep and subsequently die of starvation.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"We will begin by loading the required packages and defining three subtypes of AbstractAgent: Sheep, Wolf, and Grass. All three agent types have id and pos properties, which is a requirement for all subtypes of AbstractAgent when they exist upon a GridSpace. Sheep and wolves have identical properties, but different behaviors as explained below. The property energy represents an animals current energy level. If the level drops below zero, the agent will die. Sheep and wolves reproduce asexually in this model, with a probability given by reproduction_prob. The property Δenergy controls how much energy is acquired after consuming a food source.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Grass is a replenishing resource that occupies every cell in the grid space. Grass can be consumed only if it is fully_grown. Once the grass has been consumed, it replenishes after a delay specified by the property regrowth_time. The property countdown tracks the delay between being consumed and the regrowth time.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"It is also available from the Models module as Models.predator_prey.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"using Agents, AgentsPlots, StatsPlots\nusing Random # hide\npyplot() # hide\n\nmutable struct Sheep <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    energy::Float64\n    reproduction_prob::Float64\n    Δenergy::Float64\nend\n\nmutable struct Wolf <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    energy::Float64\n    reproduction_prob::Float64\n    Δenergy::Float64\nend\n\nmutable struct Grass <: AbstractAgent\n    id::Int\n    pos::Tuple{Int,Int}\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"The function initialize_model returns a new model containing sheep, wolves, and grass using a set of pre-defined values (which can be overwritten). The environment is a two dimensional grid space with moore = true, which enables animals to walk in all directions. Heterogeneous agents are specified in the model as a Union. Agents are scheduled by_type, which randomizes the order of agents with the constraint that agents of a particular type are scheduled consecutively.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"function initialize_model(;\n    n_sheep = 100,\n    n_wolves = 50,\n    dims = (20, 20),\n    regrowth_time = 30,\n    Δenergy_sheep = 4,\n    Δenergy_wolf = 20,\n    sheep_reproduce = 0.04,\n    wolf_reproduce = 0.05,\n)\n    space = GridSpace(dims, moore = true)\n    model =\n        ABM(Union{Sheep,Wolf,Grass}, space, scheduler = by_type(true, true), warn = false)\n    id = 0\n    for _ in 1:n_sheep\n        id += 1\n        energy = rand(1:(Δenergy_sheep * 2)) - 1\n        # Note that we must instantiate agents before adding them in a mixed-ABM\n        # to confirm their type.\n        sheep = Sheep(id, (0, 0), energy, sheep_reproduce, Δenergy_sheep)\n        add_agent!(sheep, model)\n    end\n    for _ in 1:n_wolves\n        id += 1\n        energy = rand(1:(Δenergy_wolf * 2)) - 1\n        wolf = Wolf(id, (0, 0), energy, wolf_reproduce, Δenergy_wolf)\n        add_agent!(wolf, model)\n    end\n    for n in nodes(model)\n        id += 1\n        fully_grown = rand(Bool)\n        countdown = fully_grown ? regrowth_time : rand(1:regrowth_time) - 1\n        grass = Grass(id, (0, 0), fully_grown, regrowth_time, countdown)\n        add_agent!(grass, n, model)\n    end\n    return model\nend\nnothing # hide","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"The function agent_step! is dispatched on each subtype in order to produce type-specific behavior. The agent_step! is similar for sheep and wolves: both lose 1 energy unit by moving to an adjacent cell and both consume a food source if available. If their energy level is below zero, an agent dies. Otherwise, the agent lives and reproduces with some probability.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"function agent_step!(sheep::Sheep, model)\n    move!(sheep, model)\n    sheep.energy -= 1\n    agents = get_node_agents(sheep.pos, model)\n    dinner = filter!(x -> isa(x, Grass), agents)\n    eat!(sheep, dinner, model)\n    if sheep.energy < 0\n        kill_agent!(sheep, model)\n        return\n    end\n    if rand() <= sheep.reproduction_prob\n        reproduce!(sheep, model)\n    end\nend\n\nfunction agent_step!(wolf::Wolf, model)\n    move!(wolf, model)\n    wolf.energy -= 1\n    agents = get_node_agents(wolf.pos, model)\n    dinner = filter!(x -> isa(x, Sheep), agents)\n    eat!(wolf, dinner, model)\n    if wolf.energy < 0\n        kill_agent!(wolf, model)\n        return\n    end\n    if rand() <= wolf.reproduction_prob\n        reproduce!(wolf, model)\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"The behavior of grass functions differently. If it is fully grown, it is consumable. Otherwise, it cannot be consumed until it regrows after a delay specified by regrowth_time.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"function agent_step!(grass::Grass, model)\n    if !grass.fully_grown\n        if grass.countdown <= 0\n            grass.fully_grown = true\n            grass.countdown = grass.regrowth_time\n        else\n            grass.countdown -= 1\n        end\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Sheep and wolves move to a random adjacent cell with the move! function.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"function move!(agent, model)\n    neighbors = node_neighbors(agent, model)\n    cell = rand(neighbors)\n    move_agent!(agent, cell, model)\nend\nnothing # hide","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Sheep and wolves have separate eat! functions. If a sheep eats grass, it will acquire additional energy and the grass will not be available for consumption until regrowth time has elapsed. If a wolf eats a sheep, the sheep dies and the wolf acquires more energy.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"function eat!(sheep::Sheep, grass_array, model)\n    isempty(grass_array) && return\n    grass = grass_array[1]\n    if grass.fully_grown\n        sheep.energy += sheep.Δenergy\n        grass.fully_grown = false\n    end\nend\n\nfunction eat!(wolf::Wolf, sheep, model)\n    if !isempty(sheep)\n        dinner = rand(sheep)\n        kill_agent!(dinner, model)\n        wolf.energy += wolf.Δenergy\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Sheep and wolves share a common reproduction method. Reproduction has a cost of 1/2 the current energy level of the parent. The offspring is an exact copy of the parent, with exception of id.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"function reproduce!(agent, model)\n    agent.energy /= 2\n    id = nextid(model)\n    A = typeof(agent)\n    offspring = A(id, agent.pos, agent.energy, agent.reproduction_prob, agent.Δenergy)\n    add_agent_pos!(offspring, model)\n    return\nend\nnothing # hide","category":"page"},{"location":"examples/predator_prey/#Running-the-model","page":"Predator-Prey","title":"Running the model","text":"","category":"section"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"We will run the model for 500 steps and record the number of sheep, wolves and consumable grass patches after each step. First: initialize the model.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Random.seed!(23182) # hide\nn_steps = 500\nmodel = initialize_model()","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"To view our starting population, we can build an overview plot:","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"offset(a::Sheep) = (0.2, 0.0)\noffset(a::Wolf) = (-0.2, 0.0)\noffset(a::Grass) = (0.0, 0.0)\nmshape(a::Sheep) = :circle\nmshape(a::Wolf) = :utriangle\nmshape(a::Grass) = :square\nmcolor(a::Sheep) = RGBA(1.0, 1.0, 1.0, 0.6)\nmcolor(a::Wolf) = RGBA(0.6, 0.6, 0.6, 0.8)\nmcolor(a::Grass) = cgrad([:brown, :green])[a.countdown / a.regrowth_time]\nplotabm(\n    model;\n    offset = offset,\n    am = mshape,\n    as = 15,\n    ac = mcolor,\n    scheduler = by_type((Grass, Sheep, Wolf), false),\n    grid = false,\n    size = (800, 600),\n    showaxis = false,\n    aspect_ratio = :equal,\n)","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Now, lets run the simulation and collect some data.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"sheep(a) = typeof(a) == Sheep\nwolves(a) = typeof(a) == Wolf\ngrass(a) = typeof(a) == Grass && a.fully_grown\nadata = [(sheep, count), (wolves, count), (grass, count)]\nresults, _ = run!(model, agent_step!, n_steps; adata = adata)","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"The plot shows the population dynamics over time. Initially, wolves become extinct because they consume the sheep too quickly. The few remaining sheep reproduce and gradually reach an equilibrium that can be supported by the amount of available grass.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"@df results plot(\n    :step,\n    :count_sheep,\n    grid = false,\n    xlabel = \"Step\",\n    ylabel = \"Population\",\n    label = \"Sheep\",\n)\n@df results plot!(:step, :count_wolves, label = \"Wolves\")\n@df results plot!(:step, :count_grass, label = \"Grass\")","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Altering the input conditions, we now see a landscape where all three agents find an equilibrium.","category":"page"},{"location":"examples/predator_prey/","page":"Predator-Prey","title":"Predator-Prey","text":"Random.seed!(7756) # hide\nmodel = initialize_model(\n    n_wolves = 20,\n    dims = (25, 25),\n    Δenergy_sheep = 5,\n    sheep_reproduce = 0.2,\n    wolf_reproduce = 0.08,\n)\nresults, _ = run!(model, agent_step!, n_steps; adata = adata)\n@df results plot(\n    :step,\n    :count_sheep,\n    grid = false,\n    xlabel = \"Step\",\n    ylabel = \"Population\",\n    label = \"Sheep\",\n)\n@df results plot!(:step, :count_wolves, label = \"Wolves\")\n@df results plot!(:step, :count_grass, label = \"Grass\")","category":"page"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/opinion_spread.jl\"","category":"page"},{"location":"examples/opinion_spread/#Opinion-spread","page":"Opinion spread","title":"Opinion spread","text":"","category":"section"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"(Image: )","category":"page"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"This is a simple model of how an opinion spreads through a community. Each individual has a number of opinions as a list of integers. They can change their opinion by changing the numbers in the list.","category":"page"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"Agents can change their opinion at each step. They choose one of their neighbors randomly, and adopt one of the neighbor's opinion. They are more likely to adopt their neighbors opinion if the share more opinions with each other.","category":"page"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"using Agents\nusing AgentsPlots\nusing Random","category":"page"},{"location":"examples/opinion_spread/#Building-the-model","page":"Opinion spread","title":"Building the model","text":"","category":"section"},{"location":"examples/opinion_spread/#.-Model-creation","page":"Opinion spread","title":"1. Model creation","text":"","category":"section"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"mutable struct Citizen <: AbstractAgent\n\tid::Int\n\tpos::Tuple{Int, Int}\n\tstabilized::Bool\n\topinion::Array{Int, 1}\n\tprev_opinion::Array{Int, 1}\nend\n\nfunction create_model(;dims=(10, 10), nopinions=3, levels_per_opinion=4)\n\tspace = GridSpace(dims, periodic=true, moore=true)\n\tproperties = Dict(:nopinions=>nopinions)\n\tmodel = AgentBasedModel(Citizen, space, scheduler=random_activation, properties=properties)\n\tfor cell in 1:nv(model)\n\t\tadd_agent!(cell, model, false, rand(1:levels_per_opinion, nopinions), rand(1:levels_per_opinion, nopinions))\n\tend\n\treturn model\nend","category":"page"},{"location":"examples/opinion_spread/#.-Stepping-functions","page":"Opinion spread","title":"2. Stepping functions","text":"","category":"section"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"function adopt!(agent, model)\n\tneighbor = rand(space_neighbors(agent, model))\n\tmatches = model[neighbor].opinion .== agent.opinion\n\tnmatches = count(matches)\n\tif nmatches < model.nopinions && rand() < nmatches/model.nopinions\n\t\tswitchId = rand(findall(x-> x==false, matches))\n\t\tagent.opinion[switchId] = model[neighbor].opinion[switchId]\n\tend\nend\n\nfunction update_prev_opinion!(agent, model)\n\tfor i in 1:model.nopinions\n\t\tagent.prev_opinion[i] = agent.opinion[i]\n\tend\nend\n\nfunction is_stabilized!(agent, model)\n\tif agent.prev_opinion == agent.opinion\n\t\tagent.stabilized = true\n\telse\n\t\tagent.stabilized = false\n\tend\nend\n\nfunction agent_step!(agent, model)\n\tupdate_prev_opinion!(agent, model)\n\tadopt!(agent, model)\n\tis_stabilized!(agent, model)\nend","category":"page"},{"location":"examples/opinion_spread/#Running-the-model","page":"Opinion spread","title":"Running the model","text":"","category":"section"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"levels_per_opinion=4\nmodel = create_model(nopinions=3,levels_per_opinion=levels_per_opinion)\n\n\"run the model until all agents stabilize\"\nrununtil(model, s) = count(getproperty.(values(model.agents), :stabilized)) == prod(model.space.dimensions)\n\nagentdata, _ = run!(model, agent_step!, dummystep, rununtil, adata=[(:stabilized, count)])","category":"page"},{"location":"examples/opinion_spread/#Plotting","page":"Opinion spread","title":"Plotting","text":"","category":"section"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"The plot shows the number of stable agents, that is, number of agents whose opinions don't change from one step to the next. Note that the number of stable agents can fluctuate before the final convergence.","category":"page"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"plot(1:size(agentdata, 1), agentdata.count_stabilized, legend=false, xlabel=\"generation\", ylabel=\"# of stabilized agents\")","category":"page"},{"location":"examples/opinion_spread/#Animation","page":"Opinion spread","title":"Animation","text":"","category":"section"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"Here is an animation that shows change of agent opinions over time. The first three opinions of an agent determines its color in RGB.","category":"page"},{"location":"examples/opinion_spread/","page":"Opinion spread","title":"Opinion spread","text":"levels_per_opinion = 3\nac(agent) = RGB((agent.opinion[1:3] ./ levels_per_opinion)...)\nmodel = create_model(nopinions=3, levels_per_opinion=levels_per_opinion)\nanim = @animate for sp in 1:500\n  step!(model, agent_step!)\n  p = plotabm(model, ac=ac, as=12, am=:square)\n  title!(p, \"Step $(sp)\")\n  if rununtil(model, 1)\n    break\n  end\nend\ngif(anim, \"opinion.gif\")","category":"page"},{"location":"interact/#Interactive-application","page":"Interactive application","title":"Interactive application","text":"","category":"section"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"The interactive application of Agents.jl is model-agnostic. This means that provided that the space of the model is one of the supported types (currently only 2D GridSpace or ContinuousSpace), the application does not care about the model dynamics or agent properties.","category":"page"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"The app is based on InteractiveChaos, another package of JuliaDynamics.","category":"page"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"Here is an example application","category":"page"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\n</video>","category":"page"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"the application is made with the following function:","category":"page"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"InteractiveChaos.interactive_abm","category":"page"},{"location":"interact/#InteractiveChaos.interactive_abm","page":"Interactive application","title":"InteractiveChaos.interactive_abm","text":"interactive_abm(model::ABM, agent_step!, model_step!, params=Dict(); kwargs...)\n\nOpen an interactive application for exploring an Agent-Based-Model. Requires Agents.\n\nThe application evolves an ABM interactively and plots its evolution, while allowing changing any of the model parameters interactively and also showing the evolution of collected data over time (if any are asked for, see below).\n\nmodel, agent_step!, model_step! are the same arguments that step! or run! from Agents accept.\n\nCalling interactive_abm returns: scene, agent_df, model_df. So you can save the scene, but you can also access the collected data (if any).\n\nInteraction\n\nButtons and sliders on the right-hand-side allow running/pausing the application. The slider sleep controls how much sleep time should occur after each plot update. The slider spu is the steps-per-update, i.e. how many times to step the model before updating the plot.\n\nThe final argument params is a dictionary and decides which parameters of the model will be configurable from the interactive application. Each entry of params is a pair of Symbol to an AbstractVector, and provides a range of possible values for the parameter named after the given symbol. Changing a value in the parameter slides is only updated into the actual model when pressing the \"update\" button.\n\nThe \"reset\" button resets the model to its original agent and space state but it updates it to the currently selected parameter values. A red vertical line is displayed in the data plots when resetting, for visual guidance.\n\nKeywords\n\nac, as, am: either constants, or functions each accepting an agent and outputting a valid value for the agent color, shape, or size.\nscheduler = model.scheduler: decides the plotting order of agents (which matters only if there is overlap).\noffset = nothing: Can be a function accepting an agent and returning an offset position that adjusts the agent's position when plotted (which matters only if there is overlap).\nadata, mdata: Same as the keyword arguments of Agents.run!, and decide which data of the model/agents will be collected and plotted below the interactive plot. Notice that data collection can only occur on plotted steps (and thus steps not plotted due to spu are also not data-collected).\nalabels, mlabels: If data are collected from agents or the model with adata, mdata, the corresponding plots have a y-label named after the collected data. Instead, you can give alabels, mlabels (vectors of strings with exactly same length as adata, mdata), and these labels will be used instead.\nwhen = true: When to perform data collection, as in Agents.run!.\nequalaspect = true: Set the ABM scatterplot's aspect ratio to equal.\nspu = 1:100: Values that the \"spu\" slider will obtain.\n\n\n\n\n\n","category":"function"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"The animation at the start of this page was done with:","category":"page"},{"location":"interact/","page":"Interactive application","title":"Interactive application","text":"using Agents, Random\nusing Makie\nusing InteractiveChaos\n\nmodel, agent_step!, model_step! = Models.forest_fire()\n\nalive(model) = count(a.status for a in allagents(model))\nburning(model) = count(!a.status for a in allagents(model))\nmdata = [alive, burning, nagents]\nmlabels = [\"alive\", \"burning\", \"total\"]\n\nparams = Dict(\n    :f => 0.02:0.01:1.0,\n    :p => 0.01:0.01:1.0,\n)\n\nac(a) = a.status ? \"#1f851a\" : \"#67091b\"\nam = :rect\n\np1 = interactive_abm(model, agent_step!, model_step!, params;\nac = ac, as = 1, am = am, mdata = mdata, mlabels=mlabels)","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/wealth_distribution.jl\"","category":"page"},{"location":"examples/wealth_distribution/#Wealth-distribution-model","page":"Wealth distribution","title":"Wealth distribution model","text":"","category":"section"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"This model is a simple agent-based economy that is modelled according to the work of Dragulescu et al.. This work introduces statistical mechanics concepts to study wealth distributions. What we show here is also referred to as \"Boltzmann wealth distribution\" model.","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"This model has a version with and without space. The rules of the space-less game are quite simple:","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"There is a pre-determined number of agents.\nAll agents start with one unit of wealth.\nAt every step an agent gives 1 unit of wealth (if they have it) to some other agent.","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"Even though this rule-set is simple, it can still recreate the basic properties of wealth distributions, e.g. power-laws distributions.","category":"page"},{"location":"examples/wealth_distribution/#Core-structures:-space-less","page":"Wealth distribution","title":"Core structures: space-less","text":"","category":"section"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"We start by defining the Agent type and initializing the model.","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"using Agents\nmutable struct WealthAgent <: AbstractAgent\n    id::Int\n    wealth::Int\nend","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"Notice that this agent does not have a pos field. That is okay, because there is no space structure to this example. We can also make a very simple AgentBasedModel for our model.","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"function wealth_model(; numagents = 100, initwealth = 1)\n    model = ABM(WealthAgent, scheduler = random_activation)\n    for i in 1:numagents\n        add_agent!(model, initwealth)\n    end\n    return model\nend\n\nmodel = wealth_model()","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"The next step is to define the agent step function","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"function agent_step!(agent, model)\n    agent.wealth == 0 && return # do nothing\n    ragent = random_agent(model)\n    agent.wealth -= 1\n    ragent.wealth += 1\nend\nnothing # hide","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"We use random_agent as a convenient way to just grab a second agent. (this may return the same agent as agent, but we don't care in the long run)","category":"page"},{"location":"examples/wealth_distribution/#Running-the-space-less-model","page":"Wealth distribution","title":"Running the space-less model","text":"","category":"section"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"Let's do some data collection, running a large model for a lot of time","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"N = 5\nM = 2000\nadata = [:wealth]\nmodel = wealth_model(numagents = M)\ndata, _ = run!(model, agent_step!, N; adata = adata)\ndata[(end - 20):end, :]","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"What we mostly care about is the distribution of wealth, which we can obtain for example by doing the following query:","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"wealths = filter(x -> x.step == N - 1, data)[!, :wealth]","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"and then we can make a histogram of the result. With a simple visualization we immediately see the power-law distribution:","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"using UnicodePlots\nUnicodePlots.histogram(wealths)","category":"page"},{"location":"examples/wealth_distribution/#Core-structures:-with-space","page":"Wealth distribution","title":"Core structures: with space","text":"","category":"section"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"We now expand this model to (in this case) a 2D grid. The rules are the same but agents exchange wealth only with their neighbors.","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"It is also available from the Models module as Models.wealth_distribution.","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"We therefore have to add a pos field as the second field of the agents:","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"mutable struct WealthInSpace <: AbstractAgent\n    id::Int\n    pos::NTuple{2,Int}\n    wealth::Int\nend\n\nfunction wealth_model_2D(; dims = (25, 25), wealth = 1, M = 1000)\n    space = GridSpace(dims, periodic = true)\n    model = ABM(WealthInSpace, space; scheduler = random_activation)\n    for i in 1:M # add agents in random nodes\n        add_agent!(model, wealth)\n    end\n    return model\nend\n\nmodel2D = wealth_model_2D()","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"The agent actions are a just a bit more complicated in this example. Now the agents can only give wealth to agents that exist on the same or neighboring nodes (their \"neighbors\").","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"function agent_step_2d!(agent, model)\n    agent.wealth == 0 && return # do nothing\n    agent_node = coord2vertex(agent.pos, model)\n    neighboring_nodes = node_neighbors(agent_node, model)\n    push!(neighboring_nodes, agent_node) # also consider current node\n    rnode = rand(neighboring_nodes) # the node that we will exchange with\n    available_ids = get_node_contents(rnode, model)\n    if length(available_ids) > 0\n        random_neighbor_agent = model[rand(available_ids)]\n        agent.wealth -= 1\n        random_neighbor_agent.wealth += 1\n    end\nend\nnothing # hide","category":"page"},{"location":"examples/wealth_distribution/#Running-the-model-with-space","page":"Wealth distribution","title":"Running the model with space","text":"","category":"section"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"using Random # hide\nRandom.seed!(5) # hide\ninit_wealth = 4\nmodel = wealth_model_2D(; wealth = init_wealth)\nadata = [:wealth, :pos]\ndata, _ = run!(model, agent_step!, 10; adata = adata, when = [1, 5, 9])\ndata[(end - 20):end, :]","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"Okay, now we want to get the 2D spatial wealth distribution of the model. That is actually straightforward:","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"using Plots\ngr() # hide\n\nfunction wealth_distr(data, model, n)\n    W = zeros(Int, size(model.space))\n    for row in eachrow(filter(r -> r.step == n, data)) # iterate over rows at a specific step\n        W[row.pos...] += row.wealth\n    end\n    return W\nend\n\nW1 = wealth_distr(data, model2D, 1)\nPlots.heatmap(W1)","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"W5 = wealth_distr(data, model2D, 5)\nPlots.heatmap(W5)","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"W10 = wealth_distr(data, model2D, 9)\nPlots.heatmap(W10)","category":"page"},{"location":"examples/wealth_distribution/","page":"Wealth distribution","title":"Wealth distribution","text":"What we see is that wealth gets more and more localized.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"EditURL = \"https://github.com/JuliaDynamics/Agents.jl/blob/master/examples/optim.jl\"","category":"page"},{"location":"examples/optim/#Optimizing-agent-based-models","page":"BlackBoxOptim","title":"Optimizing agent-based models","text":"","category":"section"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Sometimes we need to fine-tune our ABMs parameters to a specific outcome. The brute-force solution can quickly become infeasible for even for a few different parameter settings over a number of valid scan ranges. Most of the time, ABMs are also stochastic, so the effect of a parameter setting should be derived from taking the average value only after running the model several times.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Here we show how to use the evolutionary algorithms in BlackBoxOptim.jl with Agents.jl, to optimize the parameters of an epidemiological model (SIR). We explain this model in detail in SIR model for the spread of COVID-19. For brevity here, we just import","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"include(\"siroptim.jl\") # From the examples directory","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"which provides us a model_initiation helper function to build a SIR model, and an agent_step! function.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"include(joinpath(@__DIR__, \"../../../examples/siroptim.jl\")) #hide\nnothing #hide","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"To look for optimal parameters, we need to define a cost function. The cost function takes as arguments the model parameters that we want to tune; in a SIR model, that would be the migration rate, death rate, transmission rate, when an infected person has been detected (β_det), or when the remain undetected (β_und), infection period, reinfection probability, and time until the infection is detected. The function returns an objective: this value takes the form one or more numbers, which the optimiser will attempt to minimize.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"using BlackBoxOptim, Random\nusing Statistics: mean\n\nfunction cost(x)\n    model = model_initiation(;\n        Ns = [500, 500, 500],\n        migration_rate = x[1],\n        death_rate = x[2],\n        β_det = x[3],\n        β_und = x[4],\n        infection_period = x[5],\n        reinfection_probability = x[6],\n        detection_time = x[7],\n    )\n\n    infected_fraction(model) =\n        count(a.status == :I for a in allagents(model)) / nagents(model)\n\n    _, data = run!(\n        model,\n        agent_step!,\n        50;\n        mdata = [infected_fraction],\n        when_model = [50],\n        replicates = 10,\n    )\n\n    return mean(data.infected_fraction)\nend","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"This cost function runs our model 10 times for 50 days, then returns the average number of infected people. When we pass this function to an optimiser, we will effectively be asking for a set of parameters that can reduce the number of infected people to the lowest possible number.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"We can now test the function cost with some reasonable parameter values.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Random.seed!(10)\n\nx0 = [\n    0.2,  # migration_rate\n    0.1,  # death_rate\n    0.05, # β_det\n    0.3,  # β_und\n    10,   # infection_period\n    0.1,  # reinfection_probability\n    5,    # detection_time\n]\ncost(x0)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"With these initial values, 94% of the population is infected after the 50 day period.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"We now let the optimization algorithm change parameters to minimize the number of infected individuals. Complete details on how to use this optimiser can be found in the BlackBoxOptim readme. Here, we assign a range of possible parameter values we would like to test, and a cutoff time in the event that certain parameter sets are unfeasible and cause our model to never converge to a solution.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"result = bboptimize(\n    cost,\n    SearchRange = [\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (7.0, 13.0),\n        (0.0, 1.0),\n        (2.0, 6.0),\n    ],\n    NumDimensions = 7,\n    MaxTime = 20,\n)\nbest_fitness(result)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"With the new parameter values found in result, we find that the fraction of the infected population can be dropped down to 11%. These values of these parameters are now:","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"best_candidate(result)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Unfortunately we've not given the optimiser information we probably needed to. Notice that the death rate is 96%, with reinfection quite low. When all the infected individuals die, infection doesn't transmit - the optimiser has managed to reduce the infection rate by killing the infected.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"This is not the work of some sadistic AI, just an oversight in our instructions. Let's modify the cost function to also keep the mortality rate low.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"First, we'll run the model with our new-found parameters:","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"x = best_candidate(result)\n\nRandom.seed!(0)\n\nmodel = model_initiation(;\n    Ns = [500, 500, 500],\n    migration_rate = x[1],\n    death_rate = x[2],\n    β_det = x[3],\n    β_und = x[4],\n    infection_period = x[5],\n    reinfection_probability = x[6],\n    detection_time = x[7],\n)\n\n_, data =\n    run!(model, agent_step!, 50; mdata = [nagents], when_model = [50], replicates = 10)\n\nmean(data.nagents)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"About 10% of the population dies with these parameters over our 50 day window.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"We can define a multi-objective cost function that minimizes the number of infected and deaths by returning more than one value in our cost function.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"function cost_multi(x)\n    model = model_initiation(;\n        Ns = [500, 500, 500],\n        migration_rate = x[1],\n        death_rate = x[2],\n        β_det = x[3],\n        β_und = x[4],\n        infection_period = x[5],\n        reinfection_probability = x[6],\n        detection_time = x[7],\n    )\n\n    initial_size = nagents(model)\n\n    infected_fraction(model) =\n        count(a.status == :I for a in allagents(model)) / nagents(model)\n    n_fraction(model) = -1.0 * nagents(model) / initial_size\n\n    _, data = run!(\n        model,\n        agent_step!,\n        50;\n        mdata = [infected_fraction, n_fraction],\n        when_model = [50],\n        replicates = 10,\n    )\n\n    return mean(data.infected_fraction), mean(data.n_fraction)\nend","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Notice that our new objective n_fraction is negative. It would be simpler to state we'd like to 'maximise the living population', but the optimiser we're using here focuses on minimising objectives only, therefore we must 'minimise the number of agents dying'.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"cost_multi(x0)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"The cost of our initial parameter values is high: most of the population (96%) is infected and 22% die.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Let's minimize this multi-objective cost function. There is more than one way to approach such an optimisation. Again, refer to the BlackBoxOptim readme for specifics.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"result = bboptimize(\n    cost_multi,\n    Method = :borg_moea,\n    FitnessScheme = ParetoFitnessScheme{2}(is_minimizing = true),\n    SearchRange = [\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (0.0, 1.0),\n        (7.0, 13.0),\n        (0.0, 1.0),\n        (2.0, 6.0),\n    ],\n    NumDimensions = 7,\n    MaxTime = 55,\n)\nbest_fitness(result)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"best_candidate(result)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"These parameters look better: about 0.3% of the population dies and 0.02% are infected:","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"The algorithm managed to minimize the number of infected and deaths while still increasing death rate to 42%, reinfection probability to 53%, and migration rates to 33%. The most important change however, was decreasing the transmission rate when individuals are infected and undetected from 30% in our initial calculation, to 0.2%.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"Over a longer period of time than 50 days, that high death rate will take its toll though. Let's reduce that rate and check the cost.","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"x = best_candidate(result)\nx[2] = 0.02\ncost_multi(x)","category":"page"},{"location":"examples/optim/","page":"BlackBoxOptim","title":"BlackBoxOptim","text":"The fraction of infected increases to 0.04%. This is an interesting result: since this virus model is not as deadly, the chances of re-infection increase. We now have a set of parameters to strive towards in the real world. Insights such as these assist us to enact countermeasures like social distancing to mitigate infection risks.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Agents.jl)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Agents.jl is a Julia framework for agent-based modeling (ABM). Agents.jl is part of JuliaDynamics. To get started, please read the Tutorial page.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Latest news\nInteractive applications & predefined models!","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Intuitive, small, yet powerful and simple-to-learn API for agent based models.\nUniversal model structure where agents are identified by a unique id: AgentBasedModel\nSupport for many types of space: arbitrary graphs, regular grids, or continuous space.\nMulti-agent support, for interactions between disparate agent species.\nScheduler interface (with default schedulers), making it easy to activate agents in a specific order (e.g. by the value of some property)\nAutomatic data collection in a DataFrame at desired intervals\nAggregating collected data during model evolution\nDistributed computing\nBatch running and batch data collection\nVisualize agent distributions on regular grids, arbitrary graphs or continuous space.\nInteractive applications for any agent based model (in continuous or grid space), which are created with only 5 lines of code and look like this:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<video width=\"100%\" height=\"auto\" controls autoplay loop>\r\n<source src=\"https://raw.githubusercontent.com/JuliaDynamics/JuliaDynamics/master/videos/interact/agents.mp4?raw=true\" type=\"video/mp4\">\r\n</video>","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package is in Julia's package list. Install it using this command:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"]add Agents","category":"page"},{"location":"#Comparison-with-existing-software","page":"Introduction","title":"Comparison with existing software","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Many agent-based modeling frameworks have been constructed to ease the process of building and analyzing ABMs (see here for a review). Notable examples are NetLogo, Repast, MASON, and Mesa.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Implementing an ABM framework in Julia has several advantages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Using a general purpose programming language instead of a custom scripting language, such as NetLogo's, removes a learning step and provides a single environment for building the models and analyzing their results.\nJulia has a rich ecosystem for data analysis and visualization, implemented and maintained independently from Agents.jl.\nJulia is easier-to-use than Java (used for Repast and MASON), and provides a REPL (Read-Eval-Print-Loop) environment to build and analyze models interactively.\nUnlike Python (used for Mesa), Julia is fast to run. This is a crucial criterion for models that require considerable computations.\nBecause the direct output of Agents.jl is a DataFrame, it makes it easy to use tools such as DataVoyager.jl, which provide an interactive environment to build custom plots from DataFrames. (and of course the DataFrame itself is a tabular data format similar to Python's Pandas).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Agents.jl is lightweight and modular. It has a short learning curve, and allows one to extend its capabilities and express complicated modeling scenarios. Agents.jl was originally inspired by the Mesa framework for Python, but has since then departed in design, leading to a dramatically simpler and cleaner API and a shorter learning curve, besides having obvious performance benefits (more than 10 times better performance than Mesa, see our Agents.jl vs Mesa: speed comparison).","category":"page"},{"location":"#Crash-course-on-agent-based-modeling","page":"Introduction","title":"Crash course on agent based modeling","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"An agent-based (or individual-based) model is a computational simulation of autonomous agents that react to their environment (including other agents) given a predefined set of rules [1]. ABMs have been adopted and studied in a variety of research disciplines. One reason for their popularity is that they enable a relaxation of many simplifying assumptions usually made by mathematical models. Relaxing such assumptions of a \"perfect world\" can change a model's behavior [2].","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Agent-based models are increasingly recognized as the approach for studying complex systems [3,4,5,6]. Complex systems cannot be fully understood using traditional mathematical tools which aggregate the behavior of elements in a system. The behavior of a complex system depends on both the behavior of and interactions between its elements (agents). Small changes in the input to complex systems or the behavior of its agents can lead to large changes in outcome. That is to say, a complex system's behavior is nonlinear, and that it is not only the sum of the behavior of its elements. Use of ABMs have become feasible after the availability of computers and has been growing ever since, especially in modeling biological and economical systems, and has extended to social studies and archaeology.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An ABM consists of autonomous agents that behave given a set of rules. A classic example of an ABM is Schelling's segregation model, which we implement as an example here. This model uses a regular grid and defines agents as the cells of the grid. Agents can be from different social groups. Agents are happy/unhappy based on the fraction of their neighbors that belong to the same group as they are. If they are unhappy, they keep moving to new locations until they are happy. Schelling's model shows that even small preferences of agents to have neighbors belonging to the same group (e.g. preferring that at least 30% of neighbors to be in the same group) could lead to total segregation of neighborhoods. This is an example of emergent behavior from simple interactions of agents that can only be captured in an agent-based model.","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use this package in a publication, please cite the paper below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"R. Vahdati, Ali (2019). Agents.jl: agent-based modeling framework in Julia. Journal of Open Source Software, 4(42), 1611, https://doi.org/10.21105/joss.01611","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Agents.jl is composed of components for building models, building and managing space structures, collecting data, running batch simulations, and data visualization.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Agents.jl structures simulations in three components:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An AgentBasedModel instance.\nA space instance.\nA subtype of AbstractAgent for the agents.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To run simulations and collect data, the following are also necessary","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Stepping functions that controls how the agents and the model evolve.\nSpecifying which data should be collected from the agents and/or the model.","category":"page"},{"location":"tutorial/#.-The-model","page":"Tutorial","title":"1. The model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AgentBasedModel","category":"page"},{"location":"tutorial/#Agents.AgentBasedModel","page":"Tutorial","title":"Agents.AgentBasedModel","text":"AgentBasedModel(AgentType [, space]; scheduler, properties) → model\n\nCreate an agent based model from the given agent type and space. You can provide an agent instance instead of type, and the type will be deduced.  ABM is equivalent with AgentBasedModel.\n\nThe agents are stored in a dictionary that maps unique ids (integers) to agents. Use model[id] to get the agent with the given id.\n\nspace is a subtype of AbstractSpace: GraphSpace, GridSpace or ContinuousSpace. If it is ommited then all agents are virtually in one node and have no spatial structure.\n\nNote: Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.\n\nproperties = nothing is additional model-level properties (typically a dictionary) that can be accessed as model.properties. However, if properties is a dictionary with key type Symbol, or of it is a struct, then the syntax model.name is short hand for model.properties[:name] (or model.properties.name for structs). This syntax can't be used for name being agents, space, scheduler, properties, which are the fields of AgentBasedModel.\n\nscheduler = fastest decides the order with which agents are activated (see e.g. by_id and the scheduler API).\n\nType tests for AgentType are done, and by default warnings are thrown when appropriate. Use keyword warn=false to supress that.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Space","page":"Tutorial","title":"2. The space","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Agents.jl offers several possibilities for the space the agents live in, separated into discrete and continuous categories (notice that using a space is not actually necessary).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The discrete possibilities, often summarized as DiscreteSpace, are","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"GraphSpace\nGridSpace","category":"page"},{"location":"tutorial/#Agents.GraphSpace","page":"Tutorial","title":"Agents.GraphSpace","text":"GraphSpace(graph::AbstractGraph)\n\nCreate a GraphSpace instance that is underlined by an arbitrary graph from LightGraphs.jl. In this case, your agent type must have a pos field that is of type Int.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#Agents.GridSpace","page":"Tutorial","title":"Agents.GridSpace","text":"GridSpace(dims::NTuple; periodic = false, moore = false) → GridSpace\n\nCreate a GridSpace instance that represents a grid of dimensionality length(dims), with each dimension having the size of the corresponding entry of dims. Such grids are typically used in cellular-automata-like models. In this case, your agent type must have a pos field that is of type NTuple{N, Int}, where N is the number of dimensions.\n\nThe two keyword arguments denote if the grid should be periodic on its ends, and if the connections should be of type Moore or not (in the Moore case the diagonal connections are also valid. E.g. for a 2D grid, each node has 8 neighbors).\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and the continuous version is","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ContinuousSpace","category":"page"},{"location":"tutorial/#Agents.ContinuousSpace","page":"Tutorial","title":"Agents.ContinuousSpace","text":"ContinuousSpace(D::Int [, update_vel!]; kwargs...)\n\nCreate a ContinuousSpace of dimensionality D. In this case, your agent positions (field pos) should be of type NTuple{D, F} where F <: AbstractFloat. In addition, the agent type should have a third field vel::NTuple{D, F} representing the agent's velocity to use move_agent!.\n\nThe optional argument update_vel! is a function, update_vel!(agent, model) that updates the agent's velocity before the agent has been moved, see move_agent!. You can of course change the agents' velocities during the agent interaction, the update_vel! functionality targets arbitrary force fields acting on the agents (e.g. some magnetic field). By default no update is done this way.\n\nNotice that if you need to write your own custom move_agent function, call update_space! at the end, like in e.g. the Bacterial Growth example.\n\nKeywords\n\nperiodic = true : whether continuous space is periodic or not\nextend::NTuple{D} = ones : Extend of space. The d dimension starts at 0 and ends at extend[d]. If periodic = true, this is also when periodicity occurs. If periodic ≠ true, extend is only used at plotting.\nmetric = :cityblock : metric that configures distances for finding nearest neighbors in the space. The other option is :euclidean but cityblock is faster (due to internals).\n\nNote: if your model requires linear algebra operations for which tuples are not supported, a performant solution is to convert between Tuple and SVector using StaticArrays.jl as follows: s = SVector(t) and back with t = Tuple(s).\n\n\n\n\n\n","category":"type"},{"location":"tutorial/#.-The-agent","page":"Tutorial","title":"3. The agent","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"AbstractAgent","category":"page"},{"location":"tutorial/#Agents.AbstractAgent","page":"Tutorial","title":"Agents.AbstractAgent","text":"All agents must be a mutable subtype of AbstractAgent. Your agent type must have the id field as first field. Depending on the space structure there might be a pos field of appropriate type and a vel field of appropriate type.\n\nYour agent type may have other additional fields relevant to your system, for example variable quantities like \"status\" or other \"counters\".\n\nExamples\n\nImagine agents who have extra properties weight, happy. For a GraphSpace we would define them like\n\nmutable struct ExampleAgent <: AbstractAgent\n    id::Int\n    pos::Int\n    weight::Float64\n    happy::Bool\nend\n\nwhile for e.g. a ContinuousSpace we would use\n\nmutable struct ExampleAgent <: AbstractAgent\n    id::Int\n    pos::NTuple{2, Float64}\n    vel::NTuple{2, Float64}\n    weight::Float64\n    happy::Bool\nend\n\nwhere vel is optional, useful if you want to use move_agent! in continuous space.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The agent type must be mutable. Once an Agent is created it can be added to a model using e.g. add_agent!. Then, the agent can interact with the model and the space further by using e.g. move_agent! or kill_agent!.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For more functions visit the API page.","category":"page"},{"location":"tutorial/#.-Evolving-the-model","page":"Tutorial","title":"4. Evolving the model","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Any ABM model should have at least one and at most two step functions. An agent step function is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a model step function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"An agent step function should only accept two arguments: first, an agent object, and second, a model object.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in dummystep as the agent step function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"After you have defined these two functions, you evolve your model with step!:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"step!\ndummystep","category":"page"},{"location":"tutorial/#Agents.step!","page":"Tutorial","title":"Agents.step!","text":"step!(model, agent_step!, n::Int = 1)\nstep!(model, agent_step!, model_step!, n::Int = 1, agents_first::Bool=true)\n\nUpdate agents n steps according to the stepping function agent_step!. Agents will be activated as specified by the model.scheduler. model_step! is triggered after every scheduled agent has acted, unless the argument agents_first is false (which then first calls model_step! and then activates the agents).\n\nstep!(model, agent_step!, model_step!, n::Function, agents_first::Bool=true)\n\nIn this version n is a function. Then step! runs the model until n(model, s) returns true, where s is the current amount of steps taken, starting from 0. For this method of step!, model_step! must be provided always (use dummystep if you have no model stepping dynamics).\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Agents.dummystep","page":"Tutorial","title":"Agents.dummystep","text":"dummystep(model)\n\nIgnore the model dynamics. Use instead of model_step!.\n\n\n\n\n\ndummystep(agent, model)\n\nIgnore the agent dynamics. Use instead of agent_step!.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#.-Collecting-data","page":"Tutorial","title":"5. Collecting data","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Running the model and collecting data while the model runs is done with the run! function. Besides run!, there is also the paramscan function that performs data collection, while scanning ranges of the parameters of the model.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"run!","category":"page"},{"location":"tutorial/#Agents.run!","page":"Tutorial","title":"Agents.run!","text":"run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df\nrun!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df\n\nRun the model (step it with the input arguments propagated into step!) and collect data specified by the keywords, explained one by one below. Return the data as two DataFrames, one for agent-level data and one for model-level data.\n\nData-deciding keywords\n\nadata::Vector means \"agent data to collect\". If an entry is a Symbol, e.g. :weight, then the data for this entry is agent's field weight. If an entry is a Function, e.g. f, then the data for this entry is just f(a) for each agent a. The resulting dataframe columns are named with the input symbol (here :weight, :f).\nadata::Vector{<:Tuple}: if adata is a vector of tuples instead, data aggregation is done over the agent properties.\nFor each 2-tuple, the first entry is the \"key\" (any entry like the ones mentioned above, e.g. :weight, f). The second entry is an aggregating function that aggregates the key, e.g. mean, maximum. So, continuing from the above example, we would have adata = [(:weight, mean), (f, maximum)].\nIt's also possible to provide a 3-tuple, with the third entry being a conditional function (returning a Bool), which assesses if each agent should be included in the aggregate. For example: x_pos(a) = a.pos[1]>5 with (:weight, mean, x_pos) will result in the average weight of agents conditional on their x-position being greater than 5.\nThe resulting data name columns use the function aggname, and create something like :mean_weight or :maximum_f_x_pos. This name doesn't play well with anonymous functions!\nNotice: Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. E.g. instead of passing mean, pass mymean(a) = isempty(a) ? 0.0 : mean(a).\nmdata::Vector means \"model data to collect\" and works exactly like adata. For the model, no aggregation is possible (nothing to aggregate over).\n\nBy default both keywords are nothing, i.e. nothing is collected/aggregated.\n\nOther keywords\n\nwhen=true : at which steps s to perform the data collection and processing. A lot of flexibility is offered based on the type of when. If when::Vector, then data are collect if s ∈ when. Otherwise data are collected if when(model, s) returns true. By default data are collected in every step.\nwhen_model = when : same as when but for model data.\nobtainer = identity : method to transfer collected data to the DataFrame. Typically only change this to copy if some data are mutable containers (e.g. Vector) which change during evolution, or deepcopy if some data are nested mutable containers. Both of these options have performance penalties.\nreplicates=0 : Run replicates replicates of the simulation.\nparallel=false : Only when replicates>0. Run replicate simulations in parallel.\nagents_first=true : Whether to update agents first and then the model, or vice versa.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The run! function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregating model data, or arbitrary combinations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This means that run! has not been designed for maximum performance (or minimum memory allocation). However, we also expose a simple data-collection API (see Data collection), that gives users even more flexibility, allowing them to make their own \"data collection loops\" arbitrarily calling step! and collecting data as needed and to the data structure that they need.","category":"page"},{"location":"tutorial/#An-educative-example","page":"Tutorial","title":"An educative example","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A simple, education-oriented example of using the basic Agents.jl API is given in Schelling's segregation model, also discussing in detail how to visualize your ABMs.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Each of the examples listed within this documentation are designed to showcase different ways of interacting with the API. If you are not sure about how to use a particular function, most likely one of the examples can show you how to interact with it.","category":"page"}]
}
