<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-Prey</a></li><li><a class="tocitem" href="../examples/growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../examples/opinion_spread/">Opinion spread</a></li></ul></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Agent-information-and-retrieval"><span>Agent information and retrieval</span></a></li><li><a class="tocitem" href="#Model-Agent-interaction"><span>Model-Agent interaction</span></a></li><li><a class="tocitem" href="#Discrete-space-exclusives"><span>Discrete space exclusives</span></a></li><li><a class="tocitem" href="#Continuous-space-exclusives"><span>Continuous space exclusives</span></a></li><li><a class="tocitem" href="#Data-collection"><span>Data collection</span></a></li><li><a class="tocitem" href="#Schedulers"><span>Schedulers</span></a></li><li><a class="tocitem" href="#Plotting"><span>Plotting</span></a></li></ul></li><li><a class="tocitem" href="../interact/">Interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim</a></li></ul></li><li><a class="tocitem" href="../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>The core API is defined by <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>, <a href="../tutorial/#Space">Space</a>, <a href="../tutorial/#Agents.AbstractAgent"><code>AbstractAgent</code></a> and <a href="../tutorial/#Agents.step!"><code>step!</code></a>, which are described in the <a href="../tutorial/#Tutorial">Tutorial</a> page. The functionality described here builds on top of the core API.</p><h2 id="Agent-information-and-retrieval"><a class="docs-heading-anchor" href="#Agent-information-and-retrieval">Agent information and retrieval</a><a id="Agent-information-and-retrieval-1"></a><a class="docs-heading-anchor-permalink" href="#Agent-information-and-retrieval" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.space_neighbors" href="#Agents.space_neighbors"><code>Agents.space_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">space_neighbors(position, model::ABM, r) → ids</code></pre><p>Return the ids of the agents neighboring the given <code>position</code> (which must match type with the spatial structure of the <code>model</code>). <code>r</code> is the radius to search for agents.</p><p>For <code>DiscreteSpace</code> <code>r</code> must be integer and defines higher degree neighbors. For example, for <code>r=2</code> include first and second degree neighbors, that is, neighbors and neighbors of neighbors. Specifically for <code>GraphSpace</code>, the keyword <code>neighbor_type</code> can also be used as in <a href="#Agents.node_neighbors"><code>node_neighbors</code></a> to restrict search on directed graphs.</p><p>For <code>ContinuousSpace</code>, <code>r</code> is real number and finds all neighbors within distance <code>r</code> (based on the space&#39;s metric).</p><pre><code class="language-none">space_neighbors(agent::AbstractAgent, model::ABM [, r]) → ids</code></pre><p>Call <code>space_neighbors(agent.pos, model, r)</code> but <em>exclude</em> the given <code>agent</code> from the neighbors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L365-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_agent" href="#Agents.random_agent"><code>Agents.random_agent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_agent(model)</code></pre><p>Return a random agent from the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/model.jl#L237-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nagents" href="#Agents.nagents"><code>Agents.nagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nagents(model::ABM)</code></pre><p>Return the number of agents in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/model.jl#L243-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allagents" href="#Agents.allagents"><code>Agents.allagents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allagents(model)</code></pre><p>Return an iterator over all agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/model.jl#L249-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.allids" href="#Agents.allids"><code>Agents.allids</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allids(model)</code></pre><p>Return an iterator over all agent IDs of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/model.jl#L256-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nextid" href="#Agents.nextid"><code>Agents.nextid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nextid(model::ABM) → id</code></pre><p>Return a valid <code>id</code> for creating a new agent with it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L242-L245">source</a></section></article><h2 id="Model-Agent-interaction"><a class="docs-heading-anchor" href="#Model-Agent-interaction">Model-Agent interaction</a><a id="Model-Agent-interaction-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Agent-interaction" title="Permalink"></a></h2><p>The following API is mostly universal across all types of <a href="../tutorial/#Space">Space</a>. Only some specific methods are exclusive to a specific type of space, but we think this is clear from the documentation strings (if not, please open an issue!).</p><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent!" href="#Agents.add_agent!"><code>Agents.add_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent!(agent::AbstractAgent [, position], model::ABM) → agent</code></pre><p>Add the <code>agent</code> to the <code>position</code> in the space and to the list of agents. If <code>position</code> is not given, the <code>agent</code> is added to a random position. The <code>agent</code>&#39;s position is always updated to match <code>position</code>, and therefore for <code>add_agent!</code> the position of the <code>agent</code> is meaningless. Use <a href="#Agents.add_agent_pos!"><code>add_agent_pos!</code></a> to use the <code>agent</code>&#39;s position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L149-L157">source</a></section><section><div><pre><code class="language-none">add_agent!([pos,] model::ABM, args...; kwargs...)</code></pre><p>Create and add a new agent to the model by constructing an agent of the type of the <code>model</code>. Propagate all <em>extra</em> positional arguments and keyword arguemts to the agent constructor.</p><p>Notice that this function takes care of setting the agent&#39;s id <em>and</em> position and thus <code>args...</code> and <code>kwargs...</code> are propagated to other fields the agent has.</p><p>Optionally provide a position to add the agent to as <em>first argument</em>.</p><p><strong>Example</strong></p><pre><code class="language-julia">using Agents
mutable struct Agent &lt;: AbstractAgent
    id::Int
    pos::Int
    w::Float64
    k::Bool
end
Agent(id, pos; w, k) = Agent(id, pos, w, k) # keyword constructor
model = ABM(Agent, GraphSpace(complete_digraph(5)))

add_agent!(model, 1, 0.5, true) # incorrect: id/pos is set internally
add_agent!(model, 0.5, true) # correct: w becomes 0.5
add_agent!(5, model, 0.5, true) # add at node 5, w becomes 0.5
add_agent!(model; w = 0.5, k = true) # use keywords: w becomes 0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L186-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_pos!" href="#Agents.add_agent_pos!"><code>Agents.add_agent_pos!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_pos!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Add the agent to the <code>model</code> at the agent&#39;s own position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L133-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.add_agent_single!" href="#Agents.add_agent_single!"><code>Agents.add_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_agent_single!(agent::A, model::ABM{A, &lt;: DiscreteSpace}) → agent</code></pre><p>Add agent to a random node in the space while respecting a maximum one agent per node. This function throws a warning if no empty nodes remain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L248-L253">source</a></section><section><div><pre><code class="language-none">add_agent_single!(model::ABM{A, &lt;: DiscreteSpace}, properties...; kwargs...)</code></pre><p>Same as <code>add_agent!(model, properties...)</code> but ensures that it adds an agent into a node with no other agents (does nothing if no such node exists).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L264-L268">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent!" href="#Agents.move_agent!"><code>Agents.move_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent!(agent::A, model::ABM{A, ContinuousSpace}, dt = 1.0)</code></pre><p>Propagate the agent forwards one step according to its velocity, <em>after</em> updating the agent&#39;s velocity (see <a href="../tutorial/#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>). Also take care of periodic boundary conditions.</p><p>For this continuous space version of <code>move_agent!</code>, the &quot;evolution algorithm&quot; is a trivial Euler scheme with <code>dt</code> the step size, i.e. the agent position is updated as <code>agent.pos += agent.vel * dt</code>.</p><p>Notice that if you want the agent to instantly move to a specified position, do <code>agent.pos = pos</code> and then <code>update_space!(agent, model)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L161-L173">source</a></section><section><div><pre><code class="language-none">move_agent!(agent::A, model::ABM{A, ContinuousSpace}, vel::NTuple{D, N}, dt = 1.0)</code></pre><p>Propagate the agent forwards one step according to <code>vel</code> and the model&#39;s space, with <code>dt</code> as the time step. (<code>update_vel!</code> is not used)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L184-L187">source</a></section><section><div><pre><code class="language-none">move_agent!(agent::A [, pos], model::ABM{A, &lt;: DiscreteSpace}) → agent</code></pre><p>Move agent to the given position, or to a random one if a position is not given. <code>pos</code> must be the appropriate position type depending on the space type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L71-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.move_agent_single!" href="#Agents.move_agent_single!"><code>Agents.move_agent_single!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">move_agent_single!(agent::AbstractAgent, model::ABM) → agent</code></pre><p>Move agent to a random node while respecting a maximum of one agent per node. If there are no empty nodes, the agent wont move. Only valid for non-continuous spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.kill_agent!" href="#Agents.kill_agent!"><code>Agents.kill_agent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">kill_agent!(agent::AbstractAgent, model::ABM)</code></pre><p>Remove an agent from model, and from the space if the model has a space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.genocide!" href="#Agents.genocide!"><code>Agents.genocide!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">genocide!(model::ABM)</code></pre><p>Kill all the agents of the model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L40-L43">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, n::Int)</code></pre><p>Kill the agents of the model whose IDs are larger than n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L50-L53">source</a></section><section><div><pre><code class="language-none">genocide!(model::ABM, f::Function)</code></pre><p>Kill all agents where the function <code>f(agent)</code> returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L59-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.sample!" href="#Agents.sample!"><code>Agents.sample!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sample!(model::ABM, n [, weight]; kwargs...)</code></pre><p>Replace the agents of the <code>model</code> with a random sample of the current agents with size <code>n</code>.</p><p>Optionally, provide a <code>weight</code>: Symbol (agent field) or function (input agent out put number) to weight the sampling. This means that the higher the <code>weight</code> of the agent, the higher the probability that this agent will be chosen in the new sampling.</p><p><strong>Keywords</strong></p><ul><li><code>replace = true</code> : whether sampling is performed with replacement, i.e. all agents can</li></ul><p>be chosen more than once.</p><ul><li><code>rng = GLOBAL_RNG</code> : a random number generator to perform the sampling with.</li></ul><p>See the Wright-Fisher example in the documentation for an application of <code>sample!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/sample.jl#L4-L21">source</a></section></article><h2 id="Discrete-space-exclusives"><a class="docs-heading-anchor" href="#Discrete-space-exclusives">Discrete space exclusives</a><a id="Discrete-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Discrete-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.fill_space!" href="#Agents.fill_space!"><code>Agents.fill_space!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fill_space!([A ,] model::ABM{A, &lt;:DiscreteSpace}, args...; kwargs...)
fill_space!([A ,] model::ABM{A, &lt;:DiscreteSpace}, f::Function; kwargs...)</code></pre><p>Add one agent to each node in the model&#39;s space. Similarly with <a href="#Agents.add_agent!"><code>add_agent!</code></a>, the function creates the necessary agents and the <code>args...; kwargs...</code> are propagated into agent creation. If instead of <code>args...</code> a function <code>f</code> is provided, then <code>args = f(pos)</code> is the result of applying <code>f</code> where <code>pos</code> is each position (tuple for grid, node index for graph).</p><p>An optional first argument is an agent <strong>type</strong> to be created, and targets mixed-agent models where the agent constructor cannot be deduced (since it is a union).</p><p><strong>Example</strong></p><pre><code class="language-julia">using Agents
mutable struct Daisy &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int, Int}
    breed::String
end
mutable struct Land &lt;: AbstractAgent
    id::Int
    pos::Tuple{Int, Int}
    temperature::Float64
end
space = GridSpace((10, 10), moore = true, periodic = true)
model = ABM(Union{Daisy, Land}, space)
temperature(pos) = (pos[1]/10, ) # make it Tuple!
fill_space!(Land, model, temperature)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/agent_space_interaction.jl#L280-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.node_neighbors" href="#Agents.node_neighbors"><code>Agents.node_neighbors</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">node_neighbors(node, model::ABM{A, &lt;:DiscreteSpace}, r = 1) → nodes</code></pre><p>Return all nodes that are neighbors to the given <code>node</code>, which can be an <code>Int</code> for <a href="../tutorial/#Agents.GraphSpace"><code>GraphSpace</code></a>, or a <code>NTuple{Int}</code> for <a href="../tutorial/#Agents.GridSpace"><code>GridSpace</code></a>. Use <a href="#Agents.vertex2coord"><code>vertex2coord</code></a> to convert nodes to positions for <code>GridSpace</code>.</p><pre><code class="language-none">node_neighbors(agent, model::ABM{A, &lt;:DiscreteSpace}, r = 1) → nodes</code></pre><p>Same as above, but uses <code>agent.pos</code> as <code>node</code>.</p><p>Keyword argument <code>neighbor_type=:default</code> can be used to select differing neighbors depending on the underlying graph directionality type.</p><ul><li><code>:default</code> returns neighbors of a vertex. If graph is directed, this is equivalent</li></ul><p>to <code>:out</code>. For undirected graphs, all options are equivalent to <code>:out</code>.</p><ul><li><code>:all</code> returns both <code>:in</code> and <code>:out</code> neighbors.</li><li><code>:in</code> returns incoming vertex neighbors.</li><li><code>:out</code> returns outgoing vertex neighbors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L399-L415">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.nv-Tuple{AgentBasedModel}" href="#LightGraphs.nv-Tuple{AgentBasedModel}"><code>LightGraphs.nv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nv(model::ABM)</code></pre><p>Return the number of nodes (vertices) in the <code>model</code> space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L14-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LightGraphs.ne-Tuple{AgentBasedModel}" href="#LightGraphs.ne-Tuple{AgentBasedModel}"><code>LightGraphs.ne</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ne(model::ABM)</code></pre><p>Return the number of edges in the <code>model</code> space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L20-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.has_empty_nodes" href="#Agents.has_empty_nodes"><code>Agents.has_empty_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">has_empty_nodes(model)</code></pre><p>Return true if there are empty nodes in the <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L327-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.find_empty_nodes" href="#Agents.find_empty_nodes"><code>Agents.find_empty_nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_empty_nodes(model::ABM)</code></pre><p>Returns the indices of empty nodes on the model space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.pick_empty" href="#Agents.pick_empty"><code>Agents.pick_empty</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pick_empty(model)</code></pre><p>Return a random empty node or <code>0</code> if there are no empty nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L316-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.get_node_contents" href="#Agents.get_node_contents"><code>Agents.get_node_contents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_node_contents(node, model)</code></pre><p>Return the ids of agents in the <code>node</code> of the model&#39;s space (which is an integer for <code>GraphSpace</code> and a tuple for <code>GridSpace</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L336-L341">source</a></section><section><div><pre><code class="language-none">get_node_contents(agent::AbstractAgent, model)</code></pre><p>Return all agents&#39; ids in the same node as the <code>agent</code> (including the agent&#39;s own id).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L344-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.get_node_agents" href="#Agents.get_node_agents"><code>Agents.get_node_agents</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_node_agents(x, model)</code></pre><p>Same as <code>get_node_contents(x, model)</code> but directly returns the list of agents instead of just the list of IDs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isempty-Tuple{Integer,AgentBasedModel}" href="#Base.isempty-Tuple{Integer,AgentBasedModel}"><code>Base.isempty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isempty(node::Int, model::ABM)</code></pre><p>Return <code>true</code> if there are no agents in <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L44-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.NodeIterator" href="#Agents.NodeIterator"><code>Agents.NodeIterator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NodeIterator(model) → iterator</code></pre><p>Create an iterator that returns node coordinates, if the space is a grid, or otherwise node number, and the agent IDs in each node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L473-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nodes" href="#Agents.nodes"><code>Agents.nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nodes(model; by = :id) -&gt; ns</code></pre><p>Return a vector of the node ids of the <code>model</code> that you can iterate over. The <code>ns</code> are sorted depending on <code>by</code>:</p><ul><li><code>:id</code> - just sorted by their number</li><li><code>:random</code> - randomly sorted</li><li><code>:population</code> - nodes are sorted depending on how many agents they accommodate. The more populated nodes are first.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L504-L512">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.coord2vertex" href="#Agents.coord2vertex"><code>Agents.coord2vertex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coord2vertex(coord::NTuple{Int}, model_or_space) → n
coord2vertex(coord::AbstractAgent, model_or_space) → n</code></pre><p>Return the node number <code>n</code> of the given coordinates or the agent&#39;s position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L233-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.vertex2coord" href="#Agents.vertex2coord"><code>Agents.vertex2coord</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vertex2coord(vertex::Integer, model_or_space) → coords</code></pre><p>Returns the coordinates of a node given its number on the graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L267-L271">source</a></section></article><h2 id="Continuous-space-exclusives"><a class="docs-heading-anchor" href="#Continuous-space-exclusives">Continuous space exclusives</a><a id="Continuous-space-exclusives-1"></a><a class="docs-heading-anchor-permalink" href="#Continuous-space-exclusives" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.interacting_pairs" href="#Agents.interacting_pairs"><code>Agents.interacting_pairs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">interacting_pairs(model, r, method; scheduler = model.scheduler)</code></pre><p>Return an iterator that yields unique pairs of agents <code>(a1, a2)</code> that are close neighbors to each other, within some interaction radius <code>r</code>.</p><p>This function is usefully combined with <code>model_step!</code>, when one wants to perform some pairwise interaction across all pairs of close agents once (and does not want to trigger the event twice, both with <code>a1</code> and with <code>a2</code>, which is unavoidable when using <code>agent_step!</code>).</p><p>The argument <code>method</code> provides three pairing scenarios</p><ul><li><code>:all</code>: return every pair of agents that are within radius <code>r</code> of each other, not only the nearest ones.</li><li><code>:nearest</code>: agents are only paired with their true nearest neighbor (existing within radius <code>r</code>). Each agent can only belong to one pair, therefore if two agents share the same nearest neighbor only one of them (sorted by id) will be paired.</li><li><code>:scheduler</code>: agents are scanned according to the given keyword <code>scheduler</code> (by default the model&#39;s scheduler), and each scanned agent is paired to its nearest neighbor. Similar to <code>:nearest</code>, each agent can belong to only one pair. This functionality is useful e.g. when you want some agents to be paired &quot;guaranteed&quot;, even if some other agents might be nearest to each other.</li><li><code>:types</code>: For mixed agent models only. Return every pair of agents within radius <code>r</code> (similar to <code>:all</code>), only capturing pairs of differing types. For example, a model of <code>Union{Sheep,Wolf}</code> will only return pairs of <code>(Sheep, Wolf)</code>. In the case of multiple agent types, <em>e.g.</em> <code>Union{Sheep, Wolf, Grass}</code>, skipping pairings that involve <code>Grass</code>, can be achived by a <a href="#Schedulers"><code>scheduler</code></a> that doesn&#39;t schedule <code>Grass</code> types, <em>i.e.</em>: <code>scheduler = [a.id for a in allagents(model) of !(a isa Grass)]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L349-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.nearest_neighbor" href="#Agents.nearest_neighbor"><code>Agents.nearest_neighbor</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearest_neighbor(agent, model, r) → nearest</code></pre><p>Return the agent that has the closest distance to given <code>agent</code>, according to the space&#39;s metric. Valid only in continuous space. Return <code>nothing</code> if no agent is within distance <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L272-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.elastic_collision!" href="#Agents.elastic_collision!"><code>Agents.elastic_collision!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elastic_collision!(a, b, f = nothing)</code></pre><p>Resolve a (hypothetical) elastic collision between the two agents <code>a, b</code>. They are assumed to be disks of equal size touching tangentially. Their velocities (field <code>vel</code>) are adjusted for an elastic collision happening between them. This function works only for two dimensions. Notice that collision only happens if both disks face each other, to avoid collision-after-collision.</p><p>If <code>f</code> is a <code>Symbol</code>, then the agent property <code>f</code>, e.g. <code>:mass</code>, is taken as a mass to weight the two agents for the collision. By default no weighting happens.</p><p>One of the two agents can have infinite &quot;mass&quot;, and then acts as an immovable object that specularly reflects the other agent. In this case of course momentum is not conserved, but kinetic energy is still conserved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L298-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.index!" href="#Agents.index!"><code>Agents.index!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">index!(model)</code></pre><p>Index the database underlying the <code>ContinuousSpace</code> of the model.</p><p>This can drastically improve performance for finding neighboring agents, but adding new data can become slower because after each addition, index needs to be called again.</p><p>Lack of index won&#39;t be noticed for small databases. Only use it when you have many agents and not many additions of agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L108-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.update_space!" href="#Agents.update_space!"><code>Agents.update_space!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_space!(model::ABM{A, ContinuousSpace}, agent)</code></pre><p>Update the internal representation of continuous space to match the new position of the agent (useful in custom <code>move_agent</code> functions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L197-L201">source</a></section></article><h2 id="Data-collection"><a class="docs-heading-anchor" href="#Data-collection">Data collection</a><a id="Data-collection-1"></a><a class="docs-heading-anchor-permalink" href="#Data-collection" title="Permalink"></a></h2><p>The central simulation function is <a href="../tutorial/#Agents.run!"><code>run!</code></a>, which is mentioned in our <a href="../tutorial/#Tutorial">Tutorial</a>. But there are other functions that are related to simulations listed here.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.init_agent_dataframe" href="#Agents.init_agent_dataframe"><code>Agents.init_agent_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_agent_dataframe(model, adata) → agent_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/collect.jl#L136-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_agent_data!" href="#Agents.collect_agent_data!"><code>Agents.collect_agent_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_agent_data!(df, model, properties, step = 0; obtainer = identity)</code></pre><p>Collect and add agent data into <code>df</code> (see <a href="../tutorial/#Agents.run!"><code>run!</code></a> for the dispatch rules of <code>properties</code> and <code>obtainer</code>). <code>step</code> is given because the step number information is not known.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/collect.jl#L142-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.init_model_dataframe" href="#Agents.init_model_dataframe"><code>Agents.init_model_dataframe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">init_model_dataframe(model, mdata) → model_df</code></pre><p>Initialize a dataframe to add data later with <a href="#Agents.collect_model_data!"><code>collect_model_data!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/collect.jl#L246-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.collect_model_data!" href="#Agents.collect_model_data!"><code>Agents.collect_model_data!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_model_data!(df, model, properties, step = 0, obtainer = identity)</code></pre><p>Same as <a href="#Agents.collect_agent_data!"><code>collect_agent_data!</code></a> but for model data instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/collect.jl#L273-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.aggname" href="#Agents.aggname"><code>Agents.aggname</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">aggname(k) → name
aggname(k, agg) → name
aggname(k, agg, condition) → name</code></pre><p>Return the name of the column of the <code>i</code>-th collected data where <code>k = adata[i]</code> (or <code>mdata[i]</code>). <code>aggname</code> also accepts tuples with aggregate and conditional values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/collect.jl#L207-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.paramscan" href="#Agents.paramscan"><code>Agents.paramscan</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">paramscan(parameters, initialize; kwargs...)</code></pre><p>Run the model with all the parameter value combinations given in <code>parameters</code> while initializing the model with <code>initialize</code>. This function uses <code>DrWatson</code>&#39;s <a href="https://juliadynamics.github.io/DrWatson.jl/dev/run&amp;list/#DrWatson.dict_list"><code>dict_list</code></a> internally. This means that every entry of <code>parameters</code> that is a <code>Vector</code>, contains many parameters and thus is scanned. All other entries of <code>parameters</code> that are not <code>Vector</code>s are not expanded in the scan. Keys of <code>parameters</code> should be of type <code>Symbol</code>.</p><p><code>initialize</code> is a function that creates an ABM. It should accept keyword arguments, of which all values in <code>parameters</code> should be a subset. This means <code>parameters</code> can take both model and agent constructor properties.</p><p><strong>Keywords</strong></p><p>All the following keywords are propagated into <a href="../tutorial/#Agents.run!"><code>run!</code></a>. Defaults are also listed for convenience: <code>agent_step! = dummystep, n = 1, when = 1:n, model_step! = dummystep</code>, <code>step0::Bool = true</code>, <code>parallel::Bool = false</code>, <code>replicates::Int = 0</code>. Keyword arguments such as <code>adata</code> and <code>mdata</code> are also propagated.</p><p>The following keywords modify the <code>paramscan</code> function:</p><p><code>include_constants::Bool=false</code> determines whether constant parameters should be included in the output <code>DataFrame</code>.</p><p><code>progress::Bool = true</code> whether to show the progress of simulations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/paramscan.jl#L3-L32">source</a></section></article><p>For example, the core loop of <code>run!</code> is just</p><pre><code class="language-julia">df_agent = init_agent_dataframe(model, adata)
df_model = init_model_dataframe(model, mdata)

s = 0
while until(s, n, model)
  if should_we_collect(s, model, when)
      collect_agent_data!(df_agent, model, adata, s)
  end
  if should_we_collect(s, model, when_model)
      collect_model_data!(df_model, model, mdata, s)
  end
  step!(model, agent_step!, model_step!, 1)
  s += 1
end
return df_agent, df_model</code></pre><p>(here <code>until</code> and <code>should_we_collect</code> are internal functions)</p><h2 id="Schedulers"><a class="docs-heading-anchor" href="#Schedulers">Schedulers</a><a id="Schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Schedulers" title="Permalink"></a></h2><p>The schedulers of Agents.jl have a very simple interface. All schedulers are functions, that take as an input the ABM and return an iterator over agent IDs. Notice that this iterator can be a &quot;true&quot; iterator (non-allocated) or can be just a standard vector of IDs. You can define your own scheduler according to this API and use it when making an <a href="../tutorial/#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>.</p><p>Also notice that you can use <a href="https://docs.julialang.org/en/v1.5/manual/methods/#Function-like-objects">Function-like-objects</a> to make your scheduling possible of arbitrary events. For example, imagine that after the <code>n</code>-th step of your simulation you want to fundamentally change the order of agents. To achieve this you can define</p><pre><code class="language-julia">mutable struct MyScheduler
    n::Int # step number
    w::Float64
end</code></pre><p>and then define a calling method for it like so</p><pre><code class="language-julia">function (ms::MyScheduler)(model::ABM)
    ms.n += 1 # increment internal counter by 1 each time its called
              # be careful to use a *new* instance of this scheduler when plotting!
    if ms.n &lt; 10
        return keys(model.agents) # order doesn&#39;t matter in this case
    else
        ids = collect(allids(model))
        # filter all ids whose agents have `w` less than some amount
        filter!(id -&gt; model[id].w &lt; ms.w, ids)
        return ids
    end
end</code></pre><p>and pass it to e.g. <code>step!</code> by initializing it</p><pre><code class="language-julia">ms = MyScheduler(100, 0.5)
run!(model, agentstep, modelstep, 100; scheduler = ms)</code></pre><h3 id="Predefined-schedulers"><a class="docs-heading-anchor" href="#Predefined-schedulers">Predefined schedulers</a><a id="Predefined-schedulers-1"></a><a class="docs-heading-anchor-permalink" href="#Predefined-schedulers" title="Permalink"></a></h3><p>Some useful schedulers are available below as part of the Agents.jl public API:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.fastest" href="#Agents.fastest"><code>Agents.fastest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fastest</code></pre><p>Activate all agents once per step in the order dictated by the agent&#39;s container, which is arbitrary (the keys sequence of a dictionary). This is the fastest way to activate all agents once per step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L7-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.by_id" href="#Agents.by_id"><code>Agents.by_id</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">by_id</code></pre><p>Activate agents at each step according to their id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.random_activation" href="#Agents.random_activation"><code>Agents.random_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">random_activation</code></pre><p>Activate agents once per step in a random order. Different random ordering is used at each different step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L26-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.partial_activation" href="#Agents.partial_activation"><code>Agents.partial_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">partial_activation(p)</code></pre><p>At each step, activate only <code>p</code> percentage of randomly chosen agents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L35-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.property_activation" href="#Agents.property_activation"><code>Agents.property_activation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">property_activation(property)</code></pre><p>At each step, activate the agents in an order dictated by their <code>property</code>, with agents with greater <code>property</code> acting first. <code>property</code> is a <code>Symbol</code>, which just dictates which field the agents to compare.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.by_type" href="#Agents.by_type"><code>Agents.by_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">by_type(shuffle_types::Bool, shuffle_agents::Bool)</code></pre><p>Useful only for mixed agent models using <code>Union</code> types.</p><ul><li>Setting <code>shuffle_types = true</code> groups by agent type, but randomizes the type order.</li></ul><p>Otherwise returns agents grouped in order of appearance in the <code>Union</code>.</p><ul><li><code>shuffle_agents = true</code> randomizes the order of agents within each group, <code>false</code> returns</li></ul><p>the default order of the container (equivalent to <a href="#Agents.fastest"><code>fastest</code></a>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L62-L69">source</a></section><section><div><pre><code class="language-none">by_type((C, B, A), shuffle_agents::Bool)</code></pre><p>Activate agents by type in specified order (since <code>Union</code>s are not order preserving). <code>shuffle_agents = true</code> randomizes the order of agents within each group.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/schedule.jl#L84-L88">source</a></section></article><h2 id="Plotting"><a class="docs-heading-anchor" href="#Plotting">Plotting</a><a id="Plotting-1"></a><a class="docs-heading-anchor-permalink" href="#Plotting" title="Permalink"></a></h2><p>Plotting functionality comes from <code>AgentsPlots</code>, which uses Plots.jl. You need to install both <code>AgentsPlots</code>, as well as a plotting backend (we use GR) to use the following functions.</p><p>The version of <code>AgentsPlots</code> is:</p><pre><code class="language-julia">using Pkg
Pkg.status(&quot;AgentsPlots&quot;)</code></pre><pre class="documenter-example-output">Status `~/build/JuliaDynamics/Agents.jl/docs/Project.toml`
  [7820620d] AgentsPlots v0.3.0</pre><article class="docstring"><header><a class="docstring-binding" id="AgentsPlots.plotabm" href="#AgentsPlots.plotabm"><code>AgentsPlots.plotabm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">plotabm(model::ABM{A, &lt;: ContinuousSpace}; ac, as, am, kwargs...)
plotabm(model::ABM{A, &lt;: DiscreteSpace}; ac, as, am, kwargs...)</code></pre><p>Plot the <code>model</code> as a <code>scatter</code>-plot, by configuring the agent shape, color and size via the keywords <code>ac, as, am</code>. These keywords can be constants, or they can be functions, each accepting an agent and outputting a valid value for color/shape/size.</p><p>The keyword <code>scheduler = model.scheduler</code> decides the plotting order of agents (which matters only if there is overlap).</p><p>The keyword <code>offset</code> is a function with argument <code>offest(a::Agent)</code>. It targets scenarios where multiple agents existin within a grid cell as it adds an offset (same type as <code>agent.pos</code>) to the plotted agent position.</p><p>All other keywords are propagated into <code>Plots.scatter</code> and the plot is returned.</p></div></section><section><div><pre><code class="language-none">plotabm(model::ABM{A, &lt;: GraphSpace}; ac, as, am, kwargs...)</code></pre><p>This function is the same as <code>plotabm</code> for <code>ContinuousSpace</code>, but here the three key functions <code>ac, as, am</code> do not get an agent as an input but a vector of agents at each node of the graph. Their output is the same.</p><p>Here <code>as</code> defaults to <code>length</code>. Internally, the <code>graphplot</code> recipe is used, and all other <code>kwargs...</code> are propagated there.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../models/">« Predefined Models</a><a class="docs-footer-nextpage" href="../interact/">Interactive application »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 September 2020 14:48">Tuesday 8 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
