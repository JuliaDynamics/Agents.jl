<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#.-The-model"><span>1. The model</span></a></li><li><a class="tocitem" href="#Space"><span>2. The space</span></a></li><li><a class="tocitem" href="#.-The-agent"><span>3. The agent</span></a></li><li><a class="tocitem" href="#.-Evolving-the-model"><span>4. Evolving the model</span></a></li><li><a class="tocitem" href="#.-Collecting-data"><span>5. Collecting data</span></a></li><li><a class="tocitem" href="#An-educative-example"><span>An educative example</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/social_distancing/">Continuous space social distancing for COVID-19</a></li><li><a class="tocitem" href="../examples/wealth_distribution/">Wealth distribution</a></li><li><a class="tocitem" href="../examples/forest_fire/">Forest fire</a></li><li><a class="tocitem" href="../examples/game_of_life_2D_CA/">Conway&#39;s game of life</a></li><li><a class="tocitem" href="../examples/wright-fisher/">Wright-Fisher model of evolution</a></li><li><a class="tocitem" href="../examples/hk/">Hegselmann-Krause opinion dynamics</a></li><li><a class="tocitem" href="../examples/flock/">Flocking</a></li><li><a class="tocitem" href="../examples/daisyworld/">Daisyworld</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-Prey</a></li><li><a class="tocitem" href="../examples/growing_bacteria/">Bacteria Growth</a></li><li><a class="tocitem" href="../examples/opinion_spread/">Opinion spread</a></li></ul></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../interact/">Interactive application</a></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim</a></li></ul></li><li><a class="tocitem" href="../mesa/">Comparison against Mesa (Python)</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h1><p>Agents.jl is composed of components for building models, building and managing space structures, collecting data, running batch simulations, and data visualization.</p><p>Agents.jl structures simulations in three components:</p><ol><li>An <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> instance.</li><li>A <a href="#Space">space</a> instance.</li><li>A subtype of <a href="#Agents.AbstractAgent"><code>AbstractAgent</code></a> for the agents.</li></ol><p>To run simulations and collect data, the following are also necessary</p><ol><li>Stepping functions that controls how the agents and the model evolve.</li><li>Specifying which data should be collected from the agents and/or the model.</li></ol><h2 id=".-The-model"><a class="docs-heading-anchor" href="#.-The-model">1. The model</a><a id=".-The-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AgentBasedModel(AgentType [, space]; scheduler, properties) → model</code></pre><p>Create an agent based model from the given agent type and <code>space</code>. You can provide an agent <em>instance</em> instead of type, and the type will be deduced.  <code>ABM</code> is equivalent with <code>AgentBasedModel</code>.</p><p>The agents are stored in a dictionary that maps unique ids (integers) to agents. Use <code>model[id]</code> to get the agent with the given <code>id</code>.</p><p><code>space</code> is a subtype of <code>AbstractSpace</code>: <a href="#Agents.GraphSpace"><code>GraphSpace</code></a>, <a href="#Agents.GridSpace"><code>GridSpace</code></a> or <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a>. If it is ommited then all agents are virtually in one node and have no spatial structure.</p><p><strong>Note:</strong> Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.</p><p><code>properties = nothing</code> is additional model-level properties (typically a dictionary) that can be accessed as <code>model.properties</code>. However, if <code>properties</code> is a dictionary with key type <code>Symbol</code>, or of it is a struct, then the syntax <code>model.name</code> is short hand for <code>model.properties[:name]</code> (or <code>model.properties.name</code> for structs). This syntax can&#39;t be used for <code>name</code> being <code>agents, space, scheduler, properties</code>, which are the fields of <code>AgentBasedModel</code>.</p><p><code>scheduler = fastest</code> decides the order with which agents are activated (see e.g. <a href="../api/#Agents.by_id"><code>by_id</code></a> and the scheduler API).</p><p>Type tests for <code>AgentType</code> are done, and by default warnings are thrown when appropriate. Use keyword <code>warn=false</code> to supress that.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/model.jl#L74-L103">source</a></section></article><h2 id="Space"><a class="docs-heading-anchor" href="#Space">2. The space</a><a id="Space-1"></a><a class="docs-heading-anchor-permalink" href="#Space" title="Permalink"></a></h2><p>Agents.jl offers several possibilities for the space the agents live in, separated into discrete and continuous categories (notice that using a space is not actually necessary).</p><p>The discrete possibilities, often summarized as <code>DiscreteSpace</code>, are</p><article class="docstring"><header><a class="docstring-binding" id="Agents.GraphSpace" href="#Agents.GraphSpace"><code>Agents.GraphSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GraphSpace(graph::AbstractGraph)</code></pre><p>Create a <code>GraphSpace</code> instance that is underlined by an arbitrary graph from <a href="https://github.com/JuliaGraphs/LightGraphs.jl">LightGraphs.jl</a>. In this case, your agent type must have a <code>pos</code> field that is of type <code>Int</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L51-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.GridSpace" href="#Agents.GridSpace"><code>Agents.GridSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridSpace(dims::NTuple; periodic = false, moore = false) → GridSpace</code></pre><p>Create a <code>GridSpace</code> instance that represents a grid of dimensionality <code>length(dims)</code>, with each dimension having the size of the corresponding entry of <code>dims</code>. Such grids are typically used in cellular-automata-like models. In this case, your agent type must have a <code>pos</code> field that is of type <code>NTuple{N, Int}</code>, where <code>N</code> is the number of dimensions.</p><p>The two keyword arguments denote if the grid should be periodic on its ends, and if the connections should be of type Moore or not (in the Moore case the diagonal connections are also valid. E.g. for a 2D grid, each node has 8 neighbors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/discrete_space.jl#L62-L74">source</a></section></article><p>and the continuous version is</p><article class="docstring"><header><a class="docstring-binding" id="Agents.ContinuousSpace" href="#Agents.ContinuousSpace"><code>Agents.ContinuousSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousSpace(D::Int [, update_vel!]; kwargs...)</code></pre><p>Create a <code>ContinuousSpace</code> of dimensionality <code>D</code>. In this case, your agent positions (field <code>pos</code>) should be of type <code>NTuple{D, F}</code> where <code>F &lt;: AbstractFloat</code>. In addition, the agent type should have a third field <code>vel::NTuple{D, F}</code> representing the agent&#39;s velocity to use <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a>.</p><p>The optional argument <code>update_vel!</code> is a <strong>function</strong>, <code>update_vel!(agent, model)</code> that updates the agent&#39;s velocity <strong>before</strong> the agent has been moved, see <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a>. You can of course change the agents&#39; velocities during the agent interaction, the <code>update_vel!</code> functionality targets arbitrary force fields acting on the agents (e.g. some magnetic field). By default no update is done this way.</p><p>Notice that if you need to write your own custom <code>move_agent</code> function, call <a href="../api/#Agents.update_space!"><code>update_space!</code></a> at the end, like in e.g. the <a href="../examples/growing_bacteria/#Bacterial-Growth">Bacterial Growth</a> example.</p><p><strong>Keywords</strong></p><ul><li><code>periodic = true</code> : whether continuous space is periodic or not</li><li><code>extend::NTuple{D} = ones</code> : Extend of space. The <code>d</code> dimension starts at 0 and ends at <code>extend[d]</code>. If <code>periodic = true</code>, this is also when periodicity occurs. If <code>periodic ≠ true</code>, <code>extend</code> is only used at plotting.</li><li><code>metric = :cityblock</code> : metric that configures distances for finding nearest neighbors in the space. The other option is <code>:euclidean</code> but cityblock is faster (due to internals).</li></ul><p><strong>Note:</strong> if your model requires linear algebra operations for which tuples are not supported, a performant solution is to convert between Tuple and SVector using <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a> as follows: <code>s = SVector(t)</code> and back with <code>t = Tuple(s)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/continuous_space.jl#L23-L53">source</a></section></article><h2 id=".-The-agent"><a class="docs-heading-anchor" href="#.-The-agent">3. The agent</a><a id=".-The-agent-1"></a><a class="docs-heading-anchor-permalink" href="#.-The-agent" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All agents must be a mutable subtype of <code>AbstractAgent</code>. Your agent type <strong>must have</strong> the <code>id</code> field as first field. Depending on the space structure there might be a <code>pos</code> field of appropriate type and a <code>vel</code> field of appropriate type.</p><p>Your agent type may have other additional fields relevant to your system, for example variable quantities like &quot;status&quot; or other &quot;counters&quot;.</p><p><strong>Examples</strong></p><p>Imagine agents who have extra properties <code>weight, happy</code>. For a <a href="#Agents.GraphSpace"><code>GraphSpace</code></a> we would define them like</p><pre><code class="language-julia">mutable struct ExampleAgent &lt;: AbstractAgent
    id::Int
    pos::Int
    weight::Float64
    happy::Bool
end</code></pre><p>while for e.g. a <a href="#Agents.ContinuousSpace"><code>ContinuousSpace</code></a> we would use</p><pre><code class="language-julia">mutable struct ExampleAgent &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Float64}
    vel::NTuple{2, Float64}
    weight::Float64
    happy::Bool
end</code></pre><p>where <code>vel</code> is optional, useful if you want to use <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> in continuous space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/core/model.jl#L5-L37">source</a></section></article><p>The agent type <strong>must</strong> be mutable. Once an Agent is created it can be added to a model using e.g. <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. Then, the agent can interact with the model and the space further by using e.g. <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> or <a href="../api/#Agents.kill_agent!"><code>kill_agent!</code></a>.</p><p>For more functions visit the <a href="../api/#API">API</a> page.</p><h2 id=".-Evolving-the-model"><a class="docs-heading-anchor" href="#.-Evolving-the-model">4. Evolving the model</a><a id=".-Evolving-the-model-1"></a><a class="docs-heading-anchor-permalink" href="#.-Evolving-the-model" title="Permalink"></a></h2><p>Any ABM model should have at least one and at most two step functions. An <em>agent step function</em> is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a <em>model step function</em>.</p><p>An agent step function should only accept two arguments: first, an agent object, and second, a model object.</p><p>The model step function should accept only one argument, that is the model object. To use only a model step function, users can use the built-in <a href="#Agents.dummystep"><code>dummystep</code></a> as the agent step function.</p><p>After you have defined these two functions, you evolve your model with <code>step!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.step!" href="#Agents.step!"><code>Agents.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(model, agent_step!, n::Int = 1)
step!(model, agent_step!, model_step!, n::Int = 1, agents_first::Bool=true)</code></pre><p>Update agents <code>n</code> steps according to the stepping function <code>agent_step!</code>. Agents will be activated as specified by the <code>model.scheduler</code>. <code>model_step!</code> is triggered <em>after</em> every scheduled agent has acted, unless the argument <code>agents_first</code> is <code>false</code> (which then first calls <code>model_step!</code> and then activates the agents).</p><pre><code class="language-none">step!(model, agent_step!, model_step!, n::Function, agents_first::Bool=true)</code></pre><p>In this version <code>n</code> is a function. Then <code>step!</code> runs the model until <code>n(model, s)</code> returns <code>true</code>, where <code>s</code> is the current amount of steps taken, starting from 0. For this method of <code>step!</code>, <code>model_step!</code> must be provided always (use <a href="#Agents.dummystep"><code>dummystep</code></a> if you have no model stepping dynamics).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/step.jl#L3-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.dummystep" href="#Agents.dummystep"><code>Agents.dummystep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dummystep(model)</code></pre><p>Ignore the model dynamics. Use instead of <code>model_step!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/step.jl#L23-L27">source</a></section><section><div><pre><code class="language-none">dummystep(agent, model)</code></pre><p>Ignore the agent dynamics. Use instead of <code>agent_step!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/step.jl#L29-L33">source</a></section></article><h2 id=".-Collecting-data"><a class="docs-heading-anchor" href="#.-Collecting-data">5. Collecting data</a><a id=".-Collecting-data-1"></a><a class="docs-heading-anchor-permalink" href="#.-Collecting-data" title="Permalink"></a></h2><p>Running the model and collecting data while the model runs is done with the <a href="#Agents.run!"><code>run!</code></a> function. Besides <code>run!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection, while scanning ranges of the parameters of the model.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.run!" href="#Agents.run!"><code>Agents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df
run!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df</code></pre><p>Run the model (step it with the input arguments propagated into <a href="#Agents.step!"><code>step!</code></a>) and collect data specified by the keywords, explained one by one below. Return the data as two <code>DataFrame</code>s, one for agent-level data and one for model-level data.</p><p><strong>Data-deciding keywords</strong></p><ul><li><p><code>adata::Vector</code> means &quot;agent data to collect&quot;. If an entry is a <code>Symbol</code>, e.g. <code>:weight</code>, then the data for this entry is agent&#39;s field <code>weight</code>. If an entry is a <code>Function</code>, e.g. <code>f</code>, then the data for this entry is just <code>f(a)</code> for each agent <code>a</code>. The resulting dataframe columns are named with the input symbol (here <code>:weight, :f</code>).</p></li><li><p><code>adata::Vector{&lt;:Tuple}</code>: if <code>adata</code> is a vector of tuples instead, data aggregation is done over the agent properties.</p><p>For each 2-tuple, the first entry is the &quot;key&quot; (any entry like the ones mentioned above, e.g. <code>:weight, f</code>). The second entry is an aggregating function that aggregates the key, e.g. <code>mean, maximum</code>. So, continuing from the above example, we would have <code>adata = [(:weight, mean), (f, maximum)]</code>.</p><p>It&#39;s also possible to provide a 3-tuple, with the third entry being a conditional function (returning a <code>Bool</code>), which assesses if each agent should be included in the aggregate. For example: <code>x_pos(a) = a.pos[1]&gt;5</code> with <code>(:weight, mean, x_pos)</code> will result in the average weight of agents conditional on their x-position being greater than 5.</p><p>The resulting data name columns use the function <a href="../api/#Agents.aggname"><code>aggname</code></a>, and create something like <code>:mean_weight</code> or <code>:maximum_f_x_pos</code>. This name doesn&#39;t play well with anonymous functions!</p><p><strong>Notice:</strong> Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. <em>E.g.</em> instead of passing <code>mean</code>, pass <code>mymean(a) = isempty(a) ? 0.0 : mean(a)</code>.</p></li><li><p><code>mdata::Vector</code> means &quot;model data to collect&quot; and works exactly like <code>adata</code>. For the model, no aggregation is possible (nothing to aggregate over).</p></li></ul><p>By default both keywords are <code>nothing</code>, i.e. nothing is collected/aggregated.</p><p><strong>Other keywords</strong></p><ul><li><code>when=true</code> : at which steps <code>s</code> to perform the data collection and processing. A lot of flexibility is offered based on the type of <code>when</code>. If <code>when::Vector</code>, then data are collect if <code>s ∈ when</code>. Otherwise data are collected if <code>when(model, s)</code> returns <code>true</code>. By default data are collected in every step.</li><li><code>when_model = when</code> : same as <code>when</code> but for model data.</li><li><code>obtainer = identity</code> : method to transfer collected data to the <code>DataFrame</code>. Typically only change this to <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy"><code>copy</code></a> if some data are mutable containers (e.g. <code>Vector</code>) which change during evolution, or <a href="https://docs.julialang.org/en/v1/base/base/#Base.deepcopy"><code>deepcopy</code></a> if some data are nested mutable containers. Both of these options have performance penalties.</li><li><code>replicates=0</code> : Run <code>replicates</code> replicates of the simulation.</li><li><code>parallel=false</code> : Only when <code>replicates&gt;0</code>. Run replicate simulations in parallel.</li><li><code>agents_first=true</code> : Whether to update agents first and then the model, or vice versa.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/b7a6344fe649aa95d26d1ec8e27d1218b1c638dc/src/simulations/collect.jl#L15-L70">source</a></section></article><p>The <a href="#Agents.run!"><code>run!</code></a> function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregating model data, or arbitrary combinations.</p><p>This means that <a href="#Agents.run!"><code>run!</code></a> has not been designed for maximum performance (or minimum memory allocation). However, we also expose a simple data-collection API (see <a href="../api/#Data-collection">Data collection</a>), that gives users even more flexibility, allowing them to make their own &quot;data collection loops&quot; arbitrarily calling <code>step!</code> and collecting data as needed and to the data structure that they need.</p><h2 id="An-educative-example"><a class="docs-heading-anchor" href="#An-educative-example">An educative example</a><a id="An-educative-example-1"></a><a class="docs-heading-anchor-permalink" href="#An-educative-example" title="Permalink"></a></h2><p>A simple, education-oriented example of using the basic Agents.jl API is given in <a href="../examples/schelling/#Schelling&#39;s-segregation-model">Schelling&#39;s segregation model</a>, also discussing in detail how to visualize your ABMs.</p><p>Each of the examples listed within this documentation are designed to showcase different ways of interacting with the API. If you are not sure about how to use a particular function, most likely one of the examples can show you how to interact with it.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/schelling/">Schelling&#39;s segregation model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 8 September 2020 14:48">Tuesday 8 September 2020</span>. Using Julia version 1.5.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
