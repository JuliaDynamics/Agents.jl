<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorial · Agents.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Agents.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Agents.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Space-1"><span>1. The space</span></a></li><li><a class="tocitem" href="#.-The-agent-type(s)-1"><span>2. The agent type(s)</span></a></li><li><a class="tocitem" href="#.-The-model-1"><span>3. The model</span></a></li><li><a class="tocitem" href="#.-Evolving-the-model-1"><span>4. Evolving the model</span></a></li><li><a class="tocitem" href="#.-Visualizations-1"><span>5. Visualizations</span></a></li><li><a class="tocitem" href="#.-Collecting-data-1"><span>6. Collecting data</span></a></li><li><a class="tocitem" href="#Seeding-and-Random-numbers-1"><span>Seeding and Random numbers</span></a></li><li><a class="tocitem" href="#An-educative-example-1"><span>An educative example</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/schelling/">Schelling&#39;s segregation model</a></li><li><a class="tocitem" href="../examples/sir/">SIR model for the spread of COVID-19</a></li><li><a class="tocitem" href="../examples/flock/">Flocking model</a></li><li><a class="tocitem" href="../examples/zombies/">Zombie Outbreak in a City</a></li><li><a class="tocitem" href="../examples/predator_prey/">Predator-prey dynamics</a></li><li><a class="tocitem" href="../examples/rabbit_fox_hawk/">3D Mixed-Agent Ecosystem with Pathfinding</a></li><li><a class="tocitem" href="../models/">Predefined Models</a></li><li><a class="tocitem" href="../examples/">More Examples for Agents.jl</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../agents_visualizations/">Plotting and Interactivity</a></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Ecosystem Integration</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/optim/">BlackBoxOptim.jl</a></li><li><a class="tocitem" href="../examples/diffeq/">DifferentialEquations.jl</a></li><li><a class="tocitem" href="../examples/schoolyard/">Graphs.jl</a></li><li><a class="tocitem" href="../examples/measurements/">Measurements.jl</a></li><li><a class="tocitem" href="../examples/celllistmap/">CellListMap.jl</a></li></ul></li><li><a class="tocitem" href="../performance_tips/">Performance Tips</a></li><li><a class="tocitem" href="../comparison/">ABM Framework Comparison</a></li><li><a class="tocitem" href="../devdocs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/Agents.jl/blob/master/docs/src/tutorial.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-1"><a class="docs-heading-anchor" href="#Tutorial-1">Tutorial</a><a class="docs-heading-anchor-permalink" href="#Tutorial-1" title="Permalink"></a></h1><div class="admonition is-success"><header class="admonition-header">YouTube video</header><div class="admonition-body"><ul><li>This Tutorial is also available as a YouTube video: https://youtu.be/fgwAfAa4kt0</li></ul></div></div><p>In Agents.jl a central structure called <code>AgentBasedModel</code> contains all data of a simulation and maps unique IDs (integers) to agent instances. During the simulation, the model evolves in discrete steps. During one step, the user decides which agents will act, how will they act, how many times, and whether any model-level properties will be adjusted. Once the time evolution is defined, collecting data during time evolution is straightforward by simply stating which data should be collected.</p><p>In the spirit of simple design, all of this is done by defining simple Julia data types, like basic functions, structs and dictionaries.</p><p>To set up an ABM simulation in Agents.jl, a user only needs to follow these steps:</p><ol><li>Choose in what kind of space the agents will live in, for example a graph, a grid, etc. Several spaces are provided by Agents.jl and can be initialized immediately.</li><li>Define the agent type (or types, for mixed models) that will populate the ABM. Agent types are standard Julia <code>mutable struct</code>s. They can be created manually, but typically you&#39;d want to use <a href="#Agents.@agent"><code>@agent</code></a>. The types must contain some mandatory fields, which is ensured by using <a href="#Agents.@agent"><code>@agent</code></a>. The remaining fields of the agent type are up to user&#39;s choice.</li><li>The created agent type, the chosen space, optional additional model level properties, and other simulation tuning properties like schedulers or random number generators, are given to <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. This instance defines the model within an Agents.jl simulation. More specialized structures are also available, see <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>.</li><li>Provide functions that govern the time evolution of the ABM. A user can provide an agent-stepping function, that acts on each agent one by one, and/or a model-stepping function, that steps the entire model as a whole. These functions are standard Julia functions that take advantage of the Agents.jl <a href="../api/#API-1">API</a>. Once these functions are created, they are simply passed to <a href="#Agents.step!"><code>step!</code></a> to evolve the model.</li><li><em>(Optional)</em> Visualize the model and animate its time evolution. This can help checking that the model behaves as expected and there aren&#39;t any mistakes, or can be used in making figures for a paper/presentation.</li><li>Collect data. To do this, specify which data should be collected, by providing one standard Julia <code>Vector</code> of data-to-collect for agents, for example <code>[:mood, :wealth]</code>, and another one for the model. The agent data names are given as the keyword <code>adata</code> and the model as keyword <code>mdata</code> to the function <a href="#Agents.run!"><code>run!</code></a>. This function outputs collected data in the form of a <code>DataFrame</code>.</li></ol><p>If you&#39;re planning of running massive simulations, it might be worth having a look at the <a href="../performance_tips/#Performance-Tips-1">Performance Tips</a> after familiarizing yourself with Agents.jl.</p><h2 id="Space-1"><a class="docs-heading-anchor" href="#Space-1">1. The space</a><a class="docs-heading-anchor-permalink" href="#Space-1" title="Permalink"></a></h2><p>Agents.jl offers several possibilities for the space the agents live in. In addition, it is straightforward to implement a fundamentally new type of space, see <a href="../devdocs/#Creating-a-new-space-type-1">Creating a new space type</a>.</p><p>The available spaces are listed in the <a href="../api/#Available-spaces-1">Available spaces</a> part of the API. An example of a space is <a href="../api/#Agents.OpenStreetMapSpace"><code>OpenStreetMapSpace</code></a>. It is based on Open Street Map, where agents are confined to move along streets of the map, using real-world values for the length of each street.</p><p>After deciding on the space, one simply initializes an instance of a space, e.g. with <code>grid = GridSpace((10, 10))</code> and passes that into <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>. See each individual space for all its possible arguments.</p><h2 id=".-The-agent-type(s)-1"><a class="docs-heading-anchor" href="#.-The-agent-type(s)-1">2. The agent type(s)</a><a class="docs-heading-anchor-permalink" href="#.-The-agent-type(s)-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Agents.@agent" href="#Agents.@agent"><code>Agents.@agent</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@agent YourAgentType{X} AnotherAgentType [OptionalSupertype] begin
    extra_property::X
    other_extra_property::Int
    # etc...
end</code></pre><p>Define an agent struct which includes all fields that <code>AnotherAgentType</code> has, as well as any additional ones the user may provide via the <code>begin</code> block. See below for examples.</p><p>Using <code>@agent</code> is the recommended way to create agent types for Agents.jl, however keep in mind that the macro (currently) doesn&#39;t work with <code>Base.@kwdef</code> or <code>const</code> declerations in individual fields (for Julia v1.8+).</p><p>Structs created with <code>@agent</code> by default subtype <code>AbstractAgent</code>. They cannot subtype each other, as all structs created from <code>@agent</code> are concrete types and <code>AnotherAgentType</code> itself is also concrete (only concrete types have fields). If you want <code>YourAgentType</code> to subtype something other than <code>AbstractAgent</code>, use the optional argument <code>OptionalSupertype</code> (which itself must then subtype <code>AbstractAgent</code>).</p><p><strong>Usage</strong></p><p>The macro <code>@agent</code> has two primary uses:</p><ol><li>To include the mandatory fields for a particular space in your agent struct. In this case you would use one of the minimal agent types as <code>AnotherAgentType</code>.</li><li>A convenient way to include fields from another, already existing struct.</li></ol><p>The existing minimal agent types are:</p><ul><li><a href="../api/#Agents.NoSpaceAgent"><code>NoSpaceAgent</code></a></li><li><a href="../api/#Agents.GraphAgent"><code>GraphAgent</code></a></li><li><a href="../api/#Agents.GridAgent"><code>GridAgent</code></a></li><li><a href="../api/#Agents.ContinuousAgent"><code>ContinuousAgent</code></a></li><li><a href="../api/#Agents.OSMAgent"><code>OSMAgent</code></a></li></ul><p>All will attribute an <code>id::Int</code> field, and besides <code>NoSpaceAgent</code> will also attribute a <code>pos</code> field. You should <strong>never directly manipulate the mandatory fields <code>id, pos</code></strong> that the resulting new agent type will have. The <code>id</code> is an unchangable field. Use functions like <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> etc., to change the position.</p><p><strong>Examples</strong></p><p><strong>Example without optional hierarchy</strong></p><p>Using</p><pre><code class="language-julia">@agent Person{T} GridAgent{2} begin
    age::Int
    moneyz::T
end</code></pre><p>will create an agent appropriate for using with 2-dimensional <a href="../api/#Agents.GridSpace"><code>GridSpace</code></a></p><pre><code class="language-julia">mutable struct Person{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    age::Int
    moneyz::T
end</code></pre><p>and then, one can even do</p><pre><code class="language-julia">@agent Baker{T} Person{T} begin
    breadz_per_day::T
end</code></pre><p>which would make</p><pre><code class="language-julia">mutable struct Baker{T} &lt;: AbstractAgent
    id::Int
    pos::NTuple{2, Int}
    age::Int
    moneyz::T
    breadz_per_day::T
end</code></pre><p><strong>Example with optional hierarchy</strong></p><p>An alternative way to make the above structs, that also establishes a user-specific subtyping hierarchy would be to do:</p><pre><code class="language-julia">abstract type AbstractHuman &lt;: AbstractAgent end

@agent Worker GridAgent{2} AbstractHuman begin
    age::Int
    moneyz::Float64
end

@agent Fisher Worker AbstractHuman begin
    fish_per_day::Float64
end</code></pre><p>which would now make both <code>Fisher</code> and <code>Worker</code> subtypes of <code>AbstractHuman</code>.</p><pre><code class="language-julia">julia&gt; supertypes(Fisher)
(Fisher, AbstractHuman, AbstractAgent, Any)

julia&gt; supertypes(Worker)
(Worker, AbstractHuman, AbstractAgent, Any)</code></pre><p>Note that <code>Fisher</code> will <em>not</em> be a subtype of <code>Worker</code> although <code>Fisher</code> has inherited the fields from <code>Worker</code>.</p><p><strong>Example highlighting problems with parametric types</strong></p><p>Notice that in Julia parametric types are union types. Hence, the following cannot be used:</p><pre><code class="language-julia">@agent Dummy{T} GridAgent{2} begin
    moneyz::T
end

@agent Fisherino{T} Dummy{T} begin
    fish_per_day::T
end</code></pre><p>You will get an error in the definition of <code>Fisherino</code>, because the fields of <code>Dummy{T}</code> cannot be obtained, because it is a union type. Same with using <code>Dummy</code>. You can only use <code>Dummy{Float64}</code>.</p><p><strong>Example with common dispatch and no subtyping</strong></p><p>It may be that you do not even need to create a subtyping relation if you want to utilize multiple dispatch. Consider the example:</p><pre><code class="language-julia">@agent CommonTraits GridSpace{2} begin
    age::Int
    speed::Int
    energy::Int
end</code></pre><p>and then two more structs are made from these traits:</p><pre><code class="language-julia">@agent Bird CommonTraits begin
    height::Float64
end

@agent Rabbit CommonTraits begin
    underground::Bool
end</code></pre><p>If you wanted a function that dispatches to both <code>Rabbit, Bird</code>, you only have to define:</p><pre><code class="language-julia">Animal = Union{Bird, Rabbit}
f(x::Animal) = ... # uses `CommonTraits` fields</code></pre><p>However, it should also be said, that there is no real reason here to explicitly type-annotate <code>x::Animal</code> in <code>f</code>. Don&#39;t annotate any type. Annotating a type only becomes useful if there are at least two &quot;abstract&quot; groups, like <code>Animal, Person</code>. Then it would make sense to define</p><pre><code class="language-julia">Person = Union{Fisher, Baker}
f(x::Animal) = ... # uses `CommonTraits` fields
f(x::Person) = ... # uses fields that all &quot;persons&quot; have</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/core/agents.jl#L20-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.AbstractAgent" href="#Agents.AbstractAgent"><code>Agents.AbstractAgent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">YourAgentType &lt;: AbstractAgent</code></pre><p>Agents participating in Agents.jl simulations are instances of user-defined Types that are subtypes of <code>AbstractAgent</code>.</p><p>Your agent type(s) <strong>must have</strong> the <code>id::Int</code> field as first field. If any space is used (see <a href="../api/#Available-spaces-1">Available spaces</a>), a <code>pos</code> field of appropriate type is also mandatory. The core model structure, and each space, may also require additional fields that may, or may not, be communicated as part of the public API.</p><p>The <a href="#Agents.@agent"><code>@agent</code></a> macro ensures that all of these constrains are in place and hence it is the recommended way to generate new agent types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/core/agents.jl#L3-L17">source</a></section></article><h2 id=".-The-model-1"><a class="docs-heading-anchor" href="#.-The-model-1">3. The model</a><a class="docs-heading-anchor-permalink" href="#.-The-model-1" title="Permalink"></a></h2><p>Once an agent is created (typically by instantiating a struct generated with <a href="#Agents.@agent"><code>@agent</code></a>), it can be added to a model using <a href="../api/#Agents.add_agent!"><code>add_agent!</code></a>. Then, the agent can interact with the model and the space further by using e.g. <a href="../api/#Agents.move_agent!"><code>move_agent!</code></a> or <a href="@ref"><code>kill_agent!</code></a>. The &quot;model&quot; here stands for an instance of <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.AgentBasedModel" href="#Agents.AgentBasedModel"><code>Agents.AgentBasedModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AgentBasedModel</code></pre><p>An <code>AgentBasedModel</code> is the supertype encompassing models in Agents.jl. All models are some concrete implementation of <code>AgentBasedModel</code> and follow its interface (see below). <code>ABM</code> is an alias to <code>AgentBasedModel</code>.</p><p>A model is typically constructed with:</p><pre><code class="language-none">AgentBasedModel(AgentType [, space]; properties, kwargs...) → model</code></pre><p>which creates a model expecting agents of type <code>AgentType</code> living in the given <code>space</code>. <code>AgentBasedModel(...)</code> defaults to <a href="../api/#Agents.StandardABM"><code>StandardABM</code></a>, which stores agents in a dictionary that maps unique IDs (integers) to agents. See also <a href="../api/#Agents.UnremovableABM"><code>UnremovableABM</code></a> and <a href="../api/#Agents.FixedMassABM"><code>FixedMassABM</code></a> for different storage types that yield better performance in case number of agents can only increase, or stays constant, during the model evolution.</p><p>Agents.jl supports multiple agent types by passing a <code>Union</code> of agent types as <code>AgentType</code>. However, please have a look at <a href="../performance_tips/#Performance-Tips-1">Performance Tips</a> for potential drawbacks of this approach.</p><p><code>space</code> is a subtype of <code>AbstractSpace</code>, see <a href="#Space-1">Space</a> for all available spaces. If it is omitted then all agents are virtually in one position and there is no spatial structure. Spaces are mutable objects and are not designed to be shared between models. Create a fresh instance of a space with the same properties if you need to do this.</p><p><strong>Keywords</strong></p><ul><li><code>properties = nothing</code>: additional model-level properties that the user may decide upon and include in the model. <code>properties</code> can be an arbitrary container of data, however it is most typically a <code>Dict</code> with <code>Symbol</code> keys, or a composite type (<code>struct</code>).</li><li><code>scheduler = Schedulers.fastest</code>: is the scheduelr that decides the (default) activation order of the agents. See the <a href="../api/#Schedulers-1">scheduler API</a> for more options.</li><li><code>rng = Random.default_rng()</code>: the random number generation stored and used by the model in all calls to random functions. Accepts any subtype of <code>AbstractRNG</code>.</li><li><code>warn=true</code>: some type tests for <code>AgentType</code> are done, and by default warnings are thrown when appropriate.</li></ul><p><strong>Interface of <code>AgentBasedModel</code></strong></p><p>Here we the most important information on how to query an instance of <code>AgentBasedModel</code>:</p><ul><li><code>model[id]</code> gives the agent with given <code>id</code>.</li><li><code>abmproperties(model)</code> gives the <code>properies</code> container stored in the model.</li><li><code>model.property</code>:  If the model properties is a dictionary with key type <code>Symbol</code>, or if it is a composite type (<code>struct</code>), then the syntax <code>model.property</code> will return the model property with key <code>:property</code>.</li><li><code>abmrng(model)</code> will return the random number generator of the model. It is strongly recommended to use <code>abmrng(model)</code> to all calls to <code>rand</code> and similar functions, so that reproducibility can be established in your modelling workflow.</li><li><code>abmscheduler(model)</code> will return the default scheduler of the model.</li></ul><p>Many more functions exist in the API page, such as <a href="../api/#Agents.allagents"><code>allagents</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/core/model_abstract.jl#L29-L83">source</a></section></article><h2 id=".-Evolving-the-model-1"><a class="docs-heading-anchor" href="#.-Evolving-the-model-1">4. Evolving the model</a><a class="docs-heading-anchor-permalink" href="#.-Evolving-the-model-1" title="Permalink"></a></h2><p>In Agents.jl, an agent based model should be accompanied with least one and at most two stepping functions. An <em>agent step function</em> is required by default. Such an agent step function defines what happens to an agent when it activates. Sometimes we also need a function that changes all agents at once, or changes a model property. In such cases, we can also provide a <em>model step function</em>.</p><p>An agent step function must accept two arguments: first, an agent instance, and second, a model instance.</p><p>The model step function must accept one argument, that is the model. To use only a model step function, users can use the built-in <a href="#Agents.dummystep"><code>dummystep</code></a> as the agent step function. This is typically the case for <a href="#Advanced-stepping-1">Advanced stepping</a>.</p><p>The stepping functions are created using the <a href="../api/#API-1">API</a> functions, and the Examples hosted in this documentation showcase several different variants.</p><p>After you have defined the stepping functions functions, you can evolve your model with <code>step!</code>:</p><article class="docstring"><header><a class="docstring-binding" id="Agents.step!" href="#Agents.step!"><code>Agents.step!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">step!(model, agent_step!, n::Int = 1)
step!(model, agent_step!, model_step!, n::Int = 1, agents_first::Bool = true)</code></pre><p>Update agents <code>n</code> steps according to the stepping function <code>agent_step!</code>. Agents will be activated as specified by the <code>model.scheduler</code>. <code>model_step!</code> is triggered <em>after</em> every scheduled agent has acted, unless the argument <code>agents_first</code> is <code>false</code> (which then first calls <code>model_step!</code> and then activates the agents).</p><p><code>step!</code> ignores scheduled IDs that do not exist within the model, allowing you to safely remove agents dynamically.</p><pre><code class="language-none">step!(model, agent_step!, model_step!, n::Function, agents_first::Bool = true)</code></pre><p>In this version <code>n</code> is a function. Then <code>step!</code> runs the model until <code>n(model, s)</code> returns <code>true</code>, where <code>s</code> is the current amount of steps taken, starting from 0. For this method of <code>step!</code>, <code>model_step!</code> must be provided always (use <a href="#Agents.dummystep"><code>dummystep</code></a> if you have no model stepping dynamics).</p><p>See also <a href="#Advanced-stepping-1">Advanced stepping</a> for stepping complex models where <code>agent_step!</code> might not be convenient.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/simulations/step.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Agents.dummystep" href="#Agents.dummystep"><code>Agents.dummystep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dummystep(model)</code></pre><p>Use instead of <code>model_step!</code> in <a href="#Agents.step!"><code>step!</code></a> if no function is useful to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/simulations/step.jl#L29-L33">source</a></section><section><div><pre><code class="language-none">dummystep(agent, model)</code></pre><p>Use instead of <code>agent_step!</code> in <a href="#Agents.step!"><code>step!</code></a> if no function is useful to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/simulations/step.jl#L35-L39">source</a></section></article><h3 id="Advanced-stepping-1"><a class="docs-heading-anchor" href="#Advanced-stepping-1">Advanced stepping</a><a class="docs-heading-anchor-permalink" href="#Advanced-stepping-1" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Current step number</header><div class="admonition-body"><p>Notice that the current step number is not explicitly given to the <code>model_step!</code> function, because this is useful only for a subset of ABMs. If you need the step information, implement this by adding a counting parameter into the model <code>properties</code>, and incrementing it by 1 each time <code>model_step!</code> is called. An example can be seen in the <code>model_step!</code> function of <a href="@ref">Daisyworld</a>, where a <code>tick</code> is increased at each step.</p></div></div><p>The interface of <a href="#Agents.step!"><code>step!</code></a>, which allows the option of both <code>agent_step!</code> and <code>model_step!</code> is driven mostly by convenience. In principle, the <code>model_step!</code> function by itself can perform all operations related with stepping the ABM. However, for many models, this simplified approach offers the benefit of not having to write an explicit loop over existing agents inside the <code>model_step!</code>. Most of the examples in our documentation can be expressed using an independent <code>agent_step!</code> and <code>model_step!</code> function.</p><p>On the other hand, more advanced models require special handling for scheduling, or may need to schedule several times and act on different subsets of agents with different functions. In such a scenario, it is more sensible to provide only a <code>model_step!</code> function (and use <code>dummystep</code> as <code>agent_step!</code>), where all configuration is contained within. Notice that if you follow this road, the argument <code>scheduler</code> given to <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> somewhat loses its meaning.</p><p>Here is an example:</p><pre><code class="language-julia">function complex_step!(model)
    for id in scheduler1(model)
        agent_step1!(model[id], model)
    end
    intermediate_model_action!(model)
    for id in scheduler2(model)
        agent_step2!(model[id], model)
    end
    if model.step_counter % 100 == 0
        model_action_every_100_steps!(model)
    end
    final_model_action!(model)
end

step!(model, dummystep, complex_step!, n)</code></pre><p>For defining your own schedulers, see <a href="../api/#Schedulers-1">Schedulers</a>.</p><h2 id=".-Visualizations-1"><a class="docs-heading-anchor" href="#.-Visualizations-1">5. Visualizations</a><a class="docs-heading-anchor-permalink" href="#.-Visualizations-1" title="Permalink"></a></h2><p>Once you have defined a model and the stepping functions you can visualize the model statically or animate its time evolution straightforwardly in ~5 lines of code. This is discussed in a different page: <a href="../agents_visualizations/#Visualizations-and-Animations-for-Agent-Based-Models-1">Visualizations and Animations for Agent Based Models</a>. Furthermore, all models in the Examples showcase plotting.</p><h2 id=".-Collecting-data-1"><a class="docs-heading-anchor" href="#.-Collecting-data-1">6. Collecting data</a><a class="docs-heading-anchor-permalink" href="#.-Collecting-data-1" title="Permalink"></a></h2><p>Running the model and collecting data while the model runs is done with the <a href="#Agents.run!"><code>run!</code></a> function. Besides <code>run!</code>, there is also the <a href="../api/#Agents.paramscan"><code>paramscan</code></a> function that performs data collection while scanning ranges of the parameters of the model, and the <a href="../api/#Agents.ensemblerun!"><code>ensemblerun!</code></a> that performs ensemble simulations and data collection.</p><article class="docstring"><header><a class="docstring-binding" id="Agents.run!" href="#Agents.run!"><code>Agents.run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">run!(model, agent_step! [, model_step!], n::Integer; kwargs...) → agent_df, model_df
run!(model, agent_step!, model_step!, n::Function; kwargs...) → agent_df, model_df</code></pre><p>Run the model (step it with the input arguments propagated into <a href="#Agents.step!"><code>step!</code></a>) and collect data specified by the keywords, explained one by one below. Return the data as two <code>DataFrame</code>s, one for agent-level data and one for model-level data.</p><p><strong>Data-deciding keywords</strong></p><ul><li><p><code>adata::Vector</code> means &quot;agent data to collect&quot;. If an entry is a <code>Symbol</code>, e.g. <code>:weight</code>, then the data for this entry is agent&#39;s field <code>weight</code>. If an entry is a <code>Function</code>, e.g. <code>f</code>, then the data for this entry is just <code>f(a)</code> for each agent <code>a</code>. The resulting dataframe columns are named with the input symbol (here <code>:weight, :f</code>).</p></li><li><p><code>adata::Vector{&lt;:Tuple}</code>: if <code>adata</code> is a vector of tuples instead, data aggregation is done over the agent properties.</p><p>For each 2-tuple, the first entry is the &quot;key&quot; (any entry like the ones mentioned above, e.g. <code>:weight, f</code>). The second entry is an aggregating function that aggregates the key, e.g. <code>mean, maximum</code>. So, continuing from the above example, we would have <code>adata = [(:weight, mean), (f, maximum)]</code>.</p><p>It&#39;s also possible to provide a 3-tuple, with the third entry being a conditional function (returning a <code>Bool</code>), which assesses if each agent should be included in the aggregate. For example: <code>x_pos(a) = a.pos[1]&gt;5</code> with <code>(:weight, mean, x_pos)</code> will result in the average weight of agents conditional on their x-position being greater than 5.</p><p>The resulting data name columns use the function <a href="../api/#Agents.dataname"><code>dataname</code></a>. They create something like <code>:mean_weight</code> or <code>:maximum_f_x_pos</code>. In addition, you can use anonymous functions in a list comprehension to assign elements of an array into different columns: <code>adata = [(a)-&gt;(a.interesting_array[i]) for i=1:N]</code>. Column names can also be renamed with <code>DataFrames.rename!</code> after data is collected.</p><p><strong>Notice:</strong> Aggregating only works if there are agents to be aggregated over. If you remove agents during model run, you should modify the aggregating functions. <em>E.g.</em> instead of passing <code>mean</code>, pass <code>mymean(a) = isempty(a) ? 0.0 : mean(a)</code>.</p></li><li><p><code>mdata::Vector</code> means &quot;model data to collect&quot; and works exactly like <code>adata</code>. For the model, no aggregation is possible (nothing to aggregate over).</p><p>Alternatively, <code>mdata</code> can also be a function. This is a &quot;generator&quot; function, that accepts <code>model</code> as input and provides a <code>Vector</code> that represents <code>mdata</code>. Useful in combination with an <a href="../api/#Agents.ensemblerun!"><code>ensemblerun!</code></a> call that requires a generator function.</p></li></ul><p>By default both keywords are <code>nothing</code>, i.e. nothing is collected/aggregated.</p><p><strong>Mixed-Models</strong></p><p>For mixed-models, the <code>adata</code> keyword has some additional options &amp; properties. An additional column <code>agent_type</code> will be placed in the output dataframe.</p><p>In the case that data is needed for one agent type that does not exist in a second agent type, <code>missing</code> values will be added to the dataframe.</p><p><strong>Warning:</strong> Since this option is inherently type unstable, try to avoid this in a performance critical situation.</p><p>Aggregate functions will fail if <code>missing</code> values are not handled explicitly. If <code>a1.weight</code> but <code>a2</code> (type: Agent2) has no <code>weight</code>, use <code>a2(a) = a isa Agent2; adata = [(:weight, sum, a2)]</code> to filter out the missing results.</p><p><strong>Other keywords</strong></p><ul><li><code>when=true</code> : at which steps <code>s</code> to perform the data collection and processing. A lot of flexibility is offered based on the type of <code>when</code>. If <code>when::AbstractVector</code>, then data are collected if <code>s ∈ when</code>. Otherwise data are collected if <code>when(model, s)</code> returns <code>true</code>. By default data are collected in every step.</li><li><code>when_model = when</code> : same as <code>when</code> but for model data.</li><li><code>obtainer = identity</code> : method to transfer collected data to the <code>DataFrame</code>. Typically only change this to <a href="https://docs.julialang.org/en/v1/base/base/#Base.copy"><code>copy</code></a> if some data are mutable containers (e.g. <code>Vector</code>) which change during evolution, or <a href="https://docs.julialang.org/en/v1/base/base/#Base.deepcopy"><code>deepcopy</code></a> if some data are nested mutable containers. Both of these options have performance penalties.</li><li><code>agents_first=true</code> : Whether to update agents first and then the model, or vice versa.</li><li><code>showprogress=false</code> : Whether to show a progress bar.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/Agents.jl/blob/a4dcbe8f61fe5f33c1982483e977b8299a99a2e7/src/simulations/collect.jl#L29-L105">source</a></section></article><p>The <a href="#Agents.run!"><code>run!</code></a> function has been designed for maximum flexibility: nearly all scenarios of data collection are possible whether you need agent data, model data, aggregated data, or arbitrary combinations.</p><p>Nevertheless, we also expose a simple data-collection API (see <a href="../api/#Data-collection-1">Data collection</a>), that gives users even more flexibility, allowing them to make their own &quot;data collection loops&quot; arbitrarily calling <code>step!</code> and collecting data as, and when, needed.</p><p>As your models become more complex, it may not be advantageous to use lots of helper functions in the global scope to assist with data collection. If this is the case in your model, here&#39;s a helpful tip to keep things clean: use a generator function to collect data as instructed in the documentation string of <a href="#Agents.run!"><code>run!</code></a>. For example:</p><pre><code class="language-julia">function assets(model)
    total_savings(model) = model.bank_balance + sum(model.assets)
    function stategy(model)
        if model.year == 0
            return model.initial_strategy
        else
            return get_strategy(model)
        end
    end
    return [:age, :details, total_savings, strategy]
end
run!(model, agent_step!, model_step!, 10; mdata = assets)</code></pre><h2 id="Seeding-and-Random-numbers-1"><a class="docs-heading-anchor" href="#Seeding-and-Random-numbers-1">Seeding and Random numbers</a><a class="docs-heading-anchor-permalink" href="#Seeding-and-Random-numbers-1" title="Permalink"></a></h2><p>Each model created by <a href="#Agents.AgentBasedModel"><code>AgentBasedModel</code></a> provides a random number generator pool <code>model.rng</code> which by default coincides with the global RNG. For performance and reproducibility reasons, one should never use <code>rand()</code> without using a pool, thus throughout our examples we use <code>rand(model.rng)</code> or <code>rand(model.rng, 1:10, 100)</code>, etc.</p><p>Another benefit of this approach is deterministic models that can be run again and yield the same output. To do this, always pass a specifically seeded RNG to the model creation, e.g. <code>rng = Random.MersenneTwister(1234)</code>.</p><p>Passing <code>RandomDevice()</code> will use the system&#39;s entropy source (coupled with hardware like <a href="https://ubld.it/truerng_v3">TrueRNG</a> will invoke a true random source, rather than pseudo-random methods like <code>MersenneTwister</code>). Models using this method cannot be repeatable, but avoid potential biases of pseudo-randomness.</p><h2 id="An-educative-example-1"><a class="docs-heading-anchor" href="#An-educative-example-1">An educative example</a><a class="docs-heading-anchor-permalink" href="#An-educative-example-1" title="Permalink"></a></h2><p>A simple, education-oriented example of using the basic Agents.jl API is given in <a href="../examples/schelling/#Schelling&#39;s-segregation-model-1">Schelling&#39;s segregation model</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../examples/schelling/">Schelling&#39;s segregation model »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 11 March 2023 09:38">Saturday 11 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
